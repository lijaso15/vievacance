{"ast":null,"code":"/**\r\n * Module that defines everything related to building Funnel slices.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../../core/Container\";\nimport { Sprite } from \"../../core/Sprite\";\nimport { registry } from \"../../core/Registry\";\nimport { percent } from \"../../core/utils/Percent\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $path from \"../../core/rendering/Path\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Class used to create [[FunnelSlice]] elements.\r\n *\r\n * @see {@link IFunnelSliceEvents} for a list of available events\r\n * @see {@link IFunnelSliceAdapters} for a list of available adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for documentation\r\n * @important\r\n */\n\nvar FunnelSlice =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(FunnelSlice, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function FunnelSlice() {\n    var _this = _super.call(this) || this;\n\n    _this.slice = _this.createChild(Sprite);\n    _this.slice.shouldClone = false;\n\n    _this.slice.setElement(_this.paper.add(\"path\"));\n\n    _this.slice.isMeasured = false;\n    _this.orientation = \"vertical\";\n    _this.bottomWidth = percent(100);\n    _this.topWidth = percent(100);\n    _this.isMeasured = false;\n    _this.width = 10;\n    _this.height = 10;\n    _this.expandDistance = 0;\n    _this.className = \"FunnelSlice\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Draws the element.\r\n   */\n\n\n  FunnelSlice.prototype.draw = function () {\n    _super.prototype.draw.call(this);\n\n    var pt = this.pixelPaddingTop;\n    var pb = this.pixelPaddingBottom;\n    var pr = this.pixelPaddingRight;\n    var pl = this.pixelPaddingLeft;\n    var w = this.pixelWidth - pr - pl;\n    var h = this.pixelHeight - pt - pb;\n    var ed = this.expandDistance;\n    var path = \"\";\n\n    if (this.orientation == \"vertical\") {\n      var tw = $utils.relativeToValue(this.topWidth, w);\n      var bw = $utils.relativeToValue(this.bottomWidth, w);\n      var tl = {\n        x: (w - tw) / 2 + pl,\n        y: pt\n      };\n      var tr = {\n        x: (w + tw) / 2 + pl,\n        y: pt\n      };\n      var br = {\n        x: (w + bw) / 2 + pl,\n        y: pt + h\n      };\n      var bl = {\n        x: (w - bw) / 2 + pl,\n        y: pt + h\n      };\n      var cpr = {\n        x: tr.x + (br.x - tr.x) / 2 + ed * h,\n        y: tr.y + 0.5 * h\n      };\n      var cpl = {\n        x: tl.x + (bl.x - tl.x) / 2 - ed * h,\n        y: tl.y + 0.5 * h\n      };\n      var qp1 = $path.lineTo(br);\n      var qp2 = \"\";\n\n      if (ed != 0) {\n        qp1 = $path.quadraticCurveTo(br, cpr);\n        qp2 = $path.quadraticCurveTo(tl, cpl);\n      }\n\n      path = $path.moveTo(tl) + $path.lineTo(tr) + qp1 + $path.lineTo(bl) + qp2;\n      this.tickPoint = {\n        x: tr.x + (br.x - tr.x) / 2,\n        y: tr.y + (br.y - tr.y) / 2\n      };\n    } else {\n      var tw = $utils.relativeToValue(this.topWidth, h);\n      var bw = $utils.relativeToValue(this.bottomWidth, h);\n      var tt = {\n        x: pl,\n        y: (h - tw) / 2 + pt\n      };\n      var tb = {\n        x: pl,\n        y: (h + tw) / 2 + pt\n      };\n      var bt = {\n        x: pl + w,\n        y: (h - bw) / 2 + pt\n      };\n      var bb = {\n        x: pl + w,\n        y: (h + bw) / 2 + pt\n      };\n      var cpr = {\n        y: tt.y + (bt.y - tt.y) / 2 - ed * w,\n        x: tt.x + 0.5 * w\n      };\n      var cpl = {\n        y: tb.y + (bb.y - tb.y) / 2 + ed * w,\n        x: tb.x + 0.5 * w\n      };\n      var qp1 = $path.lineTo(bt);\n      var qp2 = \"\";\n\n      if (ed != 0) {\n        qp1 = $path.quadraticCurveTo(bt, cpr);\n        qp2 = $path.quadraticCurveTo(tb, cpl);\n      }\n\n      path = $path.moveTo(tb) + $path.lineTo(tt) + qp1 + $path.lineTo(bb) + qp2;\n      this.tickPoint = {\n        y: tb.y + (bb.y - tb.y) / 2,\n        x: tb.x + (bb.x - tb.x) / 2\n      };\n    }\n\n    this.slice.path = path;\n    this.invalidateLayout();\n  };\n\n  FunnelSlice.prototype.getPoint = function (locationX, locationY) {\n    var pt = this.pixelPaddingTop;\n    var pb = this.pixelPaddingBottom;\n    var pr = this.pixelPaddingRight;\n    var pl = this.pixelPaddingLeft;\n    var w = this.pixelWidth - pr - pl;\n    var h = this.pixelHeight - pt - pb;\n\n    if (this.orientation == \"vertical\") {\n      var tw = $utils.relativeToValue(this.topWidth, w);\n      var bw = $utils.relativeToValue(this.bottomWidth, w);\n      var tl = {\n        x: (w - tw) / 2 + pl,\n        y: pt\n      };\n      var tr = {\n        x: (w + tw) / 2 + pl,\n        y: pt\n      };\n      var br = {\n        x: (w + bw) / 2 + pl,\n        y: pt + h\n      };\n      var bl = {\n        x: (w - bw) / 2 + pl,\n        y: pt + h\n      };\n      var mlx = tl.x + (bl.x - tl.x) * locationY;\n      var mrx = tr.x + (br.x - tr.x) * locationY;\n      return {\n        x: mlx + (mrx - mlx) * locationX,\n        y: tr.y + (br.y - tr.y) * locationY\n      };\n    } else {\n      var tw = $utils.relativeToValue(this.topWidth, h);\n      var bw = $utils.relativeToValue(this.bottomWidth, h);\n      var tt = {\n        x: pl,\n        y: (h - tw) / 2 + pt\n      };\n      var tb = {\n        x: pl,\n        y: (h + tw) / 2 + pt\n      };\n      var bt = {\n        x: pl + w,\n        y: (h - bw) / 2 + pt\n      };\n      var bb = {\n        x: pl + w,\n        y: (h + bw) / 2 + pt\n      };\n      var mty = tt.y + (bt.y - tt.y) * locationX;\n      var mby = tb.y + (bb.y - tb.y) * locationX;\n      return {\n        y: mty + (mby - mty) * locationY,\n        x: tt.x + (bt.x - tt.x) * locationX\n      };\n    }\n  };\n\n  Object.defineProperty(FunnelSlice.prototype, \"bottomWidth\", {\n    /**\r\n     * @return bottom width\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"bottomWidth\");\n    },\n\n    /**\r\n     * Bottom width in pixels or percent.\r\n     *\r\n     * IMPORTANT: this setting might be used to set dimensions if you use slice\r\n     * as a standalone element. If it's a part of [[FunnelSeries]] this setting\r\n     * becomes read-only as it will be automatically reset by series.\r\n     *\r\n     * @param value  Bottom width\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"bottomWidth\", value, true, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FunnelSlice.prototype, \"topWidth\", {\n    /**\r\n     * @return Top width\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"topWidth\");\n    },\n\n    /**\r\n     * Top width in pixels or percent.\r\n     *\r\n     * IMPORTANT: this setting might be used to set dimensions if you use slice\r\n     * as a standalone element. If it's a part of [[FunnelSeries]] this setting\r\n     * becomes read-only as it will be automatically reset by series.\r\n     *\r\n     * @param value  Top width\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"topWidth\", value, true, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FunnelSlice.prototype, \"orientation\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"orientation\");\n    },\n\n    /**\r\n     * Orientation of the funnel slice: \"horizontal\" or \"vertical\".\r\n     *\r\n     * IMPORTANT: this setting might be used to set orintation if you use slice\r\n     * as a standalone element. If it's a part of [[FunnelSeries]] this setting\r\n     * becomes read-only as it will be automatically reset by series.\r\n     *\r\n     * @param value  Orientation\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"orientation\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FunnelSlice.prototype, \"expandDistance\", {\n    /**\r\n     * @return expandDistance\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"expandDistance\");\n    },\n\n    /**\r\n     * A relative distance slice's sides should be bent to. It's relative to the\r\n     * height of the slice.\r\n     *\r\n     * Zero (default) will mean the sides will be perfectly straight.\r\n     *\r\n     * Positive value will make them bend outwards, resulting in \"puffed\" slices.\r\n     *\r\n     * Negative values will make them bend inwards.\r\n     *\r\n     * @default 0\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"expandDistance\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all parameters from another [[Sprite]].\r\n   *\r\n   * @param source Source Sprite\r\n   */\n\n  FunnelSlice.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    if (this.slice) {\n      this.slice.copyFrom(source.slice);\n    }\n  };\n\n  return FunnelSlice;\n}(Container);\n\nexport { FunnelSlice };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"FunnelSlice\"] = FunnelSlice;","map":null,"metadata":{},"sourceType":"module"}