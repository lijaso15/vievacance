{"ast":null,"code":"/**\r\n * Graticule (map grid) series functionality.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { MapLineSeries, MapLineSeriesDataItem } from \"./MapLineSeries\";\nimport { Graticule } from \"./Graticule\";\nimport { registry } from \"../../core/Registry\";\nimport * as d3geo from \"d3-geo\";\nimport * as $array from \"../../core/utils/Array\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[GraticuleSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar GraticuleSeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(GraticuleSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function GraticuleSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"GraticuleSeriesDataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  return GraticuleSeriesDataItem;\n}(MapLineSeriesDataItem);\n\nexport { GraticuleSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * This class is used to create a set of graticules (map grid).\r\n *\r\n * To enable, create like you would create any regular map series:\r\n *\r\n * ```TypeScript\r\n * let graticule = chart.series.push(new am4maps.GraticuleSeries())\r\n * graticule.mapLines.template.line.stroke = am4core.color(\"#000000\");\r\n * graticule.mapLines.template.line.strokeOpacity = 0.1;\r\n * ```\r\n * ```JavaScript\r\n * var graticule = chart.series.push(new am4maps.GraticuleSeries())\r\n * graticule.mapLines.template.line.stroke = am4core.color(\"#000000\");\r\n * graticule.mapLines.template.line.strokeOpacity = 0.1;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"series\": [{\r\n *     \"type\": \"GraticuleSeries\",\r\n *     \"mapLines\": {\r\n *       \"line\": {\r\n *         \"stroke\": \"#000000\",\r\n *         \"strokeOpacity\": 0.1\r\n *       }\r\n *     }\r\n *   }]\r\n * }\r\n * ```\r\n *\r\n * @since 4.3.0\r\n * @see {@link IGraticuleSeriesEvents} for a list of available Events\r\n * @see {@link IGraticuleSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar GraticuleSeries =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(GraticuleSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function GraticuleSeries() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"GraticuleSeries\";\n    _this.longitudeStep = 10;\n    _this.latitudeStep = 10;\n    _this.north = 90;\n    _this.south = -90;\n    _this.east = -180;\n    _this.west = 180; //this.majorLatitudeStep = 90;\n    //this.majorLongitudeStep = 360;\n\n    _this.fitExtent = true;\n    _this.singleSprite = true;\n\n    _this.events.disableType(\"geoBoundsChanged\");\n\n    _this.mapLines.template.line.strokeOpacity = 0.08;\n    _this.ignoreBounds = false;\n    _this.hiddenInLegend = true;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  GraticuleSeries.prototype.createDataItem = function () {\n    return new GraticuleSeriesDataItem();\n  };\n\n  GraticuleSeries.prototype.validateData = function () {\n    var _this = this;\n\n    _super.prototype.validateData.call(this);\n\n    this.mapLines.clear();\n    var graticule = d3geo.geoGraticule();\n\n    if (graticule) {\n      graticule.stepMinor([this.longitudeStep, this.latitudeStep]);\n      graticule.stepMajor([360, 360]);\n      var chart = this.chart;\n\n      if (this.fitExtent) {\n        graticule.extent([[chart.east, chart.north], [chart.west, chart.south]]);\n      } else {\n        graticule.extent([[this.east, this.north], [this.west, this.south]]);\n      }\n\n      if (this.singleSprite) {\n        var mapLine = this.mapLines.create();\n        mapLine.multiLine = graticule().coordinates;\n      } else {\n        var lineStrings = graticule.lines();\n        $array.each(lineStrings, function (lineString) {\n          var mapLine = _this.mapLines.create();\n\n          mapLine.multiLine = [lineString.coordinates];\n        });\n      }\n    }\n  };\n  /**\r\n   * Returns a new line instance of suitable type.\r\n   *\r\n   * @return New line\r\n   */\n\n\n  GraticuleSeries.prototype.createLine = function () {\n    return new Graticule();\n  };\n\n  Object.defineProperty(GraticuleSeries.prototype, \"latitudeStep\", {\n    /**\r\n     * @return Step\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"latitudeStep\");\n    },\n\n    /**\r\n     * Draw a graticule (grid) every X degrees of latitude.\r\n     *\r\n     * @default 10\r\n     * @param  value Step\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"latitudeStep\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GraticuleSeries.prototype, \"longitudeStep\", {\n    /**\r\n     * @return Step\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"longitudeStep\");\n    },\n\n    /**\r\n     * Draw a graticule (grid) every X degrees of longitude.\r\n     *\r\n     * @default 10\r\n     * @param  value  Step\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"longitudeStep\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GraticuleSeries.prototype, \"fitExtent\", {\n    /**\r\n     * @return Fit?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fitExtent\");\n    },\n\n    /**\r\n     * Draw a thicker (major) graticule every X degrees of latitude.\r\n     *\r\n     * @default 90\r\n     * @param  value  Step\r\n     */\n    // public set majorLatitudeStep(value: number) {\n    // \tif (this.setPropertyValue(\"majorLatitudeStep\", value)) {\n    // \t\tthis.invalidateData();\n    // \t}\n    // }\n\n    /**\r\n     * @return Step\r\n     */\n    // public get majorLatitudeStep(): number {\n    // \treturn this.getPropertyValue(\"majorLatitudeStep\");\n    // }\n\n    /**\r\n     * Draw a thicker (major) graticule every X degrees of longitude.\r\n     *\r\n     * @default 360\r\n     * @param  value  Step\r\n     */\n    // public set majorLongitudeStep(value: number) {\n    // \tif (this.setPropertyValue(\"majorLongitudeStep\", value)) {\n    // \t\tthis.invalidateData();\n    // \t}\n    // }\n\n    /**\r\n     * @return Step\r\n     */\n    // public get majorLongitudeStep(): number {\n    // \treturn this.getPropertyValue(\"majorLongitudeStep\");\n    // }\n\n    /**\r\n     * Whether to cap graticules (grid) to actual span of the map (`true`), e.g.\r\n     * where there are polygons, or draw full-world grid (`false`).\r\n     *\r\n     * For world maps, using `false` makes sense. For smaller maps - not so much.\r\n     *\r\n     * If set to `false`, the grid will be drawn from this series `east` to\r\n     * `west`, and from `south` to `north` (default values: `east = -180`;\r\n     * `west = 180`; `south =-90`; `north =90`).\r\n     *\r\n     * These can be overridden by setting `GraticuleSeries`' respective\r\n     * properties.\r\n     *\r\n     * @default true\r\n     * @param  value  Fit?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"fitExtent\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GraticuleSeries.prototype, \"singleSprite\", {\n    /**\r\n     * @return Use single sprite?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"singleSprite\");\n    },\n\n    /**\r\n     * Whether to draw all the grid as a single element or as separate lines.\r\n     *\r\n     * Setting `true` (default) will result in better performance, whereas\r\n     * `false` allows setting visual properties of each line individually.\r\n     *\r\n     * @default true\r\n     * @param  value  Use single sprite?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"singleSprite\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return GraticuleSeries;\n}(MapLineSeries);\n\nexport { GraticuleSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"GraticuleSeries\"] = GraticuleSeries;\nregistry.registeredClasses[\"GraticuleSeriesDataItem\"] = GraticuleSeriesDataItem;","map":null,"metadata":{},"sourceType":"module"}