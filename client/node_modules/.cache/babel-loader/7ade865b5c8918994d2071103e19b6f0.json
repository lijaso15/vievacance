{"ast":null,"code":"/**\r\n * Morpher module contains functionality that allows morphing one polygon to\r\n * another.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../Base\";\nimport { Animation, AnimationDisposer } from \"../utils/Animation\";\nimport * as $math from \"../utils/Math\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Morpher can be used to morph one polygon to some other polygon.\r\n */\n\nvar Morpher =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Morpher, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param morphable An object to morph\r\n   */\n\n\n  function Morpher(morphable) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A storage for measurements.\r\n     */\n\n\n    _this._bboxes = [];\n    /**\r\n     * Duration of the morphing animation in milliseconds.\r\n     */\n\n    _this.morphDuration = 800;\n    /**\r\n     * An easing function to use for morphing animation.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n\n    _this.morphEasing = $ease.cubicOut;\n    /**\r\n     * If set to `true`, all separate parts of the multi-part polygon will\r\n     * morph into a single circle or polygon when using built-in methods\r\n     * `morphToCircle()` or `morphToPolygon()`.\r\n     *\r\n     * Otherwise each separate part of polygon will morph to individual target\r\n     * circle or polgyon.\r\n     */\n\n    _this.morphToSingle = true;\n    /**\r\n     * A ratio to scale morphed object in relation to the source object.\r\n     */\n\n    _this.scaleRatio = 1;\n    _this.className = \"Morpher\";\n    _this.morphable = morphable;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Morphs a polygon to another polygon.\r\n   *\r\n   * @param toPoints  Corner points of the target shape\r\n   * @param duration  Duration in milliseconds\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToPolygon = function (toPoints, duration, easing) {\n    var points = this.morphable.currentPoints;\n\n    if (points && toPoints) {\n      this.sortPoints(points);\n      this.sortPoints(toPoints);\n      this._morphFromPointsReal = [];\n      this._morphToPointsReal = [];\n\n      if (!$type.hasValue(duration)) {\n        duration = this.morphDuration;\n      }\n\n      if (!$type.hasValue(easing)) {\n        easing = this.morphEasing;\n      }\n\n      this._morphFromPointsReal = this.normalizePoints(toPoints, points);\n      this._morphToPointsReal = this.normalizePoints(points, toPoints);\n      this.morphable.currentPoints = this._morphFromPointsReal;\n      var animation = new Animation(this, {\n        property: \"morphProgress\",\n        from: 0,\n        to: 1\n      }, duration, easing);\n\n      this._disposers.push(animation);\n\n      animation.start();\n      return animation;\n    }\n  };\n  /**\r\n   * [normalizePoints description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param pointsA  Point A\r\n   * @param pointsB  Point B\r\n   * @return Normalized points\r\n   */\n\n\n  Morpher.prototype.normalizePoints = function (pointsA, pointsB) {\n    for (var i = 0, len = pointsA.length; i < len; i++) {\n      var surfaceA = pointsA[i][0];\n      var holeA = pointsA[i][1];\n      var bboxA = $type.getValue($math.getBBox(surfaceA));\n      var middleX = bboxA.x + bboxA.width;\n      var middleY = bboxA.y + bboxA.height; // check if we have the same in PointsB\n\n      if (!pointsB[i]) {\n        pointsB[i] = [];\n      } // check if we have surface in pointsB\n\n\n      if (surfaceA && !pointsB[i][0]) {\n        pointsB[i][0] = [{\n          x: middleX,\n          y: middleY\n        }, {\n          x: middleX,\n          y: middleY\n        }];\n      }\n\n      if (pointsB[i][0]) {\n        pointsB[i][0] = this.addPoints(pointsB[i][0], surfaceA.length);\n        var distance = Infinity;\n        var splitAt = 0;\n\n        for (var a = 0; a < pointsB[i][0].length; a++) {\n          var newDistance = $math.getDistance(pointsB[i][0][a], surfaceA[0]);\n\n          if (newDistance < distance) {\n            splitAt = a;\n            distance = newDistance;\n          }\n        }\n\n        var partA = pointsB[i][0].slice(0, splitAt);\n        var partB = pointsB[i][0].slice(splitAt);\n        pointsB[i][0] = partB.concat(partA);\n      }\n\n      if (holeA) {\n        if (!pointsB[i][1]) {\n          pointsB[i][1] = [{\n            x: middleX,\n            y: middleY\n          }, {\n            x: middleX,\n            y: middleY\n          }];\n        }\n\n        pointsB[i][1] = this.addPoints(pointsB[i][1], holeA.length);\n      }\n    }\n\n    return pointsB;\n  };\n  /**\r\n   * [sortPoints description]\r\n   *\r\n   * @ignore Exclude from doc\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return                        common bbox of points\r\n   */\n\n\n  Morpher.prototype.sortPoints = function (points) {\n    points.sort(function (a, b) {\n      var bbox1 = $type.getValue($math.getBBox(a[0]));\n      var bbox2 = $type.getValue($math.getBBox(b[0]));\n\n      if (bbox1.width * bbox1.height > bbox2.width * bbox2.height) {\n        return -1;\n      } else {\n        return 1;\n      }\n    });\n    var bboxes = [];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n\n      if (surface) {\n        bboxes.push($type.getValue($math.getBBox(surface)));\n      }\n    }\n\n    return $math.getCommonRectangle(bboxes);\n  };\n  /**\r\n   * Morphs polygon to a circle (it is actually a polygon which makes a circle).\r\n   *\r\n   * @param radius    Target circle radius (px)\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToCircle = function (radius, duration, easing) {\n    var points = this.morphable.points;\n    var commonBBox = this.sortPoints(points);\n    this._morphFromPointsReal = [];\n    this._morphToPointsReal = [];\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    } // surface\n\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      var hole = points[i][1];\n      this._morphFromPointsReal[i] = [];\n      this._morphToPointsReal[i] = [];\n\n      if (surface) {\n        var toPoints = surface;\n        var fromPoints = surface;\n        var bbox = $type.getValue($math.getBBox(fromPoints)); // this._bboxes[i];\n\n        if (this.morphToSingle) {\n          bbox = $type.getValue(commonBBox);\n        }\n\n        var middleX = bbox.x + bbox.width / 2;\n        var middleY = bbox.y + bbox.height / 2;\n        var realRadius = radius;\n\n        if (!$type.isNumber(realRadius)) {\n          realRadius = Math.min(bbox.width / 2, bbox.height / 2);\n        }\n\n        toPoints = []; // find angle for the first point\n\n        var startAngle = $math.getAngle({\n          x: middleX,\n          y: middleY\n        }, surface[0]);\n        var count = 100;\n\n        if (surface.length > count) {\n          count = surface.length;\n        }\n\n        fromPoints = this.addPoints(surface, count);\n        count = fromPoints.length; // add Points might increase number a bit\n\n        var angle = 360 / (count - 1);\n\n        for (var a = 0; a < count; a++) {\n          var realAngle = angle * a + startAngle;\n          var pointOnCircle = {\n            x: middleX + realRadius * $math.cos(realAngle),\n            y: middleY + realRadius * $math.sin(realAngle)\n          };\n          toPoints[a] = pointOnCircle;\n        }\n\n        if (hole && hole.length > 0) {\n          for (var i_1 = 0, hlen = hole.length; i_1 < hlen; i_1++) {\n            toPoints.push({\n              x: middleX,\n              y: middleY\n            });\n          }\n        }\n\n        this._morphFromPointsReal[i][0] = fromPoints;\n        this._morphToPointsReal[i][0] = toPoints;\n      }\n    }\n\n    this.morphable.currentPoints = this._morphFromPointsReal;\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n  /**\r\n   * [addPoints description]\r\n   *\r\n   * @ignore Exclude from doc\r\n   * @todo Description\r\n   * @param points         [description]\r\n   * @param mustHaveCount  [description]\r\n   * @return [description]\r\n   */\n\n\n  Morpher.prototype.addPoints = function (points, mustHaveCount) {\n    var addToSegmentCount = Math.round(mustHaveCount / points.length);\n    var newPoints = [];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point0 = points[i];\n      var point1 = void 0;\n\n      if (i == points.length - 1) {\n        point1 = points[0];\n      } else {\n        point1 = points[i + 1];\n      }\n\n      newPoints.push(point0);\n\n      for (var p = 1; p < addToSegmentCount; p++) {\n        var percent = p / addToSegmentCount;\n        var extraPoint = {\n          x: point0.x + (point1.x - point0.x) * percent,\n          y: point0.y + (point1.y - point0.y) * percent\n        };\n        newPoints.push(extraPoint);\n      } // stop adding in case we already added more than left in original\n\n\n      if (newPoints.length + points.length - i == mustHaveCount) {\n        addToSegmentCount = 0;\n      }\n    }\n\n    if (newPoints.length < mustHaveCount && points.length > 0) {\n      var lastPoint = points[points.length - 1];\n\n      for (var p = newPoints.length; p < mustHaveCount; p++) {\n        // add same as last\n        newPoints.push({\n          x: lastPoint.x,\n          y: lastPoint.y\n        });\n      }\n    }\n\n    return newPoints;\n  };\n  /**\r\n   * Morphs polygon into a rectangular polygon.\r\n   *\r\n   * @param width     Width of the target rectangle (px)\r\n   * @param height    Height of the target rectangle (px)\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToRectangle = function (width, height, duration, easing) {\n    var points = this.morphable.points;\n    this.sortPoints(points);\n    this._morphFromPointsReal = [];\n    this._morphToPointsReal = [];\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    } //\t\tlet biggestBBox: IRectangle = this._bboxes[this._biggestIndex];\n    // surface\n\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      var hole = points[i][1];\n      this._morphFromPointsReal[i] = [];\n      this._morphToPointsReal[i] = [];\n\n      if (surface) {\n        var toPoints = surface;\n        var fromPoints = surface;\n        var bbox = this._bboxes[i]; // we only work with first area. TODO: maybe we should find the biggest one?\n\n        if (this.morphToSingle) {//if (i != this._biggestIndex) {\n          //\tbbox = { x: biggestBBox.x + biggestBBox.width / 2, y: biggestBBox.y + biggestBBox.height / 2, width: 0, height: 0 };\n          //}\n        }\n\n        var x = bbox.x;\n        var y = bbox.y;\n        var realWidth = width;\n        var realHeight = height;\n\n        if (!$type.isNumber(realWidth)) {\n          realWidth = bbox.width;\n        }\n\n        if (!$type.isNumber(realHeight)) {\n          realHeight = bbox.height;\n        }\n\n        toPoints = [{\n          x: x,\n          y: y\n        }, {\n          x: x + realWidth,\n          y: y\n        }, {\n          x: x + realWidth,\n          y: y + realHeight\n        }, {\n          x: x,\n          y: y + realHeight\n        }];\n        toPoints = this.addPoints(toPoints, surface.length); // if polygon has less points then count, add\n\n        if (surface.length < 4) {\n          for (var i_2 = surface.length; i_2 < 4; i_2++) {\n            toPoints.push({\n              x: surface[i_2].x,\n              y: surface[i_2].y\n            });\n          }\n        }\n\n        if (hole && hole.length > 0) {\n          var middleX = bbox.x + bbox.width / 2;\n          var middleY = bbox.y + bbox.height / 2;\n\n          for (var i_3 = 0, hlen = hole.length; i_3 < hlen; i_3++) {\n            toPoints.push({\n              x: middleX,\n              y: middleY\n            });\n          }\n        }\n\n        this._morphFromPointsReal[i][0] = fromPoints;\n        this._morphToPointsReal[i][0] = toPoints;\n      }\n    }\n\n    this.morphable.currentPoints = this._morphFromPointsReal;\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n\n  Object.defineProperty(Morpher.prototype, \"morphProgress\", {\n    /**\r\n     * Returns the progress of morph transition.\r\n     *\r\n     * @return Progress (0-1)\r\n     */\n    get: function () {\n      return this._morphProgress;\n    },\n\n    /**\r\n     * Progress of the morph transition.\r\n     *\r\n     * Setting this will also trigger actual transformation.\r\n     *\r\n     * @param value  Progress (0-1)\r\n     */\n    set: function (value) {\n      this._morphProgress = value;\n      var currentPoints = [];\n\n      if (value != null) {\n        var fromPoints = this._morphFromPointsReal;\n        var toPoints = this._morphToPointsReal;\n\n        if (fromPoints != null && toPoints != null) {\n          for (var i = 0, len = fromPoints.length; i < len; i++) {\n            var currentArea = [];\n            currentPoints.push(currentArea);\n            var surfaceFrom = fromPoints[i][0];\n            var holeFrom = fromPoints[i][1];\n            var surfaceTo = toPoints[i][0];\n            var holeTo = toPoints[i][1];\n\n            if (surfaceFrom && surfaceFrom.length > 0 && surfaceTo && surfaceTo.length > 0) {\n              var currentSurface = [];\n\n              for (var i_4 = 0, slen = surfaceFrom.length; i_4 < slen; i_4++) {\n                var point0 = surfaceFrom[i_4];\n                var point1 = surfaceTo[i_4];\n                var currentPoint = {\n                  x: point0.x + (point1.x * this.scaleRatio - point0.x) * value,\n                  y: point0.y + (point1.y * this.scaleRatio - point0.y) * value\n                };\n                currentSurface.push(currentPoint);\n              }\n\n              currentArea[0] = currentSurface;\n            }\n\n            if (holeFrom && holeFrom.length > 0 && holeTo && holeTo.length > 0) {\n              var currentHole = [];\n\n              for (var i_5 = 0, hlen = holeFrom.length; i_5 < hlen; i_5++) {\n                var point0 = holeFrom[i_5];\n                var point1 = holeTo[i_5];\n                var currentPoint = {\n                  x: point0.x + (point1.x * this.scaleRatio - point0.x) * value,\n                  y: point0.y + (point1.y * this.scaleRatio - point0.y) * value\n                };\n                currentHole.push(currentPoint);\n              }\n\n              currentArea[1] = currentHole;\n            }\n          }\n        }\n      }\n\n      this.morphable.currentPoints = currentPoints;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Restores the polygon to its original appearance.\r\n   *\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n  Morpher.prototype.morphBack = function (duration, easing) {\n    this._morphToPointsReal = this._morphFromPointsReal;\n    this._morphFromPointsReal = this.morphable.currentPoints;\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    }\n\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n\n  Object.defineProperty(Morpher.prototype, \"animations\", {\n    /**\r\n     * Returns a list of morph animations currently being played.\r\n     *\r\n     * @return List of animations\r\n     */\n    get: function () {\n      if (!this._animations) {\n        this._animations = [];\n\n        this._disposers.push(new AnimationDisposer(this._animations));\n      }\n\n      return this._animations;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Morpher;\n}(BaseObject);\n\nexport { Morpher };","map":null,"metadata":{},"sourceType":"module"}