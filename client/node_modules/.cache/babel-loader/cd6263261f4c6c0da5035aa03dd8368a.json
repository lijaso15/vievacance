{"ast":null,"code":"/**\r\n * ExportMenu provides functionality for building Export menu\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport exportCSS from \"./ExportCSS\";\nimport { Adapter } from \"../utils/Adapter\";\nimport { List } from \"../utils/List\";\nimport { getInteraction } from \"../interaction/Interaction\";\nimport { MutableValueDisposer } from \"../utils/Disposer\";\nimport { Language } from \"../utils/Language\";\nimport { Validatable } from \"../utils/Validatable\";\nimport { keyboard } from \"../utils/Keyboard\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $iter from \"../utils/Iterator\";\nimport * as $dom from \"../utils/DOM\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a menu for Export operations.\r\n *\r\n * To add an export menu to a chart, set this to a new instance of\r\n * [[ExportMenu]].\r\n *\r\n * ```TypeScript\r\n * chart.exporting.menu = new am4core.ExportMenu();\r\n * ```\r\n * ```JavaScript\r\n * chart.exporting.menu = new am4core.ExportMenu();\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"exporting\": {\r\n *     \"menu\": {}\r\n *   }\r\n * }\r\n * ```\r\n * @important\r\n */\n\nvar ExportMenu =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ExportMenu, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ExportMenu() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * An [[Adapter]].\r\n     */\n\n\n    _this.adapter = new Adapter(_this);\n    /**\r\n     * How many milliseconds to hold menu/sub-menu open after it loses focus or\r\n     * hover, before auto-closing it.\r\n     *\r\n     * @default 1000\r\n     */\n\n    _this.closeDelay = 1000;\n    /**\r\n     * Close the menu automatically when some export operation is triggered.\r\n     *\r\n     * @default true\r\n     * @since 4.2.2\r\n     */\n\n    _this.closeOnClick = true;\n    /**\r\n     * An instance of [[Language]].\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._language = new MutableValueDisposer();\n    /**\r\n     * What HTML tags to use to build menu.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._menuTag = \"ul\";\n    /**\r\n     * Which tag to use to enclose individual menu items.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._itemTag = \"li\";\n    /**\r\n     * Tag to wrap menu item labels in.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._labelTag = \"a\";\n    /**\r\n     * Prefix for class names applied to menu elements.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._classPrefix = \"amexport\";\n    /**\r\n     * If set to `true` [[ExportMenu]] will load it's own external CSS when\r\n     * instantiated.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._defaultStyles = true;\n    /**\r\n     * Horizontal positioning.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._align = \"right\";\n    /**\r\n     * Vertical positioning.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._verticalAlign = \"top\";\n    /**\r\n     * A tabindex to apply to Export Menu.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._tabindex = 0;\n    /**\r\n     * Whether next menu close event should be ignored.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._ignoreNextClose = false;\n    /**\r\n     * Default menu items.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._items = [{\n      \"label\": \"...\",\n      \"menu\": [{\n        \"label\": \"Image\",\n        \"menu\": [{\n          \"type\": \"png\",\n          \"label\": \"PNG\"\n        }, {\n          \"type\": \"jpg\",\n          \"label\": \"JPG\"\n        }, {\n          \"type\": \"gif\",\n          \"label\": \"GIF\"\n        }, {\n          \"type\": \"svg\",\n          \"label\": \"SVG\"\n        }, {\n          \"type\": \"pdf\",\n          \"label\": \"PDF\"\n        }]\n      }, {\n        \"label\": \"Data\",\n        \"menu\": [{\n          \"type\": \"json\",\n          \"label\": \"JSON\"\n        }, {\n          \"type\": \"csv\",\n          \"label\": \"CSV\"\n        }, {\n          \"type\": \"xlsx\",\n          \"label\": \"XLSX\"\n        }]\n      }, {\n        \"label\": \"Print\",\n        \"type\": \"print\"\n      }]\n    }];\n    _this.className = \"ExportMenu\";\n\n    _this._disposers.push(_this._language);\n\n    _this.invalidate();\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * (Re)draws the Export menu.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ExportMenu.prototype.validate = function () {\n    this.draw();\n\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * Draws the menu based on current items.\r\n   *\r\n   * Normally, there's no need to call this explicitly. The chart, if it has\r\n   * export menu enabled, will automatically draw the menu.\r\n   */\n\n\n  ExportMenu.prototype.draw = function () {\n    var _this = this; // Create top-level menu item, or clear it\n\n\n    if (!this._element) {\n      this._element = this.createMenuElement(0);\n    } else {\n      this._element.innerHTML = \"\";\n      this._element.className = this.getMenuItemClass(0);\n    } // See if we're loading external CSS\n    // Hide it until CSS is loaded\n\n\n    if (this.defaultStyles) {\n      this._element.style.display = \"none\";\n    } // Append to container\n\n\n    $type.getValue(this._container).appendChild(this._element); // Apply adapter to menu items before processing\n\n    this._items = this.adapter.apply(\"items\", {\n      items: this._items\n    }).items;\n\n    for (var len = this._items.length, i = 0; i < len; i++) {\n      this.drawBranch(this._element, this._items[i], 0);\n    } // Apply adapter to finalized menu element\n\n\n    this._element = this.adapter.apply(\"menuElement\", {\n      menuElement: this._element\n    }).menuElement; // Set up global \"down\" event\n\n    this._disposers.push(getInteraction().body.events.on(\"down\", function (ev) {\n      if (!ev.pointer.touch) {\n        _this._ignoreNextClose = false;\n      }\n\n      _this.close();\n    })); // Set up global event on ESC press to close the menu\n\n\n    this._disposers.push(getInteraction().body.events.on(\"keyup\", function (ev) {\n      var key = keyboard.getEventKey(ev.event);\n\n      switch (key) {\n        case \"esc\":\n          _this.close();\n\n          break;\n\n        case \"up\":\n        case \"down\":\n        case \"left\":\n        case \"right\":\n          _this.moveSelection(key);\n\n          break;\n      }\n    }));\n\n    if (this.defaultStyles) {\n      this.loadDefaultCSS();\n    }\n  };\n  /**\r\n   * Creates a new branch in export menu. This function is recursive for\r\n   * building multi-level menus.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param container Container to put branch elements in\r\n   * @param branch    Menu item\r\n   * @param level     Current nesting level\r\n   */\n\n\n  ExportMenu.prototype.drawBranch = function (container, branch, level) {\n    var _this = this; // Apply adapter\n\n\n    branch = this.adapter.apply(\"branch\", {\n      branch: branch,\n      level: level\n    }).branch; // Unsupported?\n    // ExportMenu does not check or know for specific browser/system\n    // capabilities. It must happen in some other code and applied via Adapter.\n    // Export itself will check compatibility, but there might be other plugins\n    // that influence it or even add any specific export functionality.\n\n    if (branch.unsupported === true) {\n      return;\n    } // Init ascendants\n\n\n    if (!branch.ascendants) {\n      branch.ascendants = new List();\n    } // Get type\n\n\n    var type = branch.type; // Create an item\n\n    var element = this.createItemElement(level, type); // Create label\n\n    var label = this.createLabelElement(level, type);\n    label.innerHTML = branch.label ? this.language.translate(branch.label) : \"\"; // Apply reader text to label\n\n    var readerLabel = this.getReaderLabel(branch, label.innerHTML);\n    label.setAttribute(\"aria-label\", readerLabel); // Add Label\n\n    element.appendChild(label); // Create interaction object\n    // TODO clean this up when it's disposed\n\n    branch.interactions = getInteraction().getInteraction(label); // Create interaction manager we can set event listeners to\n\n    if (this.typeClickable(type)) {\n      //branch.interactions.clickable = true;\n      // TODO clean this up when it's disposed\n      branch.interactions.events.on(\"hit\", function (ev) {\n        if (_this.events.isEnabled(\"hit\")) {\n          var event_1 = {\n            \"type\": \"hit\",\n            \"event\": ev.event,\n            \"target\": _this,\n            \"branch\": branch\n          };\n\n          _this.events.dispatchImmediately(\"hit\", event_1);\n        }\n      }); // TODO clean this up when it's disposed\n\n      branch.interactions.events.on(\"keyup\", function (ev) {\n        if (keyboard.isKey(ev.event, \"enter\")) {\n          if (_this.events.isEnabled(\"enter\")) {\n            var event_2 = {\n              \"type\": \"enter\",\n              \"event\": ev.event,\n              \"target\": _this,\n              \"branch\": branch\n            };\n\n            _this.events.dispatchImmediately(\"enter\", event_2);\n          }\n        }\n      });\n    }\n\n    {\n      var submenu_1 = this.getSubMenu(branch); // Add ENTER event to open sub-menus\n\n      if (submenu_1 != null) {\n        // TODO clean this up when it's disposed\n        branch.interactions.events.on(\"keyup\", function (ev) {\n          if (keyboard.isKey(ev.event, \"enter\")) {\n            // This is item has sub-menu, activate the first child on ENTER\n            _this.selectBranch(submenu_1[0]); // Attempt to set focus\n\n\n            _this.setFocus(submenu_1[0]);\n          }\n        });\n        branch.interactions.events.on(\"hit\", function (ev) {\n          _this.selectBranch(branch);\n        });\n      }\n    } // Add events\n    // TODO clean this up when it's disposed\n\n    branch.interactions.events.on(\"over\", function (ev) {\n      if (ev.pointer.touch) {\n        // Cancel pending menu closure\n        _this._ignoreNextClose = true;\n      }\n\n      _this.selectBranch(branch);\n\n      if (_this.events.isEnabled(\"over\")) {\n        var event_3 = {\n          \"type\": \"over\",\n          \"event\": ev.event,\n          \"target\": _this,\n          \"branch\": branch\n        };\n\n        _this.events.dispatchImmediately(\"over\", event_3);\n      }\n    }); // TODO clean this up when it's disposed\n\n    branch.interactions.events.on(\"out\", function (ev) {\n      if (!ev.pointer.touch) {\n        _this.delayUnselectBranch(branch);\n      }\n\n      if (_this.events.isEnabled(\"out\")) {\n        var event_4 = {\n          \"type\": \"out\",\n          \"event\": ev.event,\n          \"target\": _this,\n          \"branch\": branch\n        };\n\n        _this.events.dispatchImmediately(\"out\", event_4);\n      }\n    }); // TODO clean this up when it's disposed\n\n    branch.interactions.events.on(\"focus\", function (ev) {\n      _this.selectBranch(branch);\n    }); // TODO clean this up when it's disposed\n\n    branch.interactions.events.on(\"blur\", function (ev) {\n      _this.delayUnselectBranch(branch);\n    }); // Increment level\n\n    var local_level = level + 1; // Has sub-menu?\n\n    if (branch.menu) {\n      var submenu = this.createMenuElement(local_level);\n\n      for (var len = branch.menu.length, i = 0; i < len; i++) {\n        var ascendants = new List();\n        branch.menu[i].ascendants = ascendants;\n\n        if (branch.ascendants.length) {\n          ascendants.copyFrom(branch.ascendants);\n        }\n\n        ascendants.push(branch);\n        this.drawBranch(submenu, branch.menu[i], local_level);\n      } // Sub-menu is empty (all items are not supported)\n      // Do not draw this menu item at all\n\n\n      if (submenu.innerHTML == \"\") {\n        return;\n      }\n\n      element.appendChild(submenu);\n    } // Append to container\n\n\n    container.appendChild(element);\n  };\n  /**\r\n   * Creates a menu element to hold its elements in. Usually it's an `<ul>`\r\n   * tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param level  Current nesting level\r\n   * @return HTML element reference\r\n   */\n\n\n  ExportMenu.prototype.createMenuElement = function (level) {\n    var element = document.createElement(this.menuTag);\n    element.className = this.getMenuItemClass(level); // Accessibility\n\n    if (level === 0) {\n      element.setAttribute(\"role\", \"menu\");\n    }\n\n    return element;\n  };\n  /**\r\n   * Generates a class name for the menu element based on its nesting level.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param level  Current nesting level\r\n   * @return Class name(s)\r\n   */\n\n\n  ExportMenu.prototype.getMenuItemClass = function (level) {\n    var className = this.classPrefix + \"-menu \" + this.classPrefix + \"-menu-level-\" + level;\n\n    if (level === 0) {\n      className += \" \" + this.classPrefix + \"-menu-root \" + this.classPrefix + \"-\" + this.align + \" \" + this.classPrefix + \"-\" + this.verticalAlign;\n    }\n\n    return this.adapter.apply(\"menuClass\", {\n      className: className,\n      level: level\n    }).className;\n  };\n  /**\r\n   * Creates menu item. Usually `<li>` tag. Its label and sub-elements will go\r\n   * into this element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param level  Current nesting level\r\n   * @param type   Type of the menu item\r\n   * @return HTML element reference\r\n   */\n\n\n  ExportMenu.prototype.createItemElement = function (level, type) {\n    var element = document.createElement(this.itemTag);\n    var className = this.classPrefix + \"-item \" + this.classPrefix + \"-item-level-\" + level + \" \" + this.classPrefix + \"-item-\" + (type || \"blank\");\n    element.className = this.adapter.apply(\"itemClass\", {\n      className: className,\n      level: level,\n      type: type\n    }).className;\n    return element;\n  };\n  /**\r\n   * Creates a \"label\" part of the menu item. It could be text or any HTML\r\n   * content.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param level  Current nesting level\r\n   * @param type   Type of the menu item\r\n   * @return An HTML Element\r\n   */\n\n\n  ExportMenu.prototype.createLabelElement = function (level, type) {\n    var element = document.createElement(this.labelTag);\n    var className = this.classPrefix + \"-label \" + this.classPrefix + \"-label-level-\" + level + \" \" + this.classPrefix + \"-item-\" + (type || \"blank\");\n\n    if (this.typeClickable(type)) {\n      className += \" \" + this.classPrefix + \"-clickable\";\n    }\n\n    element.className = this.adapter.apply(\"labelClass\", {\n      className: className,\n      level: level,\n      type: type\n    }).className; // Accessible navigation\n\n    element.setAttribute(\"tabindex\", this.tabindex.toString());\n    element.setAttribute(\"role\", \"menuitem\");\n    return element;\n  };\n  /**\r\n   * Destroys the menu and all its elements.\r\n   */\n\n\n  ExportMenu.prototype.dispose = function () {\n    if (!this._disposed) {\n      _super.prototype.dispose.call(this);\n\n      if (this._element && this._element.parentNode) {\n        this._element.parentNode.removeChild(this._element);\n      }\n    }\n  };\n  /**\r\n   * Checks whether menu item type is supposed to be clickable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param type  Menu item type\r\n   * @return Is clickable?\r\n   */\n\n\n  ExportMenu.prototype.typeClickable = function (type) {\n    return $type.hasValue(type);\n  };\n  /**\r\n   * Checks whether menu item has any sub-items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch  A menu item\r\n   * @return Has sub-items?\r\n   */\n\n\n  ExportMenu.prototype.hasSubMenu = function (branch) {\n    return branch.menu && branch.menu.length ? true : false;\n  };\n  /**\r\n   * Returns sub-items (if they exist).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch  A menu item\r\n   * @return Submenus\r\n   */\n\n\n  ExportMenu.prototype.getSubMenu = function (branch) {\n    if (branch.menu && branch.menu.length) {\n      return branch.menu;\n    }\n  };\n  /**\r\n   * Generates and returns an applicable label to be used for screen readers.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param item   A menu item instance\r\n   * @param label  Current label\r\n   * @return Reader text\r\n   */\n\n\n  ExportMenu.prototype.getReaderLabel = function (branch, label) {\n    // Strip any HTML from the label\n    label = $utils.stripTags(label); // Add textual note if the branch is clickable\n\n    if (this.hasSubMenu(branch)) {\n      label += \" [\" + this.language.translate(\"Click, tap or press ENTER to open\") + \"]\";\n    } else if (branch.type == \"print\") {\n      label = this.language.translate(\"Click, tap or press ENTER to print.\");\n    } else if (this.typeClickable(branch.type)) {\n      label = this.language.translate(\"Click, tap or press ENTER to export as %1.\", undefined, label);\n    }\n\n    return this.adapter.apply(\"rederLabel\", {\n      label: label,\n      branch: branch\n    }).label;\n  };\n\n  Object.defineProperty(ExportMenu.prototype, \"container\", {\n    /**\r\n     * @return Container\r\n     */\n    get: function () {\n      return this._container;\n    },\n\n    /**\r\n     * Getters and setters\r\n     */\n\n    /**\r\n     * An HTML container to place the Menu in.\r\n     *\r\n     * A container must be an HTML element, because menu itself is HTML, and\r\n     * cannot be placed into SVG.\r\n     *\r\n     * @param container Reference to container element\r\n     * @todo Check if menu is already build. If it is, just move it to a new container\r\n     */\n    set: function (container) {\n      this._container = container;\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"items\", {\n    /**\r\n     * @return Menu items\r\n     */\n    get: function () {\n      return this._items;\n    },\n\n    /**\r\n     * A list of menu items. Can be nested.\r\n     *\r\n     * @param items  Menu items\r\n     */\n    set: function (items) {\n      this._items = items;\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"tag\", {\n    /**\r\n     * Sets main menu tag to place menu in.\r\n     *\r\n     * This also sets up how menu items are built.\r\n     *\r\n     * If you set this to \"ul\", menu items will be wrapped into `<li>` tags.\r\n     *\r\n     * If set to \"div\", menu items will be wrapped in `<div>` tags.\r\n     *\r\n     * @default \"ul\"\r\n     * @param tag Tag to use for menu\r\n     */\n    set: function (tag) {\n      this._menuTag = tag;\n      this._itemTag = tag == \"ul\" ? \"li\" : \"div\";\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"menuTag\", {\n    /**\r\n     * Returns current menu tag.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Menu tag (item that contains sub-items)\r\n     */\n    get: function () {\n      return this.adapter.apply(\"menuTag\", {\n        tag: this._menuTag\n      }).tag;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"itemTag\", {\n    /**\r\n     * Returns tag to wrap items into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Item tag\r\n     */\n    get: function () {\n      return this.adapter.apply(\"itemTag\", {\n        tag: this._itemTag\n      }).tag;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"labelTag\", {\n    /**\r\n     * Returns menu label tag.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Label tag\r\n     */\n    get: function () {\n      return this.adapter.apply(\"labelTag\", {\n        tag: this._labelTag\n      }).tag;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"align\", {\n    /**\r\n     * @return Horizontal alignment\r\n     */\n    get: function () {\n      return this.adapter.apply(\"align\", {\n        align: this._align\n      }).align;\n    },\n\n    /**\r\n     * A horizontal alignment for the menu placement.\r\n     *\r\n     * @param value Horizontal alignment\r\n     */\n    set: function (value) {\n      this._align = value;\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"verticalAlign\", {\n    /**\r\n     * @return Vertical alignment\r\n     */\n    get: function () {\n      return this.adapter.apply(\"verticalAlign\", {\n        verticalAlign: this._verticalAlign\n      }).verticalAlign;\n    },\n\n    /**\r\n     * A vertical alignment for the menu placement.\r\n     *\r\n     * @param value Vertical alignment\r\n     */\n    set: function (value) {\n      this._verticalAlign = value;\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"classPrefix\", {\n    /**\r\n     * @return Class name prefix\r\n     */\n    get: function () {\n      return this.adapter.apply(\"classPrefix\", {\n        classPrefix: this._classPrefix\n      }).classPrefix;\n    },\n\n    /**\r\n     * Class name prefix.\r\n     *\r\n     * @default \"amexport\"\r\n     * @param value Class name prefix\r\n     */\n    set: function (value) {\n      this._classPrefix = value;\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"defaultStyles\", {\n    /**\r\n     * @return Should ExportMenu load its own CSS?\r\n     */\n    get: function () {\n      return this.adapter.apply(\"defaultStyles\", {\n        defaultStyles: this._defaultStyles\n      }).defaultStyles;\n    },\n\n    /**\r\n     * Indicates whether [[ExportMenu]] should load external CSS to style itself.\r\n     *\r\n     * If set to `false`, the menu will not be styled, and will rely on some\r\n     * external CSS.\r\n     *\r\n     * @default true\r\n     * @param Should ExportMenu load its own CSS?\r\n     */\n    set: function (value) {\n      if (this._defaultStyles != value) {\n        this._defaultStyles = value;\n\n        if (value) {\n          this.loadDefaultCSS();\n        }\n      }\n\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Loads the default CSS.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  ExportMenu.prototype.loadDefaultCSS = function () {\n    this._disposers.push(exportCSS(this.classPrefix));\n\n    if (this._element) {\n      this._element.style.display = \"\";\n    }\n  };\n\n  Object.defineProperty(ExportMenu.prototype, \"tabindex\", {\n    /**\r\n     * @return Tab index\r\n     */\n    get: function () {\n      return this.adapter.apply(\"tabindex\", {\n        tabindex: this._tabindex\n      }).tabindex;\n    },\n\n    /**\r\n     * A tab index for the menu.\r\n     *\r\n     * Tab index will influence the order in which elements on the chart and\r\n     * the whole page are selected when pressing TAB key.\r\n     *\r\n     * @param value Tab index\r\n     */\n    set: function (value) {\n      this._tabindex = value;\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ExportMenu.prototype, \"language\", {\n    /**\r\n     * @return A [[Language]] instance to be used\r\n     */\n    get: function () {\n      var _this = this;\n\n      var language = this._language.get();\n\n      if (language == null) {\n        language = new Language(); // TODO code duplication with `set language()`\n\n        this._language.set(language, language.events.on(\"localechanged\", function (ev) {\n          _this.invalidate();\n        }));\n      }\n\n      return language;\n    },\n\n    /**\r\n     * A [[Language]] instance.\r\n     *\r\n     * @param value An instance of [[Language]]\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      this._language.set(value, value.events.on(\"localechanged\", function (ev) {\n        _this.invalidate();\n      }));\n\n      this.invalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Controlling the menu\r\n   */\n\n  /**\r\n   * Removes all active classes from menu items. Useful on touch devices and\r\n   * keyboard navigation where open menu can be closed instantly by clicking or\r\n   * tapping outside it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  ExportMenu.prototype.close = function () {\n    var _this = this;\n\n    if (this._ignoreNextClose) {\n      this._ignoreNextClose = false;\n      return;\n    }\n\n    if (this.closeOnClick) {\n      this._element.style.pointerEvents = \"none\";\n      setTimeout(function () {\n        _this._element.style.pointerEvents = \"auto\";\n      }, 100);\n    }\n\n    if (this._currentSelection) {\n      this.setBlur(this._currentSelection);\n      this._currentSelection = undefined;\n    }\n\n    if (this._element) {\n      var items = this._element.getElementsByClassName(\"active\");\n\n      for (var len = items.length, i = len - 1; i >= 0; i--) {\n        if (items[i]) {\n          $dom.removeClass(items[i], \"active\");\n        }\n      }\n    }\n\n    this.events.dispatchImmediately(\"closed\", {\n      type: \"closed\",\n      target: this\n    });\n  };\n  /**\r\n   * Selects a branch in the menu.\r\n   *\r\n   * Handles closing of currently open branch.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch Branch to select\r\n   */\n\n\n  ExportMenu.prototype.selectBranch = function (branch) {\n    var _this = this; // Cancel previous closure\n\n\n    if (branch.closeTimeout) {\n      this.removeDispose(branch.closeTimeout);\n      branch.closeTimeout = undefined;\n    } // Add active class\n\n\n    $dom.addClass(branch.interactions.element.parentElement, \"active\"); // Remove current selection\n\n    if (this._currentSelection && this._currentSelection !== branch && this._currentSelection.ascendants) {\n      $iter.each($iter.concat($iter.fromArray([this._currentSelection]), this._currentSelection.ascendants.iterator()), function (ascendant) {\n        if (!branch.ascendants.contains(ascendant) && branch !== ascendant) {\n          _this.unselectBranch(ascendant, true);\n        }\n      });\n    } // Select and/or cancel timeout for current ascendants\n\n\n    $iter.each(branch.ascendants.iterator(), function (ascendant) {\n      if (ascendant.closeTimeout) {\n        _this.removeDispose(ascendant.closeTimeout);\n\n        ascendant.closeTimeout = undefined;\n      }\n\n      $dom.addClass(ascendant.interactions.element.parentElement, \"active\");\n    }); // Log current selection\n\n    this._currentSelection = branch; // Invoke event\n\n    if (this.events.isEnabled(\"branchselected\")) {\n      var event_5 = {\n        type: \"branchselected\",\n        target: this,\n        branch: branch\n      };\n      this.events.dispatchImmediately(\"branchselected\", event_5);\n    }\n  };\n  /**\r\n   * Unselects a branch. Also selects a branch one level up if necessary.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch Branch to unselect\r\n   * @param simple If `true`, only the branch will be unselected without selecting parent branch\r\n   */\n\n\n  ExportMenu.prototype.unselectBranch = function (branch, simple) {\n    // Remove active class\n    $dom.removeClass(branch.interactions.element.parentElement, \"active\"); // Remove current selection\n\n    if (this._currentSelection == branch) {\n      this._currentSelection = undefined;\n    } // Invoke event\n\n\n    if (this.events.isEnabled(\"branchunselected\")) {\n      var event_6 = {\n        type: \"branchunselected\",\n        target: this,\n        branch: branch\n      };\n      this.events.dispatchImmediately(\"branchunselected\", event_6);\n    }\n  };\n  /**\r\n   * Delay unselection of a branch. This can still be cancelled in some other\r\n   * place if the branch or its children regain focus.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch Branch to unselect\r\n   * @param simple If `true`, only the branch will be unselected without selecting parent branch\r\n   */\n\n\n  ExportMenu.prototype.delayUnselectBranch = function (branch, simple) {\n    var _this = this; // Schedule branch unselection\n\n\n    if (branch.closeTimeout) {\n      this.removeDispose(branch.closeTimeout);\n      branch.closeTimeout = undefined;\n    }\n\n    branch.closeTimeout = this.setTimeout(function () {\n      _this.unselectBranch(branch, simple);\n    }, this.closeDelay); // Schedule unselection of all ascendants\n    // In case focus went away from the export menu altogether, this will ensure\n    // that all items will be closed.\n    // In case we're jumping to other menu item, those delayed unselections will\n    // be cancelled by `selectBranch`\n\n    if (simple !== true && branch.ascendants) {\n      $iter.each(branch.ascendants.iterator(), function (ascendant) {\n        _this.delayUnselectBranch(ascendant, true);\n      });\n    }\n  };\n  /**\r\n   * Navigates the menu based on which direction kayboard key was pressed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key A key that was pressed\r\n   */\n\n\n  ExportMenu.prototype.moveSelection = function (key) {\n    // Check if there's a current selection\n    if (!this._currentSelection) {\n      return;\n    }\n\n    var newSelection;\n\n    if (key == \"up\") {\n      // Try moving up in current menu list, or to the last item if already\n      // at the top\n      newSelection = this.getPrevSibling(this._currentSelection);\n    } else if (key == \"down\") {\n      // Try moving down in current menu list, or to the top item if already\n      // at the bottom\n      newSelection = this.getNextSibling(this._currentSelection);\n    } else if (key == \"left\" && this.align == \"right\" || key == \"right\" && this.align == \"left\") {\n      var menu = this.getSubMenu(this._currentSelection); // Go one level-deeper\n\n      if (menu != null) {\n        newSelection = menu[0];\n      }\n    } else if (key == \"right\" && this.align == \"right\" || key == \"left\" && this.align == \"left\") {\n      // Go one level-deeper\n      newSelection = this.getParentItem(this._currentSelection);\n    }\n\n    if (newSelection && newSelection !== this._currentSelection) {\n      this.selectBranch(newSelection);\n      this.setFocus(newSelection);\n      this._currentSelection = newSelection;\n    }\n  };\n  /**\r\n   * Returns all siblings of a menu item, including this same menu item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch  Menu item\r\n   * @return List of sibling menu items\r\n   */\n\n\n  ExportMenu.prototype.getSiblings = function (branch) {\n    var parent = this.getParentItem(branch);\n\n    if (parent && parent.menu) {\n      return parent.menu;\n    } else {\n      return [];\n    }\n  };\n  /**\r\n   * Returns menu items parent item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch  Menu item\r\n   * @return Parent menu item\r\n   */\n\n\n  ExportMenu.prototype.getParentItem = function (branch) {\n    if (branch.ascendants && branch.ascendants.length) {\n      return branch.ascendants.getIndex(branch.ascendants.length - 1);\n    } else {\n      return undefined;\n    }\n  };\n  /**\r\n   * Returns next sibling in the same menu branch. If there is no next sibling,\r\n   * the first one is returned. If there is just one item, that item is\r\n   * returned. Unsupported menu items are skipped.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch  Menu item to search siblings for\r\n   * @return Menu item\r\n   */\n\n\n  ExportMenu.prototype.getNextSibling = function (branch) {\n    var siblings = this.getSiblings(branch);\n\n    if (siblings.length > 1) {\n      var next = siblings.indexOf(branch) + 1;\n      next = siblings.length == next ? 0 : next;\n      return siblings[next].unsupported ? this.getNextSibling(siblings[next]) : siblings[next];\n    } else {\n      return branch;\n    }\n  };\n  /**\r\n   * Returns previous sibling in the same menu branch. If there is no next\r\n   * sibling, the first one is returned. If there is just one item, that item is\r\n   * returned. Unsupported menu items are skipped.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch  Menu item to search siblings for\r\n   * @return Menu item\r\n   */\n\n\n  ExportMenu.prototype.getPrevSibling = function (branch) {\n    var siblings = this.getSiblings(branch);\n\n    if (siblings.length > 1) {\n      var prev = siblings.indexOf(branch) - 1;\n      prev = prev == -1 ? siblings.length - 1 : prev;\n      return siblings[prev].unsupported ? this.getPrevSibling(siblings[prev]) : siblings[prev];\n    } else {\n      return branch;\n    }\n  };\n  /**\r\n   * Attempts to set focus on particular menu element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch Menu item\r\n   */\n\n\n  ExportMenu.prototype.setFocus = function (branch) {\n    if (branch.interactions) {\n      branch.interactions.element.focus();\n    }\n  };\n  /**\r\n   * Attempts to remove focus from the menu element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param branch Menu item\r\n   */\n\n\n  ExportMenu.prototype.setBlur = function (branch) {\n    if (branch.interactions) {\n      branch.interactions.element.blur();\n    }\n  };\n\n  return ExportMenu;\n}(Validatable);\n\nexport { ExportMenu };","map":null,"metadata":{},"sourceType":"module"}