{"ast":null,"code":"/**\r\n * Animation module.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObjectEvents } from \"../Base\";\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\nimport { Disposer } from \"../utils/Disposer\";\nimport { Color } from \"../utils/Color\";\nimport { Percent, percent } from \"../utils/Percent\";\nimport * as $async from \"../utils/AsyncPending\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $colors from \"../utils/Colors\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport { system } from \"../System\";\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\n\nexport function animate(duration, callback) {\n  var disposed = false; // TODO use performance.now() ?\n\n  var startTime = Date.now();\n\n  function loop(now) {\n    if (!disposed) {\n      var diff = now - startTime;\n\n      if (diff >= duration) {\n        callback(1);\n      } else {\n        $async.nextFrame(loop);\n        callback(diff / duration);\n      }\n    }\n  }\n\n  $async.nextFrame(loop);\n  return new Disposer(function () {\n    disposed = true;\n  });\n}\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\n\nfunction getProgressNumber(progress, from, to) {\n  return from + (to - from) * progress;\n}\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\n\n\nfunction getProgressPercent(progress, from, to) {\n  return new Percent(getProgressNumber(progress, from.percent, to.percent));\n}\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\n\n\nfunction getProgressColor(progress, from, to) {\n  return new Color($colors.interpolate(from.rgb, to.rgb, progress));\n}\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\n\n\nfunction getHybridProperty(property, type) {\n  return type + property.charAt(0).toUpperCase() + property.substr(1);\n}\n\nvar AnimationDisposer =\n/** @class */\nfunction () {\n  function AnimationDisposer(array) {\n    this._disposer = new Disposer(function () {\n      while (array.length !== 0) {\n        array[0].dispose();\n      }\n    });\n  }\n\n  AnimationDisposer.prototype.isDisposed = function () {\n    return this._disposer.isDisposed();\n  };\n\n  AnimationDisposer.prototype.dispose = function () {\n    this._disposer.dispose();\n  };\n\n  return AnimationDisposer;\n}();\n\nexport { AnimationDisposer };\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\n\nvar Animation =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Animation, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param object            An object animation should run on\r\n   * @param animationOptions  One or several (array) of animation options\r\n   * @param duration          Duration (ms)\r\n   * @param easing            Easing function\r\n   */\n\n\n  function Animation(object, animationOptions, duration, easing) {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Duration of the animation in milliseconds.\r\n     */\n\n\n    _this.duration = 0;\n    /**\r\n     * Easing function to use.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n\n    _this.easing = $ease.linear;\n    /**\r\n     * Contains progress of the current animation: 0 (start) to 1 (end).\r\n     */\n\n    _this.progress = 0;\n    /**\r\n     * Indicated how many times animation should loop.\r\n     */\n\n    _this._loop = 0;\n    /**\r\n     * Animation is paused.\r\n     */\n\n    _this._pause = false;\n    /**\r\n     * Holds reference to timeout for delayed play.\r\n     */\n\n    _this._delayTimeout = null;\n    /**\r\n     * Elapsed time in currently playing animation.\r\n     */\n\n    _this._time = 0;\n    _this._isFinished = false;\n    _this.className = \"Animation\"; // Set parameters\n\n    _this.object = object;\n    _this.animationOptions = $array.toArray(animationOptions);\n    _this.duration = duration;\n\n    if (easing) {\n      _this.easing = easing;\n    } // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    //this.stopSameAnimations();\n\n    /*if ($type.hasValue(callback)) {\r\n        // TODO don't use .call\r\n        this.events.on(\"animationended\", callback, object);\r\n    }*/\n    // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  } // TODO verify that this is correct\n\n\n  Animation.prototype.debug = function () {};\n  /**\r\n   * Disposes this object, clears up after itself.\r\n   */\n\n\n  Animation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.pause();\n  };\n  /**\r\n   * Delays animation start by X milliseconds.\r\n   *\r\n   * @param delay  Delay (ms)\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.delay = function (delay) {\n    var _this = this; //@todo Maybe not use `bind()`\n\n\n    if (delay > 0) {\n      this.pause(); // This is so that it will get disposed if `this.object` is disposed\n      // TODO hacky, figure out a better way\n\n      $array.move(this.object.animations, this);\n      var id_1 = setTimeout(function () {\n        _this._delayTimeout = null;\n\n        _this.start();\n      }, delay);\n      this._delayTimeout = new Disposer(function () {\n        clearTimeout(id_1);\n      });\n    }\n\n    return this;\n  };\n\n  Animation.prototype._start = function () {\n    this._isFinished = false; // Clear delay timeout if there was one\n\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    } // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n\n\n    this.stopSameAnimations(); // Reset counters\n\n    this._pause = false; // Register animation\n\n    $array.move(system.animations, this); // Register this animation in object's `animations` list\n\n    $array.move(this.object.animations, this);\n    system.requestFrame();\n  };\n  /**\r\n   * Starts animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.start = function () {\n    this._start();\n\n    this._startTime = Date.now();\n    this._time = 0;\n    this.staticOptions = []; // Process initial property values\n\n    for (var i = this.animationOptions.length - 1; i >= 0; i--) {\n      var options = this.animationOptions[i];\n\n      if (!$type.hasValue(options.from)) {\n        if (options.childObject) {\n          options.from = options.childObject[options.property];\n        } else {\n          options.from = this.object[options.property];\n\n          if (!$type.hasValue(options.from)) {\n            options.from = SVGDefaults[options.property];\n          }\n        }\n        /*if (!$type.hasValue(options.from)) {\r\n            throw Error(\"Could not get initial transition value.\");\r\n        }*/\n\n      }\n\n      if (options.from == options.to) {\n        // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\n        $array.remove(this.animationOptions, options);\n      } else if (!$type.hasValue(options.from)) {\n        // Initial value is undefined, treat it as static\n        this.staticOptions.push(options);\n        $array.remove(this.animationOptions, options);\n      } else {\n        // Use different update methods for different value types\n        if ($type.isNumber(options.to)) {\n          // Numeric value\n          options.updateMethod = getProgressNumber; // Check if initial value is not Percent\n\n          if (options.from instanceof Percent) {\n            // It is. Let's convert it to pixel value\n            // @todo Check if we can do this in a less hacky way\n            var convertedFrom = this.object[getHybridProperty(options.property, \"pixel\")];\n\n            if (!isNaN(convertedFrom)) {\n              options.from = convertedFrom;\n            } else {\n              this.staticOptions.push(options);\n              $array.remove(this.animationOptions, options);\n            }\n          } else if (isNaN(options.from)) {\n            // Static value\n            this.staticOptions.push(options);\n            $array.remove(this.animationOptions, options);\n          }\n        } else {\n          // Check if maybe we have a color or percent value\n          if (options.to instanceof Color) {\n            // Yup - set resolved named color\n            //options.from = $colors.stringToColor(<string>options.from);\n            if (options.from) {\n              options.updateMethod = getProgressColor;\n            } else {\n              // Static value\n              this.staticOptions.push(options);\n              $array.remove(this.animationOptions, options);\n            }\n          } else if (options.to instanceof Percent) {\n            // Percent\n            options.updateMethod = getProgressPercent; // Check if the initial value is maybe in pixels\n\n            if (!isNaN(options.from)) {\n              // It is. Let's convert it\n              // @todo Check if we can do this in a less hacky way\n              var convertedFrom = this.object[getHybridProperty(options.property, \"relative\")];\n\n              if (!isNaN(convertedFrom)) {\n                options.from = percent(convertedFrom * 100);\n              }\n            }\n          } else {\n            // Static value\n            this.staticOptions.push(options);\n            $array.remove(this.animationOptions, options);\n          }\n        }\n      }\n    } // Apply static options (just in case they were reset by previous\n    // animation loop)\n\n\n    this.applyStaticOptions();\n\n    if (this.events.isEnabled(\"animationstarted\")) {\n      var event_1 = {\n        type: \"animationstarted\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationstarted\", event_1);\n    }\n\n    this.update(); // If duration is 0, just end animation\n\n    if (this.duration === 0) {\n      this.end();\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets loop count for the animation. If parameter is not a valid number the\r\n   * animation will keep on looping indefinitely.\r\n   *\r\n   * @param count  Number of times to loop animation\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.loop = function (count) {\n    if (!$type.isNumber(count)) {\n      count = Infinity;\n    }\n\n    this._loop = count;\n    return this;\n  };\n  /**\r\n   * Pauses animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.pause = function () {\n    this._pause = true;\n\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n\n    $array.remove(system.animations, this);\n    $array.remove(this.object.animations, this);\n    return this;\n  };\n  /**\r\n   * Resumes paused animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.resume = function () {\n    this._start();\n\n    this._startTime = Date.now() - this._time;\n    return this;\n  };\n  /**\r\n   * Jumps to animation end. If animation is set to loop, this will start\r\n   * another round of animation from start.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.end = function () {\n    // Pause and complete the progress\n    if (this._loop == 0) {\n      this.pause();\n    }\n\n    this.setProgress(1); // Apply static options\n\n    this.applyStaticOptions();\n\n    if (this.events.isEnabled(\"animationended\")) {\n      var event_2 = {\n        type: \"animationended\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationended\", event_2);\n    } // Check if we should loop\n\n\n    if (this._loop > 0) {\n      this._loop--;\n      this.start();\n    } else {\n      this.stop();\n      this._isFinished = true;\n    }\n\n    return this;\n  };\n\n  Animation.prototype.kill = function () {\n    this.pause();\n    this._isFinished = true;\n  };\n  /**\r\n   * Returns indicator if this animation is finished or not\r\n   *\r\n   * @return Is finished?\r\n   */\n\n\n  Animation.prototype.isFinished = function () {\n    return this._isFinished;\n  };\n  /**\r\n   * Applies static options that can't be animated.\r\n   */\n\n\n  Animation.prototype.applyStaticOptions = function () {\n    var _this = this;\n\n    $array.each(this.staticOptions, function (options) {\n      if (options.childObject) {\n        options.childObject[options.property] = _this.progress == 1 ? options.to : options.from;\n      } else {\n        _this.object[options.property] = _this.progress == 1 ? options.to : options.from;\n      }\n    });\n  };\n  /**\r\n   * Stops animation.\r\n   *\r\n   * When animation is stopped, the properties of the target object will remain\r\n   * where they were at the moment when `stop()` was called.\r\n   *\r\n   * @param skipEvent  Do not trigger `animationstopped` event\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.stop = function (skipEvent) {\n    this.pause();\n\n    if (!skipEvent) {\n      if (this.events.isEnabled(\"animationstopped\")) {\n        var event_3 = {\n          type: \"animationstopped\",\n          target: this,\n          progress: this.progress\n        };\n        this.events.dispatchImmediately(\"animationstopped\", event_3);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets current progress and updates object's numeric and color values.\r\n   *\r\n   * @param progress Progress (0-1)\r\n   */\n\n\n  Animation.prototype.setProgress = function (progress) {\n    var _this = this;\n\n    this._time = this.duration * progress; // just in case we call this from outside\n\n    $array.each(this.animationOptions, function (options) {\n      if (options.updateMethod && $type.hasValue(options.from)) {\n        var value = options.updateMethod(progress, options.from, options.to);\n\n        if (options.childObject) {\n          options.childObject[options.property] = value;\n        } else {\n          _this.object[options.property] = value;\n        }\n      }\n    });\n    this.progress = progress;\n\n    if (this.events.isEnabled(\"animationprogress\")) {\n      var event_4 = {\n        type: \"animationprogress\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationprogress\", event_4);\n    }\n\n    system.requestFrame();\n  };\n  /**\r\n   * Tracks and sets progress according to time or frames.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.update = function () {\n    if (!this._pause) {\n      var progress = void 0;\n      this._time = $math.fitToRange(Date.now() - this._startTime, 0, this.duration);\n      var timeProgress = this._time / this.duration;\n      progress = this.easing(timeProgress);\n\n      if (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\n        progress = 1;\n      }\n\n      this.setProgress(progress);\n\n      if ($math.round(this._time / this.duration, 6) == 1) {\n        this.end();\n      }\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(Animation.prototype, \"delayed\", {\n    /**\r\n     * Returns `true` if this animation is delayed.\r\n     *\r\n     * @readonly\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._delayTimeout ? true : false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks other animations currently running on the same object and removes\r\n   * overlapping options from those other animations that are contained in\r\n   * this animation.\r\n   *\r\n   * This is needed to ensure that no two confurent animations step on each\r\n   * other's toes by trying to animate the same property.\r\n   */\n\n  Animation.prototype.stopSameAnimations = function () {\n    var _this = this; // stop animation of the same property\n    // TODO make this more efficient\n    // TODO don't copy the array\n\n\n    $array.each($array.copy(this.object.animations), function (animation) {\n      if (animation !== _this && !animation.delayed) {\n        var killed_1 = [];\n        $array.each(_this.animationOptions, function (newOptions) {\n          $array.each(animation.animationOptions, function (oldOptions) {\n            if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\n              killed_1.push(oldOptions);\n\n              if (animation.animationOptions.length == 0) {\n                animation.kill();\n              }\n            }\n          });\n        });\n        $array.each(killed_1, function (oldOptions) {\n          $array.remove(animation.animationOptions, oldOptions);\n        });\n      }\n    });\n  };\n\n  return Animation;\n}(BaseObjectEvents);\n\nexport { Animation };","map":null,"metadata":{},"sourceType":"module"}