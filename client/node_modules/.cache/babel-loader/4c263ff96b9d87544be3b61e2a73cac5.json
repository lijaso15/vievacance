{"ast":null,"code":"/**\r\n * Axis Label module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { AxisLabel } from \"./AxisLabel\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { Percent } from \"../../core/utils/Percent\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Use to create labels on circular axis.\r\n *\r\n * @see {@link IAxisLabelCircularEvents} for a list of available events\r\n * @see {@link IAxisLabelCircularAdapters} for a list of available Adapters\r\n */\n\nvar AxisLabelCircular =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(AxisLabelCircular, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function AxisLabelCircular() {\n    var _this = _super.call(this) || this;\n    /**\r\n     *\r\n     * @ignore\r\n     */\n\n\n    _this.fdx = 0;\n    /**\r\n     *\r\n     * @ignore\r\n     */\n\n    _this.fdy = 0;\n    _this.className = \"AxisLabelCircular\";\n\n    _this.padding(0, 0, 0, 0);\n\n    _this.location = 0.5;\n    _this.radius = 0;\n    _this.isMeasured = false;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(AxisLabelCircular.prototype, \"relativeRotation\", {\n    /**\r\n     * @return Rotation angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"relativeRotation\");\n    },\n\n    /**\r\n     * Relative rotation of the label.\r\n     *\r\n     * It is an angle to circle. In case 90, labels will be positioned like rays\r\n     * of light, if 0 - positioned along the circle.\r\n     *\r\n     * @param value Rotation angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"relativeRotation\", value, true);\n\n      if (!$type.hasValue(value)) {\n        this.rotation = undefined;\n        var dataItem = this.dataItem;\n\n        if (dataItem && dataItem.component) {\n          dataItem.component.invalidateDataItems();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisLabelCircular.prototype, \"radius\", {\n    /**\r\n     * @return Distance (px)\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"radius\");\n    },\n\n    /**\r\n     * Distance from axis circle to label in pixels or percent.\r\n     *\r\n     * @param value Distance (px or percent)\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"radius\", value, true, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisLabelCircular.prototype, \"bent\", {\n    /**\r\n     * @return {number} Bent?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"bent\");\n    },\n\n    /**\r\n     * Specifies if label should be bent along the circle.\r\n     *\r\n     * IMPORTANT: Use this with caution, since it is quite CPU-greedy.\r\n     *\r\n     * @since 4.1.2\r\n     * @default false\r\n     * @param {boolean} value Bent?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"bent\", value, true);\n      this.setPropertyValue(\"wrap\", false);\n      this.setPropertyValue(\"horizontalCenter\", \"none\");\n      this.setPropertyValue(\"verticalCenter\", \"none\");\n\n      if (value) {\n        this.textAlign = \"middle\";\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns label radius in pixels.\r\n   */\n\n  AxisLabelCircular.prototype.pixelRadius = function (axisRadius) {\n    var sign = 1;\n\n    if (this.inside) {\n      sign = -1;\n    }\n\n    return $utils.relativeToValue(this.radius, axisRadius) * sign;\n  };\n  /**\r\n   * Returns label horizontal radius in pixels.\r\n   */\n\n\n  AxisLabelCircular.prototype.pixelRadiusY = function (axisRadius, axisRadiusY) {\n    var sign = 1;\n\n    if (this.inside) {\n      sign = -1;\n    }\n\n    var radius = this.radius;\n\n    if ($type.isNumber(radius)) {\n      radius *= axisRadiusY / axisRadius;\n      return $utils.relativeToValue(radius, axisRadius) * sign;\n    } else {\n      return $utils.relativeToValue(radius, axisRadiusY) * sign;\n    }\n  };\n  /**\r\n   * [fixPosition description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param point       Label affixation point\r\n   * @param axisRadius  Distance from point (px)\r\n   */\n\n\n  AxisLabelCircular.prototype.fixPosition = function (angle, axisRadius, axisRadiusY, dx, dy) {\n    if (!$type.isNumber(axisRadiusY)) {\n      axisRadiusY = axisRadius;\n    }\n\n    if (!$type.isNumber(dx)) {\n      dx = 0;\n    }\n\n    if (!$type.isNumber(dy)) {\n      dy = 0;\n    }\n\n    var point = {\n      x: axisRadius * $math.cos(angle),\n      y: axisRadiusY * $math.sin(angle)\n    };\n\n    if (this.invalid) {\n      this.validate(); //@todo\" check if we need this\n    }\n\n    var isNegative = false;\n    var realRadius = this.radius;\n\n    if (realRadius instanceof Percent && realRadius.value < 0) {\n      isNegative = true;\n    } else if (realRadius < 0) {\n      isNegative = true;\n    }\n\n    var relativeRotation = this.relativeRotation;\n    var labelRadius = this.pixelRadius(axisRadius);\n\n    if (this.bent) {\n      var point_1 = {\n        x: axisRadius * $math.cos(angle + 180),\n        y: axisRadiusY * $math.sin(angle + 180)\n      };\n      this.path = $path.moveTo(point_1) + $path.arcTo(angle + 180, 360, axisRadius + labelRadius, axisRadiusY + labelRadius * axisRadiusY / axisRadius);\n      this.locationOnPath = 0.5;\n      return;\n    } // WHEN ROTATED\n\n\n    if ($type.isNumber(relativeRotation)) {\n      this.horizontalCenter = \"none\";\n      this.verticalCenter = \"none\";\n      angle = $math.fitAngleToRange(angle, -180, 180);\n      var pixelWidth = this.bbox.width;\n      var pixelHeight = this.bbox.height;\n      var pixelPaddingBottom = this.pixelPaddingBottom;\n      var pixelPaddingTop = this.pixelPaddingTop;\n      var pixelPaddingLeft = this.pixelPaddingLeft;\n      var pixelPaddingRight = this.pixelPaddingRight;\n\n      if (angle > 90 || angle < -90) {\n        if (relativeRotation == -90) {\n          relativeRotation = 90;\n          pixelWidth = 0;\n        }\n      } else {\n        if (relativeRotation == -90) {\n          pixelHeight = -pixelHeight;\n        }\n\n        if (relativeRotation == 90) {\n          relativeRotation = -90;\n          pixelWidth = -pixelPaddingLeft - pixelPaddingRight;\n          pixelHeight = -pixelHeight - pixelPaddingTop - pixelPaddingBottom;\n        }\n      }\n\n      this.rotation = relativeRotation + angle + 90;\n      var dH = $math.sin(relativeRotation) / 2;\n      var dW = $math.cos(relativeRotation) / 2;\n      var rotation = this.rotation;\n      this.dx = pixelHeight * dH * $math.sin(rotation) - pixelWidth * dW * $math.cos(rotation);\n      this.dy = -pixelHeight * dH * $math.cos(rotation) - pixelWidth * dW * $math.sin(rotation);\n\n      if (!this.inside) {\n        labelRadius += (pixelHeight + pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelWidth + pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\n      } else {\n        if (angle > 90 || angle < -90) {\n          labelRadius -= (pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\n        } else {\n          labelRadius += (pixelPaddingBottom + this.bbox.height + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight + this.bbox.width) * $math.sin(relativeRotation);\n        }\n      }\n\n      point.x += $math.cos(angle) * labelRadius;\n      point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\n    } else {\n      // END OF ROTATED\n      this.horizontalCenter = \"middle\";\n      this.verticalCenter = \"middle\";\n\n      if (isNegative) {\n        this.dx = 0;\n        this.dy = 0;\n        point.x = (axisRadius + labelRadius) * $math.cos(angle);\n        point.y = (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle);\n      } else {\n        // we don't use valign for labels because then they would jump while animating. instead we modify dy depending on a y position\n        // this math makes dy to be 1 at the top of the circle, 0.5 at the middle and 1 at the bottom\n        // @todo with this math doesn't work well with inside = true\n        this.dy = this._measuredHeight / 2 * $math.sin(angle); //(1 - (point.y + axisRadiusY) / (2 * axisRadiusY));\n        // simmilar with dx\n\n        this.dx = this._measuredWidth / 2 * $math.cos(angle); //(1 - (point.x + axisRadius) / (2 * axisRadius));\n\n        point.x += $math.cos(angle) * labelRadius;\n        point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\n      }\n    }\n\n    point.x += dx;\n    point.y += dy;\n    this.fdx = this.dx;\n    this.fdy = this.dy;\n    this.moveTo(point);\n  };\n\n  return AxisLabelCircular;\n}(AxisLabel);\n\nexport { AxisLabelCircular };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"AxisLabelCircular\"] = AxisLabelCircular;","map":null,"metadata":{},"sourceType":"module"}