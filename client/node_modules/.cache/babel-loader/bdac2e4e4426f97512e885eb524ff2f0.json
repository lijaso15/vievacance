{"ast":null,"code":"/**\r\n * Defines Pyramid Series.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { FunnelSeries, FunnelSeriesDataItem } from \"./FunnelSeries\";\nimport { registry } from \"../../core/Registry\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { percent } from \"../../core/utils/Percent\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n//@todo: sequenced?\n\n/**\r\n * Defines a [[DataItem]] for [[PyramidSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar PyramidSeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PyramidSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function PyramidSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"PyramidSeriesDataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  return PyramidSeriesDataItem;\n}(FunnelSeriesDataItem);\n\nexport { PyramidSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines [[Series]] for a FunnelSlice series on a [[SlicedChart]].\r\n *\r\n * @see {@link IPyramidSeriesEvents} for a list of available Events\r\n * @see {@link IPyramidSeriesAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for documentation\r\n * @important\r\n */\n\nvar PyramidSeries =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PyramidSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function PyramidSeries() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"PyramidSeries\";\n    _this.topWidth = percent(0);\n    _this.bottomWidth = percent(100);\n    _this.pyramidHeight = percent(100);\n    _this.valueIs = \"area\";\n    _this.sliceLinks.template.width = 0;\n    _this.sliceLinks.template.height = 0;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  PyramidSeries.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Pyramid Series\");\n    }\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  PyramidSeries.prototype.createDataItem = function () {\n    return new PyramidSeriesDataItem();\n  };\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  PyramidSeries.prototype.validate = function () {\n    _super.prototype.validate.call(this);\n\n    this._nextWidth = undefined;\n  };\n  /**\r\n   * [getNextValue description]\r\n   *\r\n   * @todo Description\r\n   * @param dataItem [description]\r\n   * @return [description]\r\n   */\n\n\n  PyramidSeries.prototype.getNextValue = function (dataItem) {\n    var index = dataItem.index;\n    var nextValue = dataItem.getWorkingValue(\"value\");\n\n    if (index < this.dataItems.length - 1) {\n      var nextItem = this.dataItems.getIndex(index + 1);\n      nextValue = nextItem.getWorkingValue(\"value\");\n    }\n\n    if (nextValue == 0) {\n      nextValue = 0.000001;\n    }\n\n    return nextValue;\n  };\n  /**\r\n   * [validateDataElements description]\r\n   *\r\n   * @todo Description\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  PyramidSeries.prototype.validateDataElements = function () {\n    var _this = this;\n\n    var maxWidth = this.slicesContainer.innerWidth;\n    var maxHeight = this.slicesContainer.innerHeight;\n    this.dataItems.each(function (dataItem) {\n      var relValue = dataItem.getWorkingValue(\"value\") / dataItem.value;\n      var sliceLink = dataItem.sliceLink;\n\n      if (_this.orientation == \"vertical\") {\n        maxHeight -= sliceLink.pixelHeight * relValue;\n      } else {\n        maxWidth -= sliceLink.pixelWidth * relValue;\n      }\n    });\n    this._pyramidHeight = $utils.relativeToValue(this.pyramidHeight, maxHeight);\n    this._pyramidWidth = $utils.relativeToValue(this.pyramidHeight, maxWidth);\n\n    if (this.orientation == \"vertical\") {\n      var y = (maxHeight - this._pyramidHeight) / 2;\n      this.slicesContainer.y = y;\n      this.labelsContainer.y = y;\n      this.ticksContainer.y = y;\n    } else {\n      var x = (maxWidth - this._pyramidWidth) / 2;\n      this.slicesContainer.x = x;\n      this.labelsContainer.x = x;\n      this.ticksContainer.x = x;\n    }\n\n    _super.prototype.validateDataElements.call(this);\n  };\n  /**\r\n   * [decorateSlice description]\r\n   *\r\n   * @todo Description\r\n   * @param dataItem [description]\r\n   */\n\n\n  PyramidSeries.prototype.decorateSlice = function (dataItem) {\n    var sum = this.dataItem.values.value.sum;\n\n    if (sum == 0) {\n      return;\n    }\n\n    var slice = dataItem.slice;\n    var sliceLink = dataItem.sliceLink;\n    var label = dataItem.label;\n    var tick = dataItem.tick; // TODO can this be removed ?\n\n    this.getNextValue(dataItem);\n    var workingValue = dataItem.getWorkingValue(\"value\");\n\n    if (workingValue == 0) {\n      workingValue = 0.000001;\n    }\n\n    var pyramidWidth = this._pyramidWidth;\n    var pyramidHeight = this._pyramidHeight;\n    var maxWidth = this.slicesContainer.innerWidth;\n    var maxHeight = this.slicesContainer.innerHeight;\n    var linkWidth = sliceLink.pixelWidth;\n    var linkHeight = sliceLink.pixelHeight;\n\n    if (this.orientation == \"vertical\") {\n      var topWidth = $utils.relativeToValue(this.topWidth, maxWidth);\n\n      if (!$type.isNumber(this._nextWidth)) {\n        this._nextWidth = topWidth;\n      }\n\n      var bottomWidth = $utils.relativeToValue(this.bottomWidth, maxWidth);\n      var sliceTopWidth = this._nextWidth;\n      var angle = Math.atan2(pyramidHeight, topWidth - bottomWidth);\n      var c = Math.tan(Math.PI / 2 - angle);\n\n      if (c == 0) {\n        c = 0.00000001;\n      }\n\n      var sliceHeight = void 0;\n      var sliceBottomWidth = void 0;\n\n      if (this.valueIs == \"area\") {\n        var totalSquare = (topWidth + bottomWidth) / 2 * pyramidHeight;\n        var square = totalSquare * workingValue / sum;\n        var s = Math.abs(sliceTopWidth * sliceTopWidth - 2 * square * c);\n        sliceHeight = (sliceTopWidth - Math.sqrt(s)) / c;\n        sliceBottomWidth = (2 * square - sliceHeight * sliceTopWidth) / sliceHeight;\n      } else {\n        var sum_1 = this.dataItem.values.value.sum;\n        sliceHeight = pyramidHeight * workingValue / sum_1;\n        sliceBottomWidth = sliceTopWidth - sliceHeight * c;\n      }\n\n      slice.height = sliceHeight;\n      slice.width = maxWidth;\n      slice.bottomWidth = sliceBottomWidth;\n      slice.topWidth = sliceTopWidth;\n      sliceLink.topWidth = slice.bottomWidth;\n      sliceLink.bottomWidth = slice.bottomWidth;\n      slice.y = this._nextY; //slice.x = maxWidth / 2;\n\n      if (!this.alignLabels) {\n        label.x = maxWidth / 2;\n      } else {\n        label.x = 0;\n      }\n\n      label.y = slice.pixelY + slice.pixelHeight * tick.locationY + slice.dy;\n      this._nextY += slice.pixelHeight + linkHeight * workingValue / dataItem.value;\n      sliceLink.y = this._nextY - linkHeight;\n      sliceLink.x = maxWidth / 2;\n    } else {\n      var topWidth = $utils.relativeToValue(this.topWidth, maxHeight);\n\n      if (!$type.isNumber(this._nextWidth)) {\n        this._nextWidth = topWidth;\n      }\n\n      var bottomWidth = $utils.relativeToValue(this.bottomWidth, maxHeight);\n      var sliceTopWidth = this._nextWidth;\n      var angle = Math.atan2(pyramidWidth, topWidth - bottomWidth);\n      var c = Math.tan(Math.PI / 2 - angle);\n\n      if (c == 0) {\n        c = 0.00000001;\n      }\n\n      var sliceWidth = void 0;\n      var sliceBottomWidth = void 0;\n\n      if (this.valueIs == \"area\") {\n        var totalSquare = (topWidth + bottomWidth) / 2 * pyramidWidth;\n        var square = totalSquare * workingValue / this.dataItem.values.value.sum;\n        sliceWidth = (sliceTopWidth - Math.sqrt(sliceTopWidth * sliceTopWidth - 2 * square * c)) / c;\n        sliceBottomWidth = (2 * square - sliceWidth * sliceTopWidth) / sliceWidth;\n      } else {\n        sliceWidth = pyramidWidth * workingValue / this.dataItem.values.value.sum;\n        sliceBottomWidth = sliceTopWidth - sliceWidth * c;\n      }\n\n      slice.width = sliceWidth;\n      slice.height = maxHeight;\n      slice.bottomWidth = sliceBottomWidth;\n      slice.topWidth = sliceTopWidth;\n      sliceLink.topWidth = slice.bottomWidth;\n      sliceLink.bottomWidth = slice.bottomWidth;\n      slice.x = this._nextY;\n\n      if (!this.alignLabels) {\n        label.y = maxHeight / 2;\n      } else {\n        label.y = this.labelsContainer.measuredHeight;\n      }\n\n      label.x = slice.pixelX + slice.pixelWidth * tick.locationX + slice.dx;\n      this._nextY += slice.pixelWidth + linkWidth * workingValue / dataItem.value;\n      sliceLink.x = this._nextY - linkWidth;\n      sliceLink.y = maxHeight / 2;\n    }\n\n    this._nextWidth = slice.bottomWidth;\n  };\n\n  Object.defineProperty(PyramidSeries.prototype, \"topWidth\", {\n    /**\r\n     * @return {number | Percent}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"topWidth\");\n    },\n\n    /**\r\n     * Width of the pyramid's tip in pixels or relative (`Percent`).\r\n     *\r\n     * `0%` (default) means the pyramid will be perfectly pointy.\r\n     * `50%` will have a cut off / blunt top that is half the width of the chart.\r\n     * `100%` will take the whole width of the chart.\r\n     *\r\n     * If you need the downward-pointing pyramid, you might want to `topWidth` to\r\n     * `100%` and `bottomWidth` to `0%`.\r\n     *\r\n     * @default 0%\r\n     * @param {number | Percent}\r\n     */\n    set: function (value) {\n      if (this.setPercentProperty(\"topWidth\", value, false, false, 10, false)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PyramidSeries.prototype, \"pyramidHeight\", {\n    /**\r\n     * @return {number | Percent}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"pyramidHeight\");\n    },\n\n    /**\r\n     * Height of pyramid\r\n     *\r\n     *\r\n     * @default 100%\r\n     * @param {number | Percent}\r\n     */\n    set: function (value) {\n      if (this.setPercentProperty(\"pyramidHeight\", value, false, false, 10, false)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PyramidSeries.prototype, \"bottomWidth\", {\n    /**\r\n     * @return {number | Percent}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"bottomWidth\");\n    },\n\n    /**\r\n     * Width of the pyramid's bottom (bsae) in pixels or relative (`Percent`).\r\n     *\r\n     * `0%` means the pyramid's botto will be pointy.\r\n     * `50%` will have a cut off / blunt bottom that is half the width of the chart.\r\n     * `100%` (default) will take the whole width of the chart.\r\n     *\r\n     * If you need the downward-pointing pyramid, you might want to `topWidth` to\r\n     * `100%` and `bottomWidth` to `0%`.\r\n     *\r\n     * @param {number | Percent}\r\n     */\n    set: function (value) {\n      if (this.setPercentProperty(\"bottomWidth\", value, false, false, 10, false)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PyramidSeries.prototype, \"valueIs\", {\n    /**\r\n     * @return {\"area\" | \"height\"}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"valueIs\");\n    },\n\n    /**\r\n     * Indicates how slice's value will influence its size.\r\n     *\r\n     * `\"area\"` (default) means that the whole area of the pyramid (counting in\r\n     * modifications by `topWidth` and `bottomWidth`) will be divvied up between\r\n     * slices based on their value.\r\n     *\r\n     * With this setting at `\"area\"` the area of the trapezoids of each slice\r\n     * will represent their value relatively to values of the other slices.\r\n     *\r\n     * This is a correct way to depict \"weight\" of each slice based on their\r\n     * values.\r\n     *\r\n     * `\"height\"` means whole height (as opposed to area) of the pyramid will be\r\n     * divvied up between slices. Actual slice width or area is not counted in.\r\n     *\r\n     * From the data-viz standpoint this does not make a lot of sense, since\r\n     * slices with lesser values might appear more prominent if they are placed\r\n     * towards thick end of the pyramid since their areas will be bigger.\r\n     *\r\n     * @default \"area\"\r\n     * @param {\"area\" | \"height\"}\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"valueIs\", value)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PyramidSeries;\n}(FunnelSeries);\n\nexport { PyramidSeries };\n/**\r\n * bboxter class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"PyramidSeries\"] = PyramidSeries;\nregistry.registeredClasses[\"PyramidSeriesDataItem\"] = PyramidSeriesDataItem;","map":null,"metadata":{},"sourceType":"module"}