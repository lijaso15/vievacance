{"ast":null,"code":"/**\r\n * SankeyNode module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { FlowDiagramNode } from \"./FlowDiagramNode\";\nimport { LabelBullet } from \"./LabelBullet\";\nimport { registry } from \"../../core/Registry\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $utils from \"../../core/utils/Utils\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a node in a Sankey Diagram.\r\n *\r\n * A Sankey node is a block with a value, which represents its size on the\r\n * diagram.\r\n *\r\n * Nodes are connected via [[SankeyLink]] elements.\r\n *\r\n * @see {@link ISankeyNodeEvents} for a list of available events\r\n * @see {@link ISankeyNodeAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar SankeyNode =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SankeyNode, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function SankeyNode() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * [nextInCoord description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\n\n\n    _this.nextInCoord = 0;\n    /**\r\n     * [nextOutCoord description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\n\n    _this.nextOutCoord = 0;\n    _this.className = \"SankeyNode\";\n    _this.width = 10;\n    _this.height = 10;\n\n    var nameLabel = _this.createChild(LabelBullet);\n\n    nameLabel.shouldClone = false; //@should we auto update these locations if position is changed?\n\n    nameLabel.locationX = 1;\n    nameLabel.locationY = 0.5;\n    nameLabel.label.text = \"{name}\"; //nameLabel.label.textElement.hideOversized = false;\n\n    nameLabel.width = 150;\n    nameLabel.height = 150;\n    nameLabel.label.horizontalCenter = \"left\";\n    nameLabel.label.padding(0, 5, 0, 5);\n    _this.nameLabel = nameLabel;\n\n    var valueLabel = _this.createChild(LabelBullet);\n\n    valueLabel.shouldClone = false;\n    valueLabel.label.hideOversized = false;\n    valueLabel.locationX = 0.5;\n    valueLabel.locationY = 0.5;\n    valueLabel.width = 150;\n    valueLabel.height = 150; //valueLabel.label.text = \"{value}\";\n\n    valueLabel.label.horizontalCenter = \"middle\";\n    _this.valueLabel = valueLabel;\n    var hiddenState = _this.hiddenState;\n    hiddenState.properties.fill = new InterfaceColorSet().getFor(\"disabledBackground\");\n    hiddenState.properties.opacity = 0.5;\n    hiddenState.properties.visible = true;\n\n    _this.background.hiddenState.copyFrom(hiddenState);\n\n    return _this;\n  }\n  /**\r\n   * Invalidates all links, attached to this node.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  SankeyNode.prototype.invalidateLinks = function () {\n    var _this = this;\n\n    _super.prototype.invalidateLinks.call(this);\n\n    this.nextInCoord = 0;\n    this.nextOutCoord = 0;\n    var chart = this.chart;\n\n    if (chart) {\n      var orientation_1 = chart.orientation;\n\n      if (this._incomingSorted) {\n        $iter.each(this._incomingSorted, function (dataItem) {\n          var link = dataItem.link;\n          var value = dataItem.getWorkingValue(\"value\");\n\n          if ($type.isNumber(value)) {\n            link.parent = _this.chart.linksContainer;\n            var x = void 0;\n            var y = void 0;\n            var angle = void 0;\n\n            if (orientation_1 == \"horizontal\") {\n              x = _this.pixelX + _this.dx;\n              y = _this.nextInCoord + _this.pixelY + _this.dy;\n              angle = 0;\n            } else {\n              y = _this.pixelY + _this.dy;\n              x = _this.nextInCoord + _this.pixelX + _this.dx;\n              angle = 90;\n            }\n\n            link.endX = x;\n            link.endY = y;\n            link.startAngle = angle;\n            link.endAngle = angle;\n            link.gradient.rotation = angle;\n            link.linkWidth = value * chart.valueHeight;\n\n            if (!dataItem.fromNode) {\n              if (orientation_1 == \"horizontal\") {\n                link.maxWidth = 200;\n                link.startX = _this.pixelX + _this.dx - link.maxWidth;\n                link.startY = link.endY;\n              } else {\n                link.maxHeight = 200;\n                link.startX = link.endX;\n                link.startY = _this.pixelY + _this.dy - link.maxHeight;\n              } // TODO is this needed ?\n\n\n              $utils.used(link.gradient);\n              link.fill = dataItem.toNode.color;\n              var stop_1 = link.gradient.stops.getIndex(0);\n\n              if (stop_1) {\n                if (link.colorMode == \"gradient\") {\n                  stop_1.color = _this.color;\n                }\n\n                stop_1.opacity = 0;\n                link.fill = link.gradient;\n                link.stroke = link.gradient;\n                link.gradient.validate();\n              }\n            } //link.validate();\n\n\n            _this.nextInCoord += link.linkWidth;\n          }\n        });\n      }\n\n      if (this._outgoingSorted) {\n        $iter.each(this._outgoingSorted, function (dataItem) {\n          var link = dataItem.link;\n          link.parent = _this.chart.linksContainer;\n          var value = dataItem.getWorkingValue(\"value\");\n\n          if ($type.isNumber(value)) {\n            var x = void 0;\n            var y = void 0;\n            var angle = void 0;\n\n            if (orientation_1 == \"horizontal\") {\n              angle = 0;\n              x = _this.pixelX + _this.pixelWidth + _this.dx - 1;\n              y = _this.nextOutCoord + _this.pixelY + _this.dy;\n            } else {\n              angle = 90;\n              x = _this.nextOutCoord + _this.pixelX + _this.dx;\n              y = _this.pixelY + _this.pixelHeight + _this.dy - 1;\n            }\n\n            link.startX = x;\n            link.startY = y;\n            link.startAngle = angle;\n            link.endAngle = angle;\n            link.gradient.rotation = angle;\n            link.linkWidth = value * _this.chart.valueHeight;\n\n            if (!dataItem.toNode) {\n              if (orientation_1 == \"horizontal\") {\n                link.maxWidth = 200;\n                link.endX = _this.pixelX + link.maxWidth + _this.dx;\n                link.endY = link.startY;\n              } else {\n                link.maxHeight = 200;\n                link.endX = link.startX;\n                link.endY = _this.pixelY + link.maxHeight + _this.dy;\n              }\n\n              link.opacity = _this.opacity;\n              var stop_2 = link.gradient.stops.getIndex(1);\n\n              if (stop_2) {\n                if (link.colorMode == \"gradient\") {\n                  stop_2.color = _this.color;\n                }\n\n                stop_2.opacity = 0;\n                link.fill = link.gradient;\n                link.stroke = link.gradient;\n                link.gradient.validate();\n              }\n            } //link.validate();\n\n\n            _this.nextOutCoord += link.linkWidth;\n          }\n        });\n      }\n    }\n\n    this.positionBullet(this.nameLabel);\n    this.positionBullet(this.valueLabel);\n  };\n  /**\r\n   * Positions the bullet so it is centered within the node element.\r\n   *\r\n   * @param bullet  Target bullet\r\n   */\n\n\n  SankeyNode.prototype.positionBullet = function (bullet) {\n    if (bullet) {\n      bullet.x = this.measuredWidth * bullet.locationX;\n      bullet.y = this.measuredHeight * bullet.locationY;\n    }\n  };\n\n  Object.defineProperty(SankeyNode.prototype, \"level\", {\n    /**\r\n     * @return Level\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"level\");\n    },\n\n    /**\r\n     * A level node is displayed at. (0 - ...)\r\n     *\r\n     * Levels are measured from left to right.\r\n     *\r\n     * The nodes in the left-most column will have `level = 0`.\r\n     *\r\n     * Nodes in second column - `level = 1`, etc.\r\n     *\r\n     * @param value  Level\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"level\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies properties and labels from another [[SankeyNode]].\r\n   *\r\n   * @param source  Source node\r\n   */\n\n  SankeyNode.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.nameLabel.copyFrom(source.nameLabel);\n    this.valueLabel.copyFrom(source.valueLabel);\n  };\n\n  return SankeyNode;\n}(FlowDiagramNode);\n\nexport { SankeyNode };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"SankeyNode\"] = SankeyNode;","map":null,"metadata":{},"sourceType":"module"}