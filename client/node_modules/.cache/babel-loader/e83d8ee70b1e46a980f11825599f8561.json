{"ast":null,"code":"/**\r\n * Defines functionality for \"Data Item\"\r\n *\r\n * A Data Item can be any object that can hold data. For example [[LineSeries]]\r\n * holds a number of values, that comprise a line graph. Each of those values\r\n * (data points) is a {DataItem}.\r\n *\r\n * Furthermore the [[LineSeries]] itself can be represented as a entry in the\r\n * legend. Since legend needs access to Line Series' value, a DataItem is\r\n * created for the series.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObjectEvents } from \"./Base\";\nimport { Adapter } from \"./utils/Adapter\";\nimport { Animation, AnimationDisposer } from \"./utils/Animation\";\nimport * as $utils from \"./utils/Utils\";\nimport * as $array from \"./utils/Array\";\nimport * as $object from \"./utils/Object\";\nimport * as $type from \"./utils/Type\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * DataItem represents single element in data, for example a data point in a\r\n * Serial Chart Series, e.g. a column.\r\n *\r\n * DataItem defines relationship between structured data, required for specific\r\n * chart type or task, and raw source data.\r\n *\r\n * It also implements required calculations, updates related visual elements,\r\n * etc.\r\n *\r\n * @todo Description\r\n * @important\r\n */\n\nvar DataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DataItem, _super);\n  /**\r\n   * Constructor\r\n   * @todo Adding events to disposers produces errors in some cases, which means that chart is using disposed Data Items which is not right\r\n   */\n\n\n  function DataItem() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Holds Adapter.\r\n     */\n\n\n    _this.adapter = new Adapter(_this);\n    /**\r\n     * This Data Item is currently disabled.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._disabled = false;\n    /**\r\n     * Indicates whether Data Item has any properties set.\r\n     *\r\n     * If it does not have any, the code can use this property to check whether\r\n     * they need to apply costly operation of re-applying properties, whenever\r\n     * Data Item-related element is redrawn, e.g. series.\r\n     */\n\n    _this.hasProperties = false;\n    /**\r\n     * An object containing calculated values.\r\n     */\n\n    _this.values = {};\n    /**\r\n     * An object container current working values.\r\n     */\n    //public readonly workingValues: { [index: string]: { [index: string]: number } } = {};\n\n    /**\r\n     * An object containing categories.\r\n     */\n\n    _this.categories = {};\n    /**\r\n     * An object containing dates.\r\n     */\n\n    _this.dates = {};\n    /**\r\n     * An object containing locations for the Data Item.\r\n     *\r\n     * A location is a position within date or category, or, in some other cases,\r\n     * where there is no single point but rather some period.\r\n     */\n\n    _this.locations = {};\n    /**\r\n     * Current working locations.\r\n     */\n\n    _this.workingLocations = {};\n    /**\r\n     * An object containing Data Item specific appearance properties in key-value\r\n     * pairs.\r\n     *\r\n     * Sometimes a single Data Item needs to apply different properties than the\r\n     * rest of the data [[Series]] it is part of. E.g. a single column,\r\n     * represented by a Data Item needs to be filled with a different color than\r\n     * the reset of the [[ColumnSeries]] it belongs to.\r\n     *\r\n     * That's where Data Item's `properties` come into play.\r\n     *\r\n     * Please note that you should set Data Item-specific properties using\r\n     * `setProperty()` method, rather than access `properties` object directly.\r\n     */\n\n    _this.properties = {};\n    /**\r\n     * A list of [[Sprite]] elements that are associated with this Data Item.\r\n     *\r\n     * E.g. an [[Axis]] Data Item has several separate elements associated with\r\n     * it, like [[AxisTick]], [[AxisLabel]], and [[Grid]].\r\n     *\r\n     * Data Item keeps track of all of them, so it can toggle all related visual\r\n     * elements when it itself is toggled.\r\n     */\n\n    _this.sprites = [];\n    /**\r\n     * Identifies if this object is a \"template\" and should not be treated as\r\n     * real object that is drawn or actually used in the chart.\r\n     */\n\n    _this.isTemplate = false;\n    /**\r\n     * The current index within the dataItems\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._index = null;\n    /**\r\n     * Is Data Item currently visible?\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._visible = true;\n    /**\r\n     * Is Data Item currently hidden?\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._hidden = false;\n    /**\r\n     * Should this Data Item be used when calculating data ranges and scales?\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._ignoreMinMax = false;\n    /**\r\n     * Some of the Data Item's data fields may contain an array of children. This\r\n     * property contains an object indicating which fields hold an array, so that\r\n     * they can be processed properly.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this.hasChildren = {};\n    /**\r\n     * Indicates whether Data Item is currently animiting from visible to hidden\r\n     * state.\r\n     */\n\n    _this.isHiding = false;\n    /**\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._valueAnimations = {};\n    /**\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._locationAnimations = {};\n    _this.className = \"DataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(DataItem.prototype, \"index\", {\n    /**\r\n     * Data Item's position index in Component's data.\r\n     *\r\n     * @return Index\r\n     */\n    get: function () {\n      if (this.component) {\n        if (this._index != null) {\n          return this._index;\n        } else {\n          return -1;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataItem.prototype, \"animations\", {\n    /**\r\n     * A list of [[Animations]] objects currently mutating Data Item's values.\r\n     *\r\n     * @return [description]\r\n     */\n    get: function () {\n      if (!this._animations) {\n        this._animations = [];\n\n        this._disposers.push(new AnimationDisposer(this._animations));\n      }\n\n      return this._animations;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataItem.prototype, \"visible\", {\n    /**\r\n     * Returns `true` if this Data Item is currently visible.\r\n     *\r\n     * @return Visible?\r\n     */\n    get: function () {\n      if (this._hidden) {\n        return false;\n      }\n\n      return this._visible;\n    },\n\n    /**\r\n     * Sets visibility of the Data Item.\r\n     *\r\n     * @param value Visible?\r\n     */\n    set: function (value) {\n      if (value) {\n        this.hidden = false;\n      }\n\n      if (this._visible != value) {\n        this.setVisibility(value);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataItem.prototype, \"hidden\", {\n    /**\r\n     * Returns `true` if this Data Item is currently hidden.\r\n     *\r\n     * @return Hidden?\r\n     */\n    get: function () {\n      return this._hidden;\n    },\n\n    /**\r\n     * Sets hidden flag for data item. Mostly used to initially hide data item.\r\n     *\r\n     * @param value Hidden?\r\n     */\n    set: function (value) {\n      if (this._hidden != value) {\n        this._hidden = value;\n\n        if (value) {\n          this.setVisibility(false);\n        } else {\n          this.setVisibility(true, true);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataItem.prototype, \"__disabled\", {\n    /**\r\n     * Is this Data Item currently disabled?\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param {boolean}\r\n     */\n    get: function () {\n      return this._disabled;\n    },\n\n    /**\r\n     * Disables all Sprites associated with this Data Item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param {boolean}\r\n     */\n    set: function (value) {\n      //\tif (this._disabled != value) { // not good\n      this._disabled = value;\n      $array.each(this.sprites, function (sprite) {\n        sprite.__disabled = value;\n      }); //\t}\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Sets visibility of the Data Item.\r\n   *\r\n   * @param value Data Item\r\n   */\n\n  DataItem.prototype.setVisibility = function (value, noChangeValues) {\n    $array.each(this.sprites, function (sprite) {\n      if (value) {\n        sprite.visible = sprite.defaultState.properties.visible;\n      } else {\n        if (sprite.hiddenState) {\n          sprite.visible = sprite.hiddenState.properties.visible;\n        } else {\n          sprite.visible = false;\n        }\n      }\n    });\n    this._visible = value;\n\n    if (this.events.isEnabled(\"visibilitychanged\")) {\n      var event_1 = {\n        type: \"visibilitychanged\",\n        target: this,\n        visible: value\n      };\n      this.events.dispatchImmediately(\"visibilitychanged\", event_1);\n    }\n  };\n  /**\r\n   * Shows the Data Item and related visual elements.\r\n   *\r\n   * @param duration  Animation duration (ms)\r\n   * @param delay     Delay animation (ms)\r\n   * @param fields    A list of fields to set values of\r\n   */\n\n\n  DataItem.prototype.show = function (duration, delay, fields) {\n    var _this = this;\n\n    if (!this.hidden) {\n      this.setVisibility(true, true);\n      this.isHiding = false;\n\n      if (this._hideDisposer) {\n        this.removeDispose(this._hideDisposer);\n      }\n\n      var animation_1;\n\n      if (fields) {\n        $array.each(fields, function (field) {\n          animation_1 = _this.setWorkingValue(field, _this.values[field].value, duration, delay);\n        });\n      }\n\n      $array.each(this.sprites, function (sprite) {\n        var animation = sprite.show(duration);\n\n        if (animation != null && !animation.isFinished()) {\n          _this._disposers.push(animation);\n\n          if (delay != null && delay > 0) {\n            animation.delay(delay);\n          }\n        }\n      });\n      return animation_1;\n    }\n  };\n  /**\r\n   * Destroys this object and all related data.\r\n   */\n\n\n  DataItem.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    $array.each(this.sprites, function (sprite) {\n      sprite.dispose();\n    });\n    this.sprites = [];\n  };\n  /**\r\n   * Hides the Data Item and related visual elements.\r\n   *\r\n   * @param duration  Animation duration (ms)\r\n   * @param delay     Delay animation (ms)\r\n   * @param toValue   A value to set to `fields` when hiding\r\n   * @param fields    A list of data fields to set value to `toValue`\r\n   */\n\n\n  DataItem.prototype.hide = function (duration, delay, toValue, fields) {\n    var _this = this;\n\n    this.isHiding = true;\n    $array.each(this.sprites, function (sprite) {\n      var animation = sprite.hide(duration);\n\n      if (animation != null && !animation.isFinished()) {\n        _this._disposers.push(animation);\n\n        if (delay != null && delay > 0) {\n          animation.delay(delay);\n        }\n      }\n    });\n\n    if ($type.isNumber(toValue) && fields) {\n      var animation_2;\n      $array.each(fields, function (field) {\n        var anim = _this.setWorkingValue(field, toValue, duration, delay);\n\n        if (anim) {\n          animation_2 = anim;\n        }\n      });\n\n      if (animation_2 && !animation_2.isFinished()) {\n        this._hideDisposer = animation_2.events.on(\"animationended\", function () {\n          _this.setVisibility(false, true);\n\n          _this.isHiding = false;\n        });\n\n        this._disposers.push(this._hideDisposer);\n\n        return animation_2;\n      } else {\n        this.isHiding = false;\n        this.setVisibility(false, true);\n      }\n    } else {\n      this.isHiding = false;\n      this.setVisibility(false);\n    }\n  };\n  /**\r\n   * Returns a duration (ms) the Data Item should take to animate from one\r\n   * value to another.\r\n   *\r\n   * If the duration is not specified via parameter, this method will try to\r\n   * request a default duration from the related `Component`.\r\n   *\r\n   * @param duration  Default duration (ms)\r\n   * @return Duration (ms)\r\n   */\n\n\n  DataItem.prototype.getDuration = function (duration) {\n    if (!$type.isNumber(duration)) {\n      var component = this.component;\n\n      if (component) {\n        duration = component.interpolationDuration;\n      }\n    }\n\n    if (duration != null) {\n      return this.adapter.apply(\"duration\", duration);\n    }\n  };\n  /**\r\n   * Returns a numeric value for specific data field.\r\n   *\r\n   * If `calculated` is not set, it will return a raw value, as it is in\r\n   * source data.\r\n   *\r\n   * If `calculated` is set, it will return a pre-calculated specific value.\r\n   *\r\n   * @param name        Data field name\r\n   * @param calculated  A calculated value name\r\n   * @return Value\r\n   */\n\n\n  DataItem.prototype.getValue = function (name, calculated) {\n    if (name && this.component) {\n      if (!calculated) {\n        calculated = this.component.dataFields[name + \"Show\"];\n\n        if (!calculated) {\n          calculated = \"value\";\n        }\n      }\n\n      var value = this.values[name][calculated];\n\n      if (this.adapter.isEnabled(\"value\")) {\n        return this.adapter.apply(\"value\", {\n          value: value,\n          field: name\n        }).value;\n      } else {\n        return value;\n      }\n    }\n  };\n  /**\r\n   * Returns a current working value for a specific data field.\r\n   *\r\n   * The actual value may differ from the one returned by `getValue()`. The\r\n   * latter returns static values from the data source.\r\n   *\r\n   * `getWorkingValue()` returns current value, which is usually different if\r\n   * Data Item is animating from one state to another.\r\n   *\r\n   * @param name        Data field name\r\n   * @return Value\r\n   */\n\n\n  DataItem.prototype.getWorkingValue = function (name) {\n    if (name && this.component) {\n      var realName = this.component.dataFields[name + \"Show\"];\n\n      if (!realName) {\n        realName = \"workingValue\";\n      }\n\n      return this.adapter.apply(\"workingValue\", {\n        workingValue: this.values[name][realName],\n        field: name\n      }).workingValue;\n    }\n  };\n  /**\r\n   * @ignore\r\n   * @return Value\r\n   */\n\n\n  DataItem.prototype.getActualWorkingValue = function (name) {\n    return this.values[name].workingValue;\n  };\n  /**\r\n   * Sets a numeric value for specific data field.\r\n   *\r\n   * @param name        Data field name\r\n   * @param value       Value\r\n   * @param calculated  Calculated data field name\r\n   * @param duration    Duration (ms) to animate to new value to\r\n   * @param delay       Delay animation (ms)\r\n   */\n\n\n  DataItem.prototype.setValue = function (name, value, duration, delay) {\n    var currentValue = this.values[name].value;\n    var newDuration = this.getDuration(duration);\n    value = $type.toNumber(value);\n\n    if (currentValue !== value) {\n      this.values[name].value = value;\n\n      if (this.events.isEnabled(\"valuechanged\")) {\n        var event_2 = {\n          type: \"valuechanged\",\n          target: this,\n          property: name\n        };\n        this.events.dispatchImmediately(\"valuechanged\", event_2);\n      }\n\n      if (this.component) {\n        this.component.handleDataItemValueChange(this, name);\n      }\n    }\n\n    this.setWorkingValue(name, value, newDuration, delay);\n  };\n\n  DataItem.prototype.setCalculatedValue = function (name, value, calculated) {\n    var currentValue = this.values[name][calculated];\n\n    if (currentValue !== value && $type.isNumber(value)) {\n      this.values[name][calculated] = value;\n\n      if (this.events.isEnabled(\"calculatedvaluechanged\")) {\n        var event_3 = {\n          type: \"calculatedvaluechanged\",\n          target: this,\n          property: name\n        };\n        this.events.dispatchImmediately(\"calculatedvaluechanged\", event_3);\n      }\n\n      if (this.component) {\n        this.component.handleDataItemCalculatedValueChange(this, name);\n      }\n    }\n  };\n  /**\r\n   * Set current working numeric value for a specific data field.\r\n   *\r\n   * @param name        Data field name\r\n   * @param value       Value\r\n   * @param calculated  Calculated data field name\r\n   * @param duration    Duration (ms) to animate to new value to\r\n   * @param delay       Delay animation (ms)\r\n   * @return An [[Animation]] object used for transition to new values\r\n   */\n\n\n  DataItem.prototype.setWorkingValue = function (name, value, duration, delay) {\n    if ($type.isNumber(this.values[name].value)) {\n      var newDuration = this.getDuration(duration);\n      var workingValue = this.values[name].workingValue;\n\n      if (newDuration != null && newDuration > 0 && $type.isNumber(workingValue) && this.component) {\n        // sometimes NaN is passed, so only change this to != null if all cases of NaN are handled, otherwise animation won't stop\n        if (workingValue != value) {\n          var animation = this.animate({\n            childObject: this.values[name],\n            property: \"workingValue\",\n            from: workingValue,\n            to: value,\n            dummyData: name\n          }, newDuration, this.component.interpolationEasing);\n\n          if (delay != null) {\n            animation.delay(delay);\n          }\n\n          animation.events.on(\"animationstarted\", this.handleInterpolationProgress, this);\n          animation.events.on(\"animationprogress\", this.handleInterpolationProgress, this);\n          animation.events.on(\"animationended\", this.handleInterpolationProgress, this);\n          this._valueAnimations[name] = animation;\n          return animation;\n        } else {\n          var valueAnimation = this._valueAnimations[name];\n\n          if (valueAnimation) {\n            valueAnimation.stop();\n          }\n\n          this.values[name].workingValue = value;\n        }\n      } else {\n        var valueAnimation = this._valueAnimations[name];\n\n        if (valueAnimation) {\n          valueAnimation.stop();\n        }\n\n        this.values[name].workingValue = value;\n\n        if (this.events.isEnabled(\"workingvaluechanged\")) {\n          var event_4 = {\n            type: \"workingvaluechanged\",\n            target: this,\n            property: name\n          };\n          this.events.dispatchImmediately(\"workingvaluechanged\", event_4);\n        }\n\n        if (this.component) {\n          this.component.handleDataItemWorkingValueChange(this, name);\n        }\n      }\n    }\n  };\n  /**\r\n   * Sets a relative location for a data field.\r\n   *\r\n   * A location is always relative on a 0 to 1 scale, with 0 being beginning,\r\n   * 0.5 middle and 1 end.\r\n   *\r\n   * @todo Rewiew description\r\n   * @param name      Data field name\r\n   * @param value     Location (0-1)\r\n   * @param duration  Duration (ms) to animate to new value to\r\n   * @param delay     Delay animation (ms)\r\n   */\n\n\n  DataItem.prototype.setLocation = function (name, value, duration, delay) {\n    var currentLocation = this.locations[name];\n\n    if (currentLocation !== value) {\n      this.locations[name] = value;\n\n      if (this.events.isEnabled(\"locationchanged\")) {\n        var event_5 = {\n          type: \"locationchanged\",\n          target: this,\n          property: name\n        };\n        this.events.dispatchImmediately(\"locationchanged\", event_5);\n      }\n\n      if (this.component) {\n        this.component.handleDataItemValueChange(this, name); // correct\n      }\n\n      this.setWorkingLocation(name, value, duration, delay);\n    }\n  };\n  /**\r\n   * Sets a current working location for a data field.\r\n   *\r\n   * @todo Rewiew description\r\n   * @param name      Data field name\r\n   * @param value     Location (0-1)\r\n   * @param duration  Duration (ms) to animate to new value to\r\n   * @param delay     Delay animation (ms)\r\n   */\n\n\n  DataItem.prototype.setWorkingLocation = function (name, value, duration, delay) {\n    var newDuration = this.getDuration(duration);\n    var workingLocation = this.workingLocations[name];\n\n    if (newDuration != null && newDuration > 0 && $type.isNumber(workingLocation) && this.component) {\n      // sometimes NaN is passed, so only change this to != null if all cases of NaN are handled, otherwise animation won't stop\n      if (workingLocation != value) {\n        var animation = this.animate({\n          childObject: this.workingLocations,\n          property: name,\n          from: workingLocation,\n          to: value,\n          dummyData: name\n        }, newDuration, this.component.interpolationEasing);\n\n        if (delay != null) {\n          animation.delay(delay);\n        }\n\n        animation.events.on(\"animationstarted\", this.handleInterpolationProgress, this);\n        animation.events.on(\"animationprogress\", this.handleInterpolationProgress, this);\n        animation.events.on(\"animationended\", this.handleInterpolationProgress, this);\n        this._locationAnimations[name] = animation;\n        return animation;\n      } else {\n        var locationAnimation = this._locationAnimations[name];\n\n        if (locationAnimation) {\n          locationAnimation.stop();\n        }\n\n        this.workingLocations[name] = value;\n      }\n    } else {\n      var locationAnimation = this._locationAnimations[name];\n\n      if (locationAnimation) {\n        locationAnimation.stop();\n      }\n\n      this.workingLocations[name] = value;\n\n      if (this.events.isEnabled(\"workinglocationchanged\")) {\n        var event_6 = {\n          type: \"workinglocationchanged\",\n          target: this,\n          property: name\n        };\n        this.events.dispatchImmediately(\"workinglocationchanged\", event_6);\n      }\n\n      if (this.component) {\n        this.component.handleDataItemWorkingLocationChange(this, name);\n      }\n    }\n  };\n  /**\r\n   * Sets Date value to a data field.\r\n   *\r\n   * @param name      Data field name\r\n   * @param date      Date object\r\n   * @param duration  Duration (ms) to animate to new value to\r\n   */\n\n\n  DataItem.prototype.setDate = function (name, date, duration) {\n    if (!$type.isDate(date) && this.component) {\n      date = this.component.dateFormatter.parse(date);\n    }\n\n    var currentDate = this.dates[name];\n\n    if (currentDate !== date) {\n      this.dates[name] = date;\n      this.setValue(name, date.getTime(), duration);\n    }\n  };\n  /**\r\n   * Returns a Date value of the data field.\r\n   *\r\n   * @param name  Data field name\r\n   * @return Date object\r\n   */\n\n\n  DataItem.prototype.getDate = function (name) {\n    return this.adapter.apply(\"date\", {\n      date: this.dates[name],\n      field: name\n    }).date;\n  };\n  /**\r\n   * Sets a Data Item-specific visual properties to apply to related elements.\r\n   *\r\n   * @param name   Property name\r\n   * @param value  Property value\r\n   */\n\n\n  DataItem.prototype.setProperty = function (name, value) {\n    if (this.properties[name] !== value) {\n      this.hasProperties = true;\n      this.properties[name] = value;\n\n      if (this.events.isEnabled(\"propertychanged\")) {\n        var event_7 = {\n          type: \"propertychanged\",\n          target: this,\n          property: name,\n          value: value\n        };\n        this.events.dispatchImmediately(\"propertychanged\", event_7);\n      }\n\n      if (this.component) {\n        this.component.handleDataItemPropertyChange(this, name);\n      }\n    }\n  };\n  /**\r\n   * Sets a related category for this Data Item.\r\n   *\r\n   * @todo Review description\r\n   * @param name   Data field name\r\n   * @param value  Category\r\n   */\n\n\n  DataItem.prototype.setCategory = function (name, value) {\n    if (!$type.isString(value)) {\n      value = $type.castString(value);\n    }\n\n    if (this.categories[name] !== value) {\n      this.categories[name] = value;\n    }\n  };\n  /**\r\n   * Clones the Data Item, including all related data.\r\n   *\r\n   * @return New Data Item clone\r\n   */\n\n\n  DataItem.prototype.clone = function (cloneId) {\n    var dataItem = _super.prototype.clone.call(this, cloneId);\n\n    dataItem.copyFrom(this);\n    return dataItem;\n  };\n  /**\r\n   * Copies all properties and related data from different data item.\r\n   *\r\n   * @param object Source data item\r\n   */\n\n\n  DataItem.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    _super.prototype.copyFrom.call(this, source);\n\n    if (source.dataContext) {\n      this.dataContext = $utils.copy(source.dataContext, {});\n    }\n\n    $utils.copyProperties(source.locations, this.locations);\n    $utils.copyProperties(source.properties, this.properties);\n    $utils.copyProperties(source.categories, this.categories);\n    $utils.copyProperties(source.values, this.values);\n    $utils.copyProperties(source.dates, this.dates);\n    $object.each(source.values, function (name, value) {\n      _this.values[name] = $object.copy(value);\n    });\n    this.adapter.copyFrom(source.adapter);\n    this.events.copyFrom(source.events);\n    this.component = source.component;\n  };\n\n  Object.defineProperty(DataItem.prototype, \"opacity\", {\n    /**\r\n     * Sets opacity for all Data Item's related elements (Sprites).\r\n     *\r\n     * @param value Opacity (0-1)\r\n     */\n    set: function (value) {\n      $array.each(this.sprites, function (sprite) {\n        sprite.opacity = value;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataItem.prototype, \"ignoreMinMax\", {\n    /**\r\n     * Exclude from min/max calculations?\r\n     * @return Exclude from min/max calculations?\r\n     */\n    get: function () {\n      return this._ignoreMinMax;\n    },\n\n    /**\r\n     * Sets whether this data point should not be included in the scale and\r\n     * minimum/maximum calculations.\r\n     *\r\n     * E.g. some we may want to exclude a particular data point from influencing\r\n     * [[ValueAxis]] scale.\r\n     *\r\n     * @param value  Exclude from min/max calculations?\r\n     */\n    set: function (value) {\n      this._ignoreMinMax = value;\n\n      if (this.events.isEnabled(\"propertychanged\")) {\n        var event_8 = {\n          type: \"propertychanged\",\n          target: this,\n          property: \"ignoreMinMax\",\n          value: value\n        };\n        this.events.dispatchImmediately(\"propertychanged\", event_8);\n      }\n\n      if (this.component) {\n        this.component.handleDataItemPropertyChange(this, \"ignoreMinMax\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates and starts an [[Animation]] to interpolate (morph) Data Item's\r\n   * properties and/or values.\r\n   *\r\n   * @see {@link Animation}\r\n   * @param animationOptions  Animation options\r\n   * @param duration          Animation duration (ms)\r\n   * @param easing            Easing function\r\n   * @return Animation\r\n   */\n\n  DataItem.prototype.animate = function (animationOptions, duration, easing) {\n    return new Animation(this, animationOptions, duration, easing).start();\n  };\n  /**\r\n   * Handles intermediate steps when Data Item is interpolating (morphing) from\r\n   * one value to another.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event Event object\r\n   */\n\n\n  DataItem.prototype.handleInterpolationProgress = function (event) {\n    var animation = event.target; // it's always only one options, no need cycle\n\n    var animationOptions = animation.animationOptions[0];\n\n    if (animationOptions) {\n      if (this.events.isEnabled(\"workingvaluechanged\")) {\n        var event_9 = {\n          type: \"workingvaluechanged\",\n          target: this,\n          property: animationOptions.dummyData\n        };\n        this.events.dispatchImmediately(\"workingvaluechanged\", event_9);\n      }\n\n      if (this.component) {\n        this.component.handleDataItemWorkingValueChange(this, animationOptions.dummyData);\n      }\n    }\n  };\n  /**\r\n   * Checks whether Data Item has values set for all of the data fields,\r\n   * supplied via argument.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param fields  Field list to check\r\n   * @return Has values for all fields?\r\n   */\n\n\n  DataItem.prototype.hasValue = function (fields) {\n    // todo: what about categories?\n    for (var i = 0, len = fields.length; i < len; i++) {\n      var values = this.values[fields[i]];\n\n      if (!values || !$type.hasValue(values.value)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Object.defineProperty(DataItem.prototype, \"depth\", {\n    /**\r\n     * Depth of the Data Item.\r\n     *\r\n     * In nested data structures, like TreeMap, this indicates the level this\r\n     * data point is at, in relation to the parent Data Item.\r\n     *\r\n     * @return Depth\r\n     */\n    get: function () {\n      if (!this.parent) {\n        return 0;\n      } else {\n        return this.parent.depth + 1;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataItem.prototype, \"dataContext\", {\n    /**\r\n     * Sets to a reference to an original object from Component's data.\r\n     *\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._dataContext;\n    },\n\n    /**\r\n     * A reference to an original object in Component's data, that this Data Item\r\n     * is derived from.\r\n     *\r\n     * @param value Original data object\r\n     */\n    set: function (value) {\n      this._dataContext = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * adds a sprite to dataItem.sprites array\r\n   * @ignore\r\n   */\n\n  DataItem.prototype.addSprite = function (sprite) {\n    if (sprite.dataItem && sprite.dataItem != this) {\n      $array.remove(sprite.dataItem.sprites, sprite);\n    }\n\n    if (!this.visible) {\n      sprite.hide(0);\n    }\n\n    if (this.isHiding) {\n      sprite.hide();\n    }\n\n    this.sprites.push(sprite);\n    sprite.dataItem = this;\n  };\n\n  return DataItem;\n}(BaseObjectEvents);\n\nexport { DataItem };","map":null,"metadata":{},"sourceType":"module"}