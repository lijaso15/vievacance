{"ast":null,"code":"/**\r\n * Contains code and logic for generating linear gradients.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../../Base\";\nimport { List } from \"../../utils/List\";\nimport { getGhostPaper } from \"../Paper\";\nimport { registry } from \"../../Registry\";\nimport * as $iter from \"../../utils/Iterator\";\nimport * as $math from \"../../utils/Math\";\nimport * as $type from \"../../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Linear gradient class.\r\n */\n\nvar LinearGradient =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(LinearGradient, _super);\n  /**\r\n   * Constructor.\r\n   */\n\n\n  function LinearGradient() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * List of colors switch definitions in a gradient.\r\n     */\n\n\n    _this._stops = new List();\n    /**\r\n     * Gradient direction.\r\n     */\n\n    _this._rotation = 0;\n    _this.className = \"LinearGradient\";\n\n    _this._stops.events.on(\"setIndex\", _this.validate, _this);\n\n    _this._stops.events.on(\"inserted\", _this.validate, _this); // Create element\n\n\n    _this.element = _this.paper.addGroup(\"linearGradient\");\n    _this.id = \"gradient-\" + registry.getUniqueId();\n\n    _this.element.attr({\n      \"id\": _this.id\n    });\n\n    _this._disposers.push(_this.element); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Draws gradient.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  LinearGradient.prototype.validate = function () {\n    var _this = this;\n\n    var rotation = (this._rotation + 90) * $math.RADIANS;\n    var x1 = Math.round(50 + Math.sin(rotation + Math.PI) * 50) + '%';\n    var y1 = Math.round(50 + Math.cos(rotation) * 50) + '%';\n    var x2 = Math.round(50 + Math.sin(rotation) * 50) + '%';\n    var y2 = Math.round(50 + Math.cos(rotation + Math.PI) * 50) + '%';\n    var gradientElement = this.element;\n    gradientElement.removeChildNodes();\n    gradientElement.attr({\n      \"x1\": x1,\n      \"x2\": x2,\n      \"y1\": y1,\n      \"y2\": y2\n    });\n    $iter.each($iter.indexed(this._stops.iterator()), function (a) {\n      var i = a[0];\n      var stop = a[1];\n      var offset = stop.offset;\n\n      if (!$type.isNumber(offset)) {\n        offset = i / (_this._stops.length - 1);\n      }\n\n      var gradientStop = _this.paper.add(\"stop\");\n\n      if ($type.hasValue(stop.color)) {\n        gradientStop.attr({\n          \"stop-color\": stop.color.toString()\n        });\n      }\n\n      if ($type.isNumber(stop.opacity)) {\n        gradientStop.attr({\n          \"stop-opacity\": stop.opacity\n        });\n      }\n\n      if ($type.isNumber(offset)) {\n        gradientStop.attr({\n          \"offset\": offset\n        });\n      }\n\n      gradientElement.add(gradientStop);\n    });\n  };\n  /**\r\n   * Clears the gradient.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  LinearGradient.prototype.clear = function () {\n    this._stops.clear();\n  };\n  /**\r\n   * Adds a color step to the gradient.\r\n   *\r\n   * @param color    Color (hex code or named color)\r\n   * @param opacity  Opacity (value from 0 to 1; 0 completely transaprent, 1 fully opaque)\r\n   * @param offset   Position of color in the gradient (value 0 to 1; 0 meaning start of the gradient and 1 end)\r\n   */\n\n\n  LinearGradient.prototype.addColor = function (color, opacity, offset) {\n    this._stops.push({\n      color: color,\n      opacity: opacity,\n      offset: offset\n    });\n  };\n\n  Object.defineProperty(LinearGradient.prototype, \"stops\", {\n    /**\r\n     * A list of color stops in the gradient.\r\n     *\r\n     * @return Stops\r\n     */\n    get: function () {\n      return this._stops;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LinearGradient.prototype, \"paper\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Paper\r\n     */\n    get: function () {\n      if (this._paper) {\n        return this._paper;\n      }\n\n      return getGhostPaper();\n    },\n\n    /**\r\n     * [[Paper]] instace to use for the gradient.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param paper  Paper\r\n     */\n    set: function (paper) {\n      if (this._paper != paper) {\n        this._paper = paper;\n        this.validate();\n        paper.appendDef(this.element);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LinearGradient.prototype, \"rotation\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function () {\n      return this._rotation;\n    },\n\n    /**\r\n     * Rotation (direction) of the gradient in degrees.\r\n     *\r\n     * @param value  Rotation\r\n     */\n    set: function (value) {\n      //this.element.attr({ \"gradientTransform\": \"rotate(\" + value + \" 10 100)\" });\n      this._rotation = value;\n      this.validate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  LinearGradient.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.stops.copyFrom(source.stops);\n    this._rotation = source.rotation;\n  };\n\n  return LinearGradient;\n}(BaseObject);\n\nexport { LinearGradient };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"LinearGradient\"] = LinearGradient;","map":null,"metadata":{},"sourceType":"module"}