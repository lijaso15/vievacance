{"ast":null,"code":"/**\r\n * Polygon module.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Sprite } from \"../Sprite\";\nimport { Morpher } from \"../utils/Morpher\";\nimport { registry } from \"../Registry\";\nimport * as $path from \"../rendering/Path\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\n\nvar Polygon =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Polygon, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Polygon() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Polygon\";\n    _this.element = _this.paper.add(\"path\");\n    _this.shapeRendering = \"auto\";\n    _this._currentPoints = [];\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(Polygon.prototype, \"points\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      var points = this.getPropertyValue(\"points\");\n      var path = this.path;\n\n      if (path && (!points || points.length == 0)) {\n        var valueStr = path.slice(1, path.length - 1);\n        var segments = valueStr.split(\"ZM\");\n\n        for (var s = 0; s < segments.length; s++) {\n          var segment = segments[s];\n\n          if (segment.length > 0) {\n            var areaHole = segment.split(\"M\");\n            var areaArr = areaHole[0];\n            var holeArr = areaHole[1];\n\n            if (areaArr && areaArr.length > 0) {\n              var pointsArr = areaArr.split(\"L\");\n\n              if (pointsArr.length > 0) {\n                var area = [];\n                var areaAndHole = [area];\n                points.push(areaAndHole);\n\n                for (var p = 0; p < pointsArr.length; p++) {\n                  var coords = pointsArr[p].split(\",\");\n                  area.push({\n                    x: Number(coords[0]),\n                    y: Number(coords[1])\n                  });\n                }\n\n                if (holeArr && holeArr.length > 0) {\n                  var pointsArr_1 = holeArr.split(\"L\");\n\n                  if (pointsArr_1.length > 0) {\n                    var hole = [];\n                    areaAndHole.push(hole);\n\n                    for (var p = pointsArr_1.length - 1; p >= 0; p--) {\n                      var coords = pointsArr_1[p].split(\",\");\n                      hole.push({\n                        x: Number(coords[0]),\n                        y: Number(coords[1])\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        this.setPropertyValue(\"points\", points);\n        this._currentPoints = points;\n      }\n\n      return points;\n    },\n\n    /**\r\n     * An array of X/Y coordinates for each elbow of the polygon.\r\n     *\r\n     * @todo Example\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      this.setPropertyValue(\"points\", points, true);\n      this._currentPoints = points;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"currentPoints\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\n        this._currentPoints = this.points;\n      }\n\n      return this._currentPoints;\n    },\n\n    /**\r\n     * Current points. Used when morphing the element, so that original `points`\r\n     * are not overwritten.\r\n     *\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      if (this._currentPoints != points) {\n        this._currentPoints = points;\n        this.draw();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Polygon.prototype.draw = function () {\n    var path = \"\";\n    var points = this._currentPoints;\n    var left;\n    var right;\n    var top;\n    var bottom;\n\n    if (points.length > 0) {\n      // separate areas\n      for (var i = 0, len = points.length; i < len; i++) {\n        // surface\n        var surface = points[i][0];\n        var hole = points[i][1];\n\n        if (surface && surface.length > 0) {\n          var point = surface[0];\n          path += $path.moveTo(point);\n\n          for (var s = 0; s < surface.length; s++) {\n            point = surface[s];\n            path += $path.lineTo(point);\n\n            if (!$type.isNumber(right) || right < point.x) {\n              right = point.x;\n            }\n\n            if (!$type.isNumber(left) || left > point.x) {\n              left = point.x;\n            }\n\n            if (!$type.isNumber(top) || top > point.y) {\n              top = point.y;\n            }\n\n            if (!$type.isNumber(bottom) || bottom < point.y) {\n              bottom = point.y;\n            }\n          }\n        } // hole\n\n\n        if (hole && hole.length > 0) {\n          var point = hole[0];\n          path += $path.moveTo(point);\n\n          for (var h = 0, hlen = hole.length; h < hlen; h++) {\n            point = hole[h];\n            path += $path.lineTo(point);\n          }\n        }\n      }\n\n      if (path) {\n        path += $path.closePath();\n      }\n\n      this.bbox.x = left;\n      this.bbox.y = top;\n      this.bbox.width = right - left;\n      this.bbox.height = bottom - top;\n\n      _super.prototype.setPath.call(this, path);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Polygon.prototype.setPath = function (value) {\n    if (_super.prototype.setPath.call(this, value)) {\n      this.points = [];\n      this._bbox = this.group.getBBox();\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Measures element\r\n   */\n\n\n  Polygon.prototype.measureElement = function () {// Overriding to avoid extra measurement.\n  };\n\n  Object.defineProperty(Polygon.prototype, \"centerPoint\", {\n    /**\r\n     * A calculated center point for the shape.\r\n     *\r\n     * @readonly\r\n     * @return Center\r\n     */\n    get: function () {\n      return {\n        x: this.bbox.x + this.bbox.width / 2,\n        y: this.bbox.y + this.bbox.height / 2\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"morpher\", {\n    /**\r\n     * A [[Morpher]] instance that is used to morph polygon into some other\r\n     * shape.\r\n     *\r\n     * @readonly\r\n     * @return Morpher instance\r\n     */\n    get: function () {\n      if (!this._morpher) {\n        this._morpher = new Morpher(this);\n\n        this._disposers.push(this._morpher);\n      }\n\n      return this._morpher;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polygon;\n}(Sprite);\n\nexport { Polygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Polygon\"] = Polygon;","map":null,"metadata":{},"sourceType":"module"}