{"ast":null,"code":"/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { registry } from \"../Registry\";\nimport * as $path from \"./Path\";\nimport * as $array from \"../utils/Array\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $math from \"../utils/Math\";\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\n\nvar Tension =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param tensionX [description]\r\n   * @param tensionY [description]\r\n   */\n  function Tension(tensionX, tensionY) {\n    this._tensionX = tensionX;\n    this._tensionY = tensionY;\n  }\n  /**\r\n   * [smooth description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return [description]\r\n   */\n\n\n  Tension.prototype.smooth = function (points) {\n    var tensionX = this._tensionX;\n    var tensionY = this._tensionY;\n\n    if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n      return $path.polyline(points);\n    }\n\n    var first = points[0];\n    var last = points[points.length - 1];\n    var closed = false;\n\n    if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n      closed = true;\n    } // Can't moveTo here, as it wont be possible to have fill then.\n\n\n    var path = \"\";\n\n    for (var i = 0, len = points.length - 1; i < len; i++) {\n      var p0 = points[i - 1];\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n\n      if (i === 0) {\n        if (closed) {\n          p0 = points[points.length - 2];\n        } else {\n          p0 = points[i];\n        }\n      } else if (i == points.length - 2) {\n        if (closed) {\n          p3 = points[1];\n        } else {\n          p3 = points[i + 1];\n        }\n      }\n\n      var controlPointA = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n      var controlPointB = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n      path += $path.cubicCurveTo(p2, controlPointA, controlPointB);\n    }\n\n    return path;\n  };\n\n  return Tension;\n}();\n\nexport { Tension };\n/**\r\n * Returns a waved line SVG path between two points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point1            Starting point\r\n * @param point2            Ending point\r\n * @param waveLength        Wave length\r\n * @param waveHeight        Wave height\r\n * @param adjustWaveLength  Adjust wave length based on the actual line length\r\n * @return SVG path\r\n */\n\nexport function wavedLine(point1, point2, waveLength, waveHeight, tension, adjustWaveLength) {\n  var x1 = point1.x;\n  var y1 = point1.y;\n  var x2 = point2.x;\n  var y2 = point2.y;\n  var distance = $math.getDistance(point1, point2);\n\n  if (adjustWaveLength) {\n    waveLength = distance / Math.round(distance / waveLength);\n  }\n\n  var d = registry.getCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]));\n\n  if (!d) {\n    if (distance > 0) {\n      var angle = Math.atan2(y2 - y1, x2 - x1);\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      var waveLengthX = waveLength * cos;\n      var waveLengthY = waveLength * sin;\n\n      if (waveLength <= 1 || waveHeight <= 1) {\n        d = $path.lineTo(point2);\n      } else {\n        var halfWaveCount = Math.round(2 * distance / waveLength);\n        var points = [];\n        var sign = 1;\n\n        if (x2 < x1) {\n          sign *= -1;\n        }\n\n        if (y2 < y1) {\n          sign *= -1;\n        }\n\n        for (var i = 0; i <= halfWaveCount; i++) {\n          sign *= -1;\n          var x = x1 + i * waveLengthX / 2 + sign * waveHeight / 2 * sin;\n          var y = y1 + i * waveLengthY / 2 - sign * waveHeight / 2 * cos;\n          points.push({\n            x: x,\n            y: y\n          });\n        }\n\n        d = new Tension(tension, tension).smooth(points);\n      }\n    } else {\n      d = \"\";\n    }\n\n    registry.setCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]), d);\n  }\n\n  return d;\n}\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\n\nvar Basis =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param info  [description]\r\n   */\n  function Basis(info) {\n    this._closed = info.closed;\n  }\n  /**\r\n   * [smooth description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return [description]\r\n   */\n\n\n  Basis.prototype.smooth = function (points) {\n    var _this = this;\n\n    var x0 = NaN;\n    var x1 = NaN;\n    var x2 = NaN;\n    var x3 = NaN;\n    var x4 = NaN;\n    var y0 = NaN;\n    var y1 = NaN;\n    var y2 = NaN;\n    var y3 = NaN;\n    var y4 = NaN;\n    var point = 0;\n    var output = \"\";\n\n    var pushCurve = function (x, y) {\n      output += $path.cubicCurveTo({\n        x: (x0 + 4 * x1 + x) / 6,\n        y: (y0 + 4 * y1 + y) / 6\n      }, {\n        x: (2 * x0 + x1) / 3,\n        y: (2 * y0 + y1) / 3\n      }, {\n        x: (x0 + 2 * x1) / 3,\n        y: (y0 + 2 * y1) / 3\n      });\n    };\n\n    var pushPoint = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      switch (point) {\n        case 0:\n          point = 1;\n\n          if (_this._closed) {\n            x2 = x;\n            y2 = y;\n          } else {\n            output += $path.lineTo({\n              x: x,\n              y: y\n            });\n          }\n\n          break;\n\n        case 1:\n          point = 2;\n\n          if (_this._closed) {\n            x3 = x;\n            y3 = y;\n          }\n\n          break;\n\n        case 2:\n          point = 3;\n\n          if (_this._closed) {\n            x4 = x;\n            y4 = y;\n            output += $path.moveTo({\n              x: (x0 + 4 * x1 + x) / 6,\n              y: (y0 + 4 * y1 + y) / 6\n            });\n            break;\n          } else {\n            output += $path.lineTo({\n              x: (5 * x0 + x1) / 6,\n              y: (5 * y0 + y1) / 6\n            }); // fall-through\n          }\n\n        default:\n          pushCurve(x, y);\n          break;\n      }\n\n      x0 = x1;\n      x1 = x;\n      y0 = y1;\n      y1 = y;\n    };\n\n    $array.each(points, pushPoint);\n\n    if (this._closed) {\n      switch (point) {\n        case 1:\n          output += $path.moveTo({\n            x: x2,\n            y: y2\n          });\n          output += $path.closePath();\n          break;\n\n        case 2:\n          output += $path.moveTo({\n            x: (x2 + 2 * x3) / 3,\n            y: (y2 + 2 * y3) / 3\n          });\n          output += $path.lineTo({\n            x: (x3 + 2 * x2) / 3,\n            y: (y3 + 2 * y2) / 3\n          });\n          output += $path.closePath();\n          break;\n\n        case 3:\n          pushPoint({\n            x: x2,\n            y: y2\n          });\n          pushPoint({\n            x: x3,\n            y: y3\n          });\n          pushPoint({\n            x: x4,\n            y: y4\n          });\n          break;\n      }\n    } else {\n      switch (point) {\n        case 3:\n          pushCurve(x1, y1);\n        // fall-through\n\n        case 2:\n          output += $path.lineTo({\n            x: x1,\n            y: y1\n          });\n          break;\n      }\n\n      output += $path.closePath();\n    }\n\n    return output;\n  };\n\n  return Basis;\n}();\n\nexport { Basis };","map":null,"metadata":{},"sourceType":"module"}