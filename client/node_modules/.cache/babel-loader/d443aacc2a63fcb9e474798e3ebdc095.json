{"ast":null,"code":"/**\r\n * Cursor module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../../core/Container\";\nimport { getInteraction } from \"../../core/interaction/Interaction\";\nimport { registry } from \"../../core/Registry\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { MouseCursorStyle } from \"../../core/interaction/Mouse\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Main Cursor class with common cursor functionality.\r\n *\r\n * Chart-specific cursors must extend this class.\r\n *\r\n * @see {@link ICursorEvents} for a list of available events\r\n * @see {@link ICursorAdapters} for a list of available Adapters\r\n * @todo Add description, examples\r\n * @todo Should we allow changing `_generalBehavior`?\r\n */\n\nvar Cursor =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Cursor, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Cursor() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Current cursor position during selection.\r\n     *\r\n     * @todo Better description\r\n     */\n\n\n    _this.point = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * Specifies the rules when cursor needs to be moved or hidden.\r\n     */\n\n    _this._stick = \"none\";\n    _this.className = \"Cursor\"; // Set defaults\n\n    _this.width = percent(100);\n    _this.height = percent(100);\n    _this.shouldClone = false;\n\n    _this.hide(0);\n\n    _this.trackable = true;\n    _this.clickable = true;\n    _this.isMeasured = false; // Add events on body to trigger down and up events (to start zooming or\n    // selection)\n\n    var interaction = getInteraction();\n\n    _this._disposers.push(interaction.body.events.on(\"down\", _this.handleCursorDown, _this));\n\n    _this._disposers.push(interaction.body.events.on(\"up\", _this.handleCursorUp, _this));\n\n    _this._disposers.push(interaction.body.events.on(\"track\", _this.handleCursorMove, _this)); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Handle pointer movement in document and update cursor position as needed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event Event\r\n   */\n\n\n  Cursor.prototype.handleCursorMove = function (event) {\n    if (!this.interactionsEnabled || this.interactions.isTouchProtected && event.touch) {\n      return;\n    }\n\n    if ((this._generalBehavior != \"zoom\" && this._generalBehavior != \"pan\" || !this.downPoint) && !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {\n      // We want to let zoom/pan continue even if cursor is outside chart area\n      if (!this.isHidden || !this.isHiding) {\n        this.hide();\n      }\n\n      return;\n    }\n\n    var local = $utils.documentPointToSprite(event.pointer.point, this);\n\n    if (this._stick == \"hard\" && this._stickPoint) {\n      local = this._stickPoint;\n    }\n\n    if (this._stick == \"soft\" && this._stickPoint) {\n      if (!this.fitsToBounds(local)) {\n        local = this._stickPoint;\n      }\n    }\n\n    this.triggerMove(local);\n    return local;\n  };\n  /**\r\n   * Hides actual SVG elements and handles hiding animations.\r\n   *\r\n   * @param duration  Fade out duration (ms)\r\n   * @return Fade out duration (ms)\r\n   * @ignore\r\n   */\n\n\n  Cursor.prototype.hideReal = function (duration) {\n    if ((this._stick == \"hard\" || this._stick == \"soft\") && this._stickPoint) {\n      return;\n    }\n\n    return _super.prototype.hideReal.call(this, duration);\n  };\n  /**\r\n   * Places the cursor at specific point.\r\n   *\r\n   * The second parameter has following options:\r\n   *\r\n   * `\"none\"` - placed cursor will only be there until mouse/touch moves, then\r\n   * it either moves to a new place (if pointer over plot area) or is hidden.\r\n   *\r\n   * `\"soft\"` - cursor will stay in the place if mouse/touch is happening\r\n   * outside chart, but will move to a new place whe plot area is hovered or\r\n   * touched.\r\n   *\r\n   * `\"hard\"` - cursor will stay in place no matter what, until it is moved by\r\n   * another `triggerMove()` call.\r\n   *\r\n   * @param point  Point to place cursor at\r\n   * @param stick  Level of cursor stickiness to the place\r\n   */\n\n\n  Cursor.prototype.triggerMove = function (point, stick) {\n    point.x = $math.round(point.x, 1);\n    point.y = $math.round(point.y, 1);\n\n    if (stick) {\n      this._stick = stick;\n    }\n\n    if (stick == \"hard\" || stick == \"soft\") {\n      this._stickPoint = point;\n    }\n\n    this.triggerMoveReal(point);\n  };\n  /**\r\n   * Places the cursor at specific point.\r\n   *\r\n   * @param point Point to place cursor at\r\n   */\n\n\n  Cursor.prototype.triggerMoveReal = function (point) {\n    if (this.point.x != point.x || this.point.y != point.y) {\n      this.point = point;\n      this.invalidatePosition(); // hide cursor if it's out of bounds\n\n      if (this.fitsToBounds(point)) {\n        this.show(0);\n      } else {\n        // unless we are selecting (mouse is down)\n        if (!this.downPoint) {\n          this.hide(0);\n        }\n      }\n\n      if (this.visible) {\n        this.getPositions();\n        this.dispatch(\"cursorpositionchanged\"); // not good to dispatch later (check step count example)\n      }\n    }\n  };\n  /**\r\n   * Simulates pressing down (click/touch) action by a cursor.\r\n   *\r\n   * @param point               Point of action\r\n   */\n\n\n  Cursor.prototype.triggerDown = function (point) {\n    this.triggerDownReal(point);\n  };\n  /**\r\n   * Simulates pressing down (click/touch) action by a cursor.\r\n   *\r\n   * @param point               Point of action\r\n   */\n\n\n  Cursor.prototype.triggerDownReal = function (point) {\n    switch (this._generalBehavior) {\n      case \"zoom\":\n        this.dispatchImmediately(\"zoomstarted\");\n        break;\n\n      case \"select\":\n        this.dispatchImmediately(\"selectstarted\");\n        break;\n\n      case \"pan\":\n        this.dispatchImmediately(\"panstarted\");\n        getInteraction().setGlobalStyle(MouseCursorStyle.grabbing);\n        break;\n    }\n  };\n  /**\r\n   * Simulates the action of release of the mouse down / touch.\r\n   *\r\n   * @param point               Point of action\r\n   */\n\n\n  Cursor.prototype.triggerUp = function (point) {\n    this.triggerUpReal(point);\n  };\n  /**\r\n   * Simulates the action of release of the mouse down / touch.\r\n   *\r\n   * @param point               Point of action\r\n   */\n\n\n  Cursor.prototype.triggerUpReal = function (point) {\n    this.updatePoint(this.upPoint);\n    var interaction = getInteraction();\n\n    if ($math.getDistance(this._upPointOrig, this._downPointOrig) > interaction.getHitOption(this.interactions, \"hitTolerance\")) {\n      switch (this._generalBehavior) {\n        case \"zoom\":\n          this.dispatchImmediately(\"zoomended\");\n          break;\n\n        case \"select\":\n          this.dispatchImmediately(\"selectended\");\n          break;\n\n        case \"pan\":\n          this.dispatchImmediately(\"panended\");\n          interaction.setGlobalStyle(MouseCursorStyle.default);\n          break;\n      }\n\n      this.downPoint = undefined;\n      this.updateSelection();\n    } else {\n      this.dispatchImmediately(\"behaviorcanceled\");\n      interaction.setGlobalStyle(MouseCursorStyle.default);\n      this.downPoint = undefined;\n    }\n  };\n  /**\r\n   * Updates selection dimensions on size change.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Cursor.prototype.updateSelection = function () {};\n  /**\r\n   * Updates cursors current positions.\r\n   */\n\n\n  Cursor.prototype.getPositions = function () {\n    // positions are used by axes or series\n    this.xPosition = this.point.x / this.innerWidth;\n    this.yPosition = 1 - this.point.y / this.innerHeight;\n  };\n  /**\r\n   * Handles pointer down event so we can start zoom or selection.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event Original event\r\n   */\n\n\n  Cursor.prototype.handleCursorDown = function (event) {\n    if (!this.interactionsEnabled || this.interactions.isTouchProtected && event.touch || !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {\n      return;\n    } // Get local point\n\n\n    var local = $utils.documentPointToSprite(event.pointer.point, this);\n    this._downPointOrig = {\n      x: local.x,\n      y: local.y\n    }; // We need to cancel the event to prevent gestures on touch devices\n\n    if (event.event.cancelable && this.shouldPreventGestures(event.touch) && this.fitsToBounds(local)) {\n      event.event.preventDefault();\n    } // Make this happen\n\n\n    this.triggerMove(local);\n    this.triggerDown(local);\n  };\n  /**\r\n   * Determines whether Cursor should prevent default action on move.\r\n   *\r\n   * Child classes should override this as necessary.\r\n   *\r\n   * @return Prevent default?\r\n   */\n\n\n  Cursor.prototype.shouldPreventGestures = function (touch) {\n    return true;\n  };\n  /**\r\n   * Updates the coordinates of where pointer down event occurred\r\n   * (was pressed).\r\n   */\n\n\n  Cursor.prototype.updatePoint = function (point) {};\n  /**\r\n   * Handles pointer up event - finishes zoom or selection action.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event Original event\r\n   */\n\n\n  Cursor.prototype.handleCursorUp = function (event) {\n    if (!this.interactionsEnabled) {\n      return;\n    }\n\n    if ((this._generalBehavior != \"zoom\" && this._generalBehavior != \"pan\" || !this.downPoint) && !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {\n      return;\n    }\n\n    var local = $utils.documentPointToSprite(event.pointer.point, this);\n    this._upPointOrig = {\n      x: local.x,\n      y: local.y\n    };\n    this.triggerMove(local);\n    this.triggerUp(local);\n  };\n\n  Object.defineProperty(Cursor.prototype, \"chart\", {\n    /**\r\n     * @return Chart\r\n     */\n    get: function () {\n      return this._chart;\n    },\n\n    /**\r\n     * A reference to a [[Chart]] the cursor belongs to.\r\n     *\r\n     * @param value  Chart\r\n     */\n    set: function (value) {\n      this._chart = value;\n\n      if ($type.hasValue(this._chart.plotContainer)) {\n        getInteraction().lockElement(this._chart.plotContainer.interactions);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Cursor;\n}(Container);\n\nexport { Cursor };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Cursor\"] = Cursor;","map":null,"metadata":{},"sourceType":"module"}