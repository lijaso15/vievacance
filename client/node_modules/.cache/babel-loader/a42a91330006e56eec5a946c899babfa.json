{"ast":null,"code":"/**\r\n * CSV parser.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { DataParser } from \"./DataParser\";\nimport * as $type from \"../utils/Type\";\nimport * as $array from \"../utils/Array\";\n/**\r\n * Define possible separators.\r\n */\n\nvar separators = [\",\", \";\", \"\\t\"];\n/**\r\n * A parser for CSV format.\r\n *\r\n * @important\r\n */\n\nvar CSVParser =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(CSVParser, _super);\n\n  function CSVParser() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Content-type suitable for CSV format.\r\n     */\n\n\n    _this.contentType = \"text/csv\";\n    /**\r\n     * Parser options.\r\n     *\r\n     * @see {@link ICSVOptions} for description of each option\r\n     */\n\n    _this.options = {\n      delimiter: \"\",\n      reverse: false,\n      skipRows: 0,\n      skipEmpty: true,\n      useColumnNames: false\n    };\n    return _this;\n  }\n  /**\r\n   * Tests if the format is CSV.\r\n   *\r\n   * @param data  Source data\r\n   * @return Is it CSV?\r\n   */\n\n\n  CSVParser.isCSV = function (data) {\n    return CSVParser.getDelimiterFromData(data) ? true : false;\n  };\n  /**\r\n   * Tries to determine a column separator.\r\n   *\r\n   * @param data  Source data\r\n   * @return Separator\r\n   */\n\n\n  CSVParser.getDelimiterFromData = function (data) {\n    // We're going to take first few lines of the CSV with different\n    // possible separators and check if it results in same number of columns.\n    // If it does, we're going to assume it's a CSV\n    var lines = data.split(\"\\n\");\n    var len = lines.length;\n    var separator;\n    $array.each(separators, function (sep) {\n      var columns = 0,\n          lineColums = 0; // TODO replace with iterators\n\n      for (var i = 0; i < len; ++i) {\n        // Get number of columns in a line\n        columns = lines[i].split(sep).length;\n\n        if (columns > 1) {\n          // More than one column - possible candidate\n          if (lineColums === 0) {\n            // First line\n            lineColums = columns;\n          } else if (columns != lineColums) {\n            // Incorrect number of columns, give up on this separator\n            lineColums = 0;\n            break;\n          }\n        } else {\n          // Not this separator\n          // Not point in continuing\n          lineColums = 0;\n          break;\n        }\n      } // Check if we have a winner\n\n\n      if (lineColums) {\n        separator = sep;\n      }\n    });\n    return separator;\n  };\n  /**\r\n   * Parses and returns data.\r\n   *\r\n   * @param data  Unparsed data\r\n   * @return Parsed data\r\n   */\n\n\n  CSVParser.prototype.parse = function (csv) {\n    // Check if we have delimiter set\n    if (!this.options.delimiter) {\n      this.options.delimiter = CSVParser.getDelimiterFromData(csv);\n    } // Get CSV data as array\n\n\n    var data = this.CSVToArray(csv, this.options.delimiter); // Do we need to cast some fields to numbers?\n\n    var empty = $type.hasValue(this.options.emptyAs);\n    var numbers = this.parsableNumbers;\n    var dates = this.parsableDates; // Init resuling array\n\n    var res = [],\n        cols = [],\n        col,\n        i; // Skip rows\n\n    for (i = 0; i < this.options.skipRows; i++) {\n      data.shift();\n    } // First row holds column names?\n\n\n    if (this.options.useColumnNames) {\n      cols = data.shift(); // Normalize column names\n\n      for (var x = 0; x < cols.length; x++) {\n        // trim\n        col = $type.hasValue(cols[x]) ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\"; // Check for empty\n\n        if (\"\" === col) {\n          col = \"col\" + x;\n        }\n\n        cols[x] = col;\n      }\n    } // Iterate through the result set\n\n\n    var row;\n\n    while (true) {\n      row = this.options.reverse ? data.pop() : data.shift();\n\n      if (!row) {\n        break;\n      }\n\n      if (this.options.skipEmpty && row.length === 1 && row[0] === \"\") {\n        continue;\n      }\n\n      var dataPoint = {};\n\n      for (i = 0; i < row.length; i++) {\n        col = undefined === cols[i] ? \"col\" + i : cols[i];\n        dataPoint[col] = row[i] === \"\" ? this.options.emptyAs : row[i]; // Convert\n\n        if (empty) {\n          dataPoint[col] = this.maybeToEmpty(dataPoint[col]);\n        }\n\n        if (numbers) {\n          dataPoint[col] = this.maybeToNumber(col, dataPoint[col]);\n        }\n\n        if (dates) {\n          dataPoint[col] = this.maybeToDate(col, dataPoint[col]);\n        }\n      }\n\n      res.push(dataPoint);\n    }\n\n    return res;\n  };\n  /**\r\n   * Converts CSV into array.\r\n   *\r\n   * The functionality of this function is taken from here:\r\n   * http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm\r\n   *\r\n   * @param data       Source data\r\n   * @param delimiter  Column delimiter\r\n   * @return Parsed array\r\n   */\n\n\n  CSVParser.prototype.CSVToArray = function (data, delimiter) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    delimiter = delimiter || ','; // Create a regular expression to parse the CSV values.\n\n    var objPattern = new RegExp( // Delimiters.\n    \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" + // Quoted fields.\n    \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" + // Standard fields.\n    \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\", \"gi\"); // Create an array to hold our data. Give the array\n    // a default empty first row.\n\n    var arrData = [[]]; // Create an array to hold our individual pattern\n    // matching groups.\n\n    var arrMatches = null; // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n\n    while (true) {\n      arrMatches = objPattern.exec(data);\n\n      if (!arrMatches) {\n        break;\n      } // Get the delimiter that was found.\n\n\n      var strMatchedDelimiter = arrMatches[1]; // Check to see if the given delimiter has a length\n      // (is not the start of string) and if it matches\n      // field delimiter. If id does not, then we know\n      // that this delimiter is a row delimiter.\n\n      if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n        // Since we have reached a new row of data,\n        // add an empty row to our data array.\n        arrData.push([]);\n      } // Now that we have our delimiter out of the way,\n      // let's check to see which kind of value we\n      // captured (quoted or unquoted).\n\n\n      var strMatchedValue = void 0;\n\n      if (arrMatches[2]) {\n        // We found a quoted value. When we capture\n        // this value, unescape any double quotes.\n        strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n      } else {\n        // We found a non-quoted value.\n        strMatchedValue = arrMatches[3];\n      } // Now that we have our value string, let's add\n      // it to the data array.\n\n\n      arrData[arrData.length - 1].push(strMatchedValue);\n    } // Return the parsed data.\n\n\n    return arrData;\n  };\n\n  return CSVParser;\n}(DataParser);\n\nexport { CSVParser };","map":null,"metadata":{},"sourceType":"module"}