{"ast":null,"code":"/**\r\n * Line series segment module.\r\n * @todo Add description about what this is\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../../core/Container\";\nimport { Sprite, visualProperties } from \"../../core/Sprite\";\nimport { registry } from \"../../core/Registry\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $object from \"../../core/utils/Object\";\nimport { color } from \"../../core/utils/Color\";\nimport * as $smoothing from \"../../core/rendering/Smoothing\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Represents a line series segment.\r\n *\r\n * A line segment can be used to apply different properties to a part of the\r\n * line series, between two data points.\r\n *\r\n * @see {@link ILineSeriesSegmentEvents} for a list of available events\r\n * @see {@link ILineSeriesSegmentAdapters} for a list of available Adapters\r\n * @todo Example\r\n */\n\nvar LineSeriesSegment =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(LineSeriesSegment, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function LineSeriesSegment() {\n    var _this = // Init\n    _super.call(this) || this;\n\n    _this.className = \"LineSeriesSegment\"; // Set defaults\n\n    _this.isMeasured = false;\n    _this.interactionsEnabled = false;\n    _this.layout = \"none\"; // Create fill element\n\n    var fillSprite = _this.createChild(Sprite);\n\n    _this.fillSprite = fillSprite;\n    fillSprite.shouldClone = false;\n    fillSprite.setElement(_this.paper.add(\"path\"));\n    fillSprite.isMeasured = false;\n\n    _this._disposers.push(fillSprite); // Create line element\n\n\n    var strokeSprite = _this.createChild(Sprite);\n\n    _this.strokeSprite = strokeSprite;\n    strokeSprite.shouldClone = false;\n    strokeSprite.fill = color();\n    strokeSprite.setElement(_this.paper.add(\"path\"));\n    strokeSprite.isMeasured = false;\n\n    _this._disposers.push(strokeSprite);\n\n    return _this;\n  }\n  /**\r\n   * Draws the series segment.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param points       Points to connect\r\n   * @param closePoints  ?\r\n   * @param smoothnessX  Horizontal bezier setting (?)\r\n   * @param smoothnessY  Vertical bezier setting (?)\r\n   */\n\n\n  LineSeriesSegment.prototype.drawSegment = function (points, closePoints, smoothnessX, smoothnessY) {\n    if (!this.disabled) {\n      if (points.length > 0 && closePoints.length > 0) {\n        // first moveTo helps to avoid Chrome straight line in the mask bug.\n        var path = $path.moveTo({\n          x: points[0].x - 0.2,\n          y: points[0].y - 0.2\n        }) + $path.moveTo(points[0]) + new $smoothing.Tension(smoothnessX, smoothnessY).smooth(points);\n\n        if (this.strokeOpacity == 0 || this.strokeSprite.strokeOpacity == 0) {// like this and not if != 0, otherwise ranges stroke won't be drawn.\n        } else {\n          this.strokeSprite.path = path;\n        }\n\n        if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) {\n          // helps to avoid drawing fill object if fill is not visible\n          path += $path.lineTo(closePoints[0]) + new $smoothing.Tension(smoothnessX, smoothnessY).smooth(closePoints);\n          path += $path.lineTo(points[0]);\n          path += $path.closePath();\n          this.fillSprite.path = path;\n        }\n      } else {\n        this.fillSprite.path = \"\";\n        this.strokeSprite.path = \"\";\n      }\n    }\n  };\n  /**\r\n   * Copies properties from a [[Sprite]] to both line and fill elements.\r\n   *\r\n   * @param source Source [[Sprite]] to copy properties from\r\n   */\n\n\n  LineSeriesSegment.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    var lineElement = this.strokeSprite;\n    $object.copyProperties(source, lineElement.properties, visualProperties);\n    lineElement.events.copyFrom(source.strokeSprite.events);\n    lineElement.fillOpacity = 0;\n    var fillElement = this.fillSprite;\n    $object.copyProperties(source, fillElement.properties, visualProperties);\n    fillElement.events.copyFrom(source.fillSprite.events);\n    fillElement.strokeOpacity = 0;\n  };\n\n  return LineSeriesSegment;\n}(Container);\n\nexport { LineSeriesSegment };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"LineSeriesSegment\"] = LineSeriesSegment;","map":null,"metadata":{},"sourceType":"module"}