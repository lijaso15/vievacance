{"ast":null,"code":"/**\r\n * Defines Pie Chart Series.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { PercentSeries, PercentSeriesDataItem } from \"./PercentSeries\";\nimport { Slice } from \"../../core/elements/Slice\"; //import { Slice3D } from \"../../core/elements/3D/Slice3D\";\n\nimport { AxisLabelCircular } from \"../axes/AxisLabelCircular\";\nimport { PieTick } from \"../elements/PieTick\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport { Percent, percent } from \"../../core/utils/Percent\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n//@todo: sequenced?\n\n/**\r\n * Defines a [[DataItem]] for [[PieSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar PieSeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PieSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function PieSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"PieSeriesDataItem\";\n    _this.values.radiusValue = {};\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(PieSeriesDataItem.prototype, \"radiusValue\", {\n    /**\r\n     * @return Radius\r\n     */\n    get: function () {\n      return this.values.radiusValue.value;\n    },\n\n    /**\r\n     * Slice's radius, if other than default.\r\n     *\r\n     * @param value  Radius\r\n     */\n    set: function (value) {\n      this.setValue(\"radiusValue\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Hide the data item (and corresponding visual elements).\r\n   *\r\n   * @param duration  Duration (ms)\r\n   * @param delay     Delay hiding (ms)\r\n   * @param toValue   Target value for animation\r\n   * @param fields    Fields to animate while hiding\r\n   */\n\n  PieSeriesDataItem.prototype.hide = function (duration, delay, toValue, fields) {\n    return _super.prototype.hide.call(this, duration, delay, 0, [\"value\", \"radiusValue\"]);\n  };\n  /**\r\n   * Show hidden data item (and corresponding cisual elements).\r\n   *\r\n   * @param duration  Duration (ms)\r\n   * @param delay     Delay hiding (ms)\r\n   * @param fields    Fields to animate while hiding\r\n   */\n\n\n  PieSeriesDataItem.prototype.show = function (duration, delay, fields) {\n    return _super.prototype.show.call(this, duration, delay, [\"value\", \"radiusValue\"]);\n  };\n\n  return PieSeriesDataItem;\n}(PercentSeriesDataItem);\n\nexport { PieSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines [[Series]] for a slice series on a Pie chart.\r\n *\r\n * @see {@link IPieSeriesEvents} for a list of available Events\r\n * @see {@link IPieSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\n\nvar PieSeries =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PieSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function PieSeries() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"PieSeries\";\n    _this.alignLabels = true;\n    _this.startAngle = -90;\n    _this.endAngle = 270;\n    _this.layout = \"none\";\n    _this.labels.template.radius = percent(5);\n\n    _this.addDisposer(_this.labels.template.events.on(\"enabled\", _this.invalidate, _this, false));\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * creates slice\r\n   */\n\n\n  PieSeries.prototype.createSlice = function () {\n    return new Slice();\n  };\n  /**\r\n   * creates tick\r\n   */\n\n\n  PieSeries.prototype.createTick = function () {\n    return new PieTick();\n  };\n  /**\r\n   * creates label\r\n   */\n\n\n  PieSeries.prototype.createLabel = function () {\n    return new AxisLabelCircular();\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  PieSeries.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Pie Slice Series\");\n    }\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  PieSeries.prototype.createDataItem = function () {\n    return new PieSeriesDataItem();\n  };\n  /**\r\n   * Inits slice.\r\n   *\r\n   * @param slice to init\r\n   */\n\n\n  PieSeries.prototype.initSlice = function (slice) {\n    slice.isMeasured = false;\n    slice.defaultState.properties.scale = 1;\n    slice.observe(\"scale\", this.handleSliceScale, this);\n    slice.observe([\"dx\", \"dy\", \"x\", \"y\", \"shiftRadius\"], this.handleSliceMove, this);\n    slice.tooltipText = \"{category}: {value.percent.formatNumber('#.#')}% ({value.value})\";\n    var hoverState = slice.states.create(\"hover\");\n    hoverState.properties.scale = 1.05;\n    var defaultState = slice.defaultState;\n    defaultState.properties.shiftRadius = 0;\n    slice.togglable = true;\n    slice.events.on(\"toggled\", function (event) {\n      event.target.hideTooltip();\n    });\n    var activeState = slice.states.create(\"active\");\n    activeState.properties.shiftRadius = 0.10;\n  };\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  PieSeries.prototype.validate = function () {\n    this._leftItems = [];\n    this._rightItems = [];\n    this._currentStartAngle = this.startAngle;\n    this._arcRect = $math.getArcRect(this.startAngle, this.endAngle);\n    this._maxRadiusPercent = 0;\n\n    for (var i = this.startIndex; i < this.endIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      var radiusValuePercent = dataItem.values.radiusValue.percent;\n\n      if (radiusValuePercent > this._maxRadiusPercent) {\n        this._maxRadiusPercent = radiusValuePercent;\n      }\n    }\n\n    _super.prototype.validate.call(this);\n\n    if (this.alignLabels) {\n      if (this.startAngle > this.endAngle) {\n        this._rightItems.reverse();\n      } else {\n        this._leftItems.reverse();\n      }\n\n      this._rightItems.sort(function (a, b) {\n        var aAngle = (a.slice.middleAngle + 360) % 360;\n        var bAngle = (b.slice.middleAngle + 360) % 360;\n\n        if (aAngle > 270) {\n          aAngle -= 360;\n        }\n\n        if (bAngle > 270) {\n          bAngle -= 360;\n        }\n\n        if (aAngle < bAngle) {\n          return -1;\n        } else {\n          return 1;\n        }\n      });\n\n      this._leftItems.sort(function (a, b) {\n        var aAngle = (a.slice.middleAngle + 360) % 360;\n        var bAngle = (b.slice.middleAngle + 360) % 360;\n\n        if (aAngle < bAngle) {\n          return 1;\n        } else {\n          return -1;\n        }\n      });\n\n      this.arrangeLabels(this._rightItems);\n      this.arrangeLabels2(this._rightItems);\n      this.arrangeLabels(this._leftItems);\n      this.arrangeLabels2(this._leftItems);\n    }\n  };\n  /**\r\n   * Validates data item's element, effectively redrawing it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n\n\n  PieSeries.prototype.validateDataElement = function (dataItem) {\n    if (this.pixelRadius > 0) {\n      // SLICE\n      var slice = dataItem.slice;\n      slice.radius = this.pixelRadius;\n\n      if ($type.isNumber(dataItem.radiusValue)) {\n        slice.radius = this.pixelInnerRadius + (this.pixelRadius - this.pixelInnerRadius) * dataItem.values.radiusValue.percent / this._maxRadiusPercent;\n      }\n\n      if (!(slice.innerRadius instanceof Percent)) {\n        slice.innerRadius = this.pixelInnerRadius;\n      }\n\n      slice.startAngle = this._currentStartAngle;\n      slice.arc = dataItem.values.value.percent * (this.endAngle - this.startAngle) / 100; // LABEL\n\n      if (!this.labels.template.disabled) {\n        var label = dataItem.label;\n        var tick = dataItem.tick;\n        tick.slice = slice;\n        tick.label = label;\n        var normalizedMiddleAngle = (slice.middleAngle + 360) % 360; // force angle to be 0 - 360;\n\n        var point = void 0;\n\n        if (this.alignLabels) {\n          var labelRadius = label.pixelRadius(slice.radius);\n          var x = tick.length + labelRadius;\n          label.dx = 0;\n          label.dy = 0;\n          label.verticalCenter = \"middle\";\n          var arcRect = this._arcRect; // right half\n\n          if (normalizedMiddleAngle >= 270 || normalizedMiddleAngle <= 90) {\n            // 91 makes less chances for flickering\n            x += (arcRect.width + arcRect.x) * this.pixelRadius;\n            label.horizontalCenter = \"left\";\n\n            this._rightItems.push(dataItem);\n          } // left half\n          else {\n              x -= arcRect.x * this.pixelRadius;\n              label.horizontalCenter = \"right\";\n\n              this._leftItems.push(dataItem);\n\n              x *= -1;\n            }\n\n          var distance = slice.radius + tick.length + labelRadius;\n          point = {\n            x: x,\n            y: slice.iy * distance\n          };\n          label.moveTo(point);\n        } else {\n          var depth = slice[\"depth\"];\n\n          if (!$type.isNumber(depth)) {\n            depth = 0;\n          }\n\n          label.fixPosition(slice.middleAngle, slice.radius, slice.radiusY, 0, -depth);\n        }\n      }\n\n      this._currentStartAngle += slice.arc; // do this at the end, otherwise bullets won't be positioned properly\n\n      _super.prototype.validateDataElement.call(this, dataItem);\n    }\n  };\n\n  Object.defineProperty(PieSeries.prototype, \"radius\", {\n    /**\r\n     * @return Radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"radius\");\n    },\n\n    /**\r\n     * Outer radius for the series' slices in pixels or [[Percent]].\r\n     *\r\n     * @param value  Radius\r\n     */\n    set: function (value) {\n      if (this.setPercentProperty(\"radius\", value, true, false, 10, false)) {\n        this.invalidateDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PieSeries.prototype, \"pixelRadius\", {\n    /**\r\n     * @return Radius\r\n     * @ignore\r\n     */\n    get: function () {\n      return this._pixelRadius;\n    },\n\n    /**\r\n     * @ignore\r\n     */\n    set: function (value) {\n      if (this._pixelRadius != value) {\n        this._pixelRadius = value;\n        this.invalidateDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PieSeries.prototype, \"pixelInnerRadius\", {\n    /**\r\n     * @return Pixel inner radius\r\n     * @ignore\r\n     */\n    get: function () {\n      return this._pixelInnerRadius;\n    },\n\n    /**\r\n     * @ignore\r\n     */\n    set: function (value) {\n      if (this._pixelInnerRadius != value) {\n        this._pixelInnerRadius = value;\n        this.invalidateDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PieSeries.prototype, \"innerRadius\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"innerRadius\");\n    },\n\n    /**\r\n     * Inner radius for the series' slices in pixels.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Redo so that users can set it\r\n     * @param value  Radius\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"innerRadius\", value, true, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PieSeries.prototype, \"startAngle\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"startAngle\");\n    },\n\n    /**\r\n     * Start angle for the series' slices in degrees. (0-360)\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Redo so that users can set it\r\n     * @param value  Angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"startAngle\", $math.normalizeAngle(value), true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PieSeries.prototype, \"endAngle\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"endAngle\");\n    },\n\n    /**\r\n     * End angle for the series' slices in degrees. (0-360)\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Redo so that users can set it\r\n     * @param value  Angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"endAngle\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Positions series bullet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param bullet  Bullet\r\n   */\n\n  PieSeries.prototype.positionBullet = function (bullet) {\n    _super.prototype.positionBullet.call(this, bullet);\n\n    var dataItem = bullet.dataItem;\n    var slice = dataItem.slice;\n    var locationX = bullet.locationX;\n\n    if (!$type.isNumber(locationX)) {\n      locationX = 0.5;\n    }\n\n    var locationY = bullet.locationY;\n\n    if (!$type.isNumber(locationY)) {\n      locationY = 1;\n    }\n\n    var angle = slice.startAngle + slice.arc * locationX;\n    bullet.x = locationY * slice.radius * $math.cos(angle);\n    bullet.y = locationY * slice.radiusY * $math.sin(angle);\n  };\n  /**\r\n   * Repositions bullet and labels when slice moves.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event  Event\r\n   */\n\n\n  PieSeries.prototype.handleSliceMove = function (event) {\n    if (!this.alignLabels) {\n      var slice = event.target;\n      var dataItem = slice.dataItem; // moving textelement, as label dx and dy are already employed for aligning\n      //@labeltodo\n\n      if (dataItem) {\n        var label = dataItem.label;\n\n        if (label) {\n          label.dx = label.fdx + slice.dx + slice.pixelX;\n          label.dy = label.fdy + slice.dy + slice.pixelY;\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(PieSeries.prototype, \"bbox\", {\n    /**\r\n     * Returns bounding box (square) for this element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n    get: function () {\n      if (this.definedBBox) {\n        return this.definedBBox;\n      }\n\n      var chart = this.chart;\n\n      if (chart) {\n        return $math.getArcRect(chart.startAngle, chart.endAngle, this.pixelRadius);\n      }\n\n      return $math.getArcRect(this.startAngle, this.endAngle, this.pixelRadius);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PieSeries;\n}(PercentSeries);\n\nexport { PieSeries };\n/**\r\n * bboxter class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"PieSeries\"] = PieSeries;\nregistry.registeredClasses[\"PieSeriesDataItem\"] = PieSeriesDataItem;","map":null,"metadata":{},"sourceType":"module"}