{"ast":null,"code":"/**\r\n * Module, defining Axis Renderer for radial axes.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { CategoryAxis } from \"./CategoryAxis\";\nimport { WavedCircle } from \"../../core/elements/WavedCircle\";\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A renderer for radial axis.\r\n */\n\nvar AxisRendererRadial =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(AxisRendererRadial, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param axis Related axis\r\n   */\n\n\n  function AxisRendererRadial() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A related chart.\r\n     */\n\n\n    _this._chart = new MutableValueDisposer();\n    /**\r\n     * @ignore\r\n     */\n\n    _this.pixelRadiusReal = 0;\n    _this.className = \"AxisRendererRadial\";\n    _this.isMeasured = false;\n    _this.startAngle = -90;\n    _this.endAngle = 270;\n    _this.minGridDistance = 30;\n    _this.gridType = \"circles\";\n    _this.axisAngle = -90;\n    _this.isMeasured = false;\n    _this.layout = \"none\";\n    _this.radius = percent(100);\n    _this.line.strokeOpacity = 0;\n    _this.labels.template.horizontalCenter = \"middle\";\n\n    _this._disposers.push(_this._chart);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Validates Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererRadial.prototype.validate = function () {\n    // so that radius would be updated\n    if (this.chart && this.chart.invalid) {\n      this.chart.validate();\n    }\n\n    _super.prototype.validate.call(this);\n  };\n\n  Object.defineProperty(AxisRendererRadial.prototype, \"axisLength\", {\n    /**\r\n     * Returns actual length of the Axis, in pixels.\r\n     *\r\n     * @return Length (px)\r\n     */\n    get: function () {\n      return this.pixelRadius - this.pixelInnerRadius;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"radius\", {\n    /**\r\n     * @return Outer radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"radius\");\n    },\n\n    /**\r\n     * Outer radius of the axis.\r\n     *\r\n     * Can be absolute (px) or relative ([[Percent]]).\r\n     *\r\n     * @param value  Outer radius\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"radius\", value, false, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"pixelRadius\", {\n    /**\r\n     * Outer radius in pixels.\r\n     *\r\n     * @return Outer radius (px)\r\n     */\n    get: function () {\n      return $utils.relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"innerRadius\", {\n    /**\r\n     * @return Inner radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"innerRadius\");\n    },\n\n    /**\r\n     * Inner radius of the axis.\r\n     *\r\n     * Can be absolute (px) or relative ([[Percent]]).\r\n     *\r\n     * @param value  Outer radius\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"innerRadius\", value, false, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"pixelInnerRadius\", {\n    /**\r\n     * Inner radius in pixels.\r\n     *\r\n     * @return Inner radius (px)\r\n     */\n    get: function () {\n      return $utils.relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"chart\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Chart\r\n     */\n    get: function () {\n      return this._chart.get();\n    },\n\n    /**\r\n     * Chart, associated with the Axis.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value Chart\r\n     */\n    set: function (chart) {\n      this._chart.set(chart, null);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts relative position on axis to point coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Point\r\n   */\n\n  AxisRendererRadial.prototype.positionToPoint = function (position) {\n    var radius = $math.fitToRange(this.positionToCoordinate(position), 0, Infinity);\n    return {\n      x: radius * $math.cos(this.axisAngle),\n      y: radius * $math.sin(this.axisAngle)\n    };\n  };\n  /**\r\n   * Updates and positions the axis line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererRadial.prototype.updateAxisLine = function () {\n    this.line.path = $path.moveTo({\n      x: this.pixelInnerRadius * $math.cos(this.axisAngle),\n      y: this.pixelInnerRadius * $math.sin(this.axisAngle)\n    }) + $path.lineTo({\n      x: this.pixelRadius * $math.cos(this.axisAngle),\n      y: this.pixelRadius * $math.sin(this.axisAngle)\n    });\n    var title = this.axis.title;\n    title.valign = \"none\";\n    title.horizontalCenter = \"middle\";\n    title.verticalCenter = \"bottom\";\n    title.y = -this.axisLength / 2;\n    var rotation = 90;\n\n    if (this.opposite) {\n      if (!this.inside) {\n        rotation = -90;\n      }\n    } else {\n      if (this.inside) {\n        rotation = -90;\n      }\n    }\n\n    title.rotation = rotation;\n  };\n  /**\r\n   * Updates and positions a grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param grid         Grid element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererRadial.prototype.updateGridElement = function (grid, position, endPosition) {\n    position = position + (endPosition - position) * grid.location;\n    var point = this.positionToPoint(position);\n    var path;\n    var radius = $math.getDistance(point);\n    var startAngle = this.startAngle;\n    var endAngle = this.endAngle;\n\n    if ($type.isNumber(radius) && grid.element) {\n      var chart = this.chart;\n      var xAxis = chart.xAxes.getIndex(0);\n      var count = chart.dataItems.length;\n      var series = chart.series.getIndex(0); // polygons are only possible if x axis is present\n      // @todo: review this\n\n      if (this.gridType == \"polygons\" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis) {\n        var gridLocation = xAxis.renderer.grid.template.location;\n        var angle = xAxis.getAngle(series.dataItems.getIndex(0), \"categoryX\", gridLocation);\n        path = $path.moveTo({\n          x: radius * $math.cos(angle),\n          y: radius * $math.sin(angle)\n        });\n        var count_1 = chart.dataItems.length;\n\n        for (var i = 1; i < count_1; i++) {\n          angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\n          path += $path.lineTo({\n            x: radius * $math.cos(angle),\n            y: radius * $math.sin(angle)\n          });\n        }\n\n        angle = xAxis.getAngle(series.dataItems.getIndex(count_1 - 1), \"categoryX\", xAxis.renderer.cellEndLocation);\n        path += $path.lineTo({\n          x: radius * $math.cos(angle),\n          y: radius * $math.sin(angle)\n        });\n      } else {\n        path = $path.moveTo({\n          x: radius * $math.cos(startAngle),\n          y: radius * $math.sin(startAngle)\n        }) + $path.arcTo(startAngle, endAngle - startAngle, radius, radius);\n      }\n\n      grid.path = path;\n    }\n\n    this.toggleVisibility(grid, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions a label element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param label        Label element\r\n   * @param position     Starting position\r\n   * @param endPosition  Ending position\r\n   */\n\n\n  AxisRendererRadial.prototype.updateLabelElement = function (label, position, endPosition, location) {\n    if (!$type.hasValue(location)) {\n      location = label.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    var point = this.positionToPoint(position);\n    this.positionItem(label, point);\n    this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\n  };\n  /**\r\n   * Updates and positions the base grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererRadial.prototype.updateBaseGridElement = function () {// @todo? zero grid for radar chart, is it needed?\n  };\n  /**\r\n   * Checks if point is within bounds of a container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param point Point coordinates\r\n   * @return Fits?\r\n   */\n\n\n  AxisRendererRadial.prototype.fitsToBounds = function (point) {\n    return true;\n  };\n\n  Object.defineProperty(AxisRendererRadial.prototype, \"startAngle\", {\n    /**\r\n     * @return Start angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"startAngle\");\n    },\n\n    /**\r\n     * Start angle of the axis in degrees. (0-360)\r\n     *\r\n     * @param value  Start angle\r\n     */\n    set: function (value) {\n      // do not normalize angle here!\n      if (this.setPropertyValue(\"startAngle\", value)) {\n        this.invalidateAxisItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"endAngle\", {\n    /**\r\n     * @return End angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"endAngle\");\n    },\n\n    /**\r\n     * End angle of the axis in degrees. (0-360)\r\n     *\r\n     * @param value  End angle\r\n     */\n    set: function (value) {\n      // do not normalize angel here!\n      if (this.setPropertyValue(\"endAngle\", value)) {\n        this.invalidateAxisItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"axisAngle\", {\n    /**\r\n     * @return Axis angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"axisAngle\"); //return $math.fitToRange(this.getPropertyValue(\"axisAngle\"), this.startAngle, this.endAngle); // no good, as less flexible\n    },\n\n    /**\r\n     * Angle of the radial axis in degrees. (0-360)\r\n     *\r\n     * @param value  Axis angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"axisAngle\", $math.normalizeAngle(value));\n      this.invalidateAxisItems();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"gridType\", {\n    /**\r\n     * Grid type\r\n     */\n    get: function () {\n      var axis = this.chart.xAxes.getIndex(0);\n\n      if (axis instanceof CategoryAxis) {\n        return this.getPropertyValue(\"gridType\");\n      } else {\n        return \"circles\";\n      }\n    },\n    // polygons grid type is only possible under these conditions: xAxis is available and it is CategoryAxis, also at least one series should be added to a chart\n\n    /**\r\n     * Grid type for radial axis.\r\n     *\r\n     * A grid on radia axis can either be perfect circles (\"circles\"), or\r\n     * straight lines (\"polygons\").\r\n     *\r\n     * @default \"circles\"\r\n     * @param value  Grid type\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"gridType\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [getPositionRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param startPosition  Starting position\r\n   * @param endPosition    End position\r\n   * @return SVG path\r\n   */\n\n  AxisRendererRadial.prototype.getPositionRangePath = function (startPosition, endPosition) {\n    var pixelInnerRadius = this.pixelInnerRadius;\n    var pixelRadius = this.axisLength + pixelInnerRadius;\n    var innerRadius = $math.fitToRange(this.positionToCoordinate(startPosition), pixelInnerRadius, pixelRadius);\n    var radius = $math.fitToRange(this.positionToCoordinate(endPosition), pixelInnerRadius, pixelRadius); //let angleCount: number = this.angleCount;\n\n    var startAngle = this.startAngle;\n    var endAngle = this.endAngle;\n    var arc = endAngle - startAngle;\n    var path;\n    var chart = this.chart;\n    var xAxis = chart.xAxes.getIndex(0);\n    var count = chart.dataItems.length;\n    var series = chart.series.getIndex(0); // polygons are only possible if x axis is present\n    // @todo: review this\n\n    if (this.gridType == \"polygons\" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis) {\n      var gridLocation = xAxis.renderer.grid.template.location;\n      var angle = xAxis.getAngle(series.dataItems.getIndex(0), \"categoryX\", gridLocation);\n      path = $path.moveTo({\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      });\n      var count_2 = chart.dataItems.length;\n\n      for (var i = 1; i < count_2; i++) {\n        angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\n        path += $path.lineTo({\n          x: radius * $math.cos(angle),\n          y: radius * $math.sin(angle)\n        });\n      }\n\n      angle = xAxis.getAngle(series.dataItems.getIndex(count_2 - 1), \"categoryX\", xAxis.renderer.cellEndLocation);\n      path += $path.lineTo({\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      });\n      path += $path.moveTo({\n        x: innerRadius * $math.cos(angle),\n        y: innerRadius * $math.sin(angle)\n      });\n\n      for (var i = count_2 - 1; i >= 0; i--) {\n        angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\n        path += $path.lineTo({\n          x: innerRadius * $math.cos(angle),\n          y: innerRadius * $math.sin(angle)\n        });\n      }\n    } else {\n      path = $path.arc(startAngle, arc, radius, innerRadius);\n    }\n\n    return path;\n  };\n  /**\r\n   * Updates and positions an axis break element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Break element\r\n   */\n\n\n  AxisRendererRadial.prototype.updateBreakElement = function (axisBreak) {\n    // @todo: someday we might need axis break when gridType is polygons\n    var startLine = axisBreak.startLine;\n    var endLine = axisBreak.endLine;\n    var fillShape = axisBreak.fillShape;\n    var startPoint = axisBreak.startPoint;\n    var endPoint = axisBreak.endPoint;\n    startLine.radius = Math.abs(startPoint.y);\n    endLine.radius = Math.abs(endPoint.y);\n    fillShape.radius = Math.abs(endPoint.y);\n    fillShape.innerRadius = Math.abs(startPoint.y);\n  };\n  /**\r\n   * Creates visual elements for and axis break.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Axis break\r\n   */\n\n\n  AxisRendererRadial.prototype.createBreakSprites = function (axisBreak) {\n    axisBreak.startLine = new WavedCircle();\n    axisBreak.endLine = new WavedCircle();\n    axisBreak.fillShape = new WavedCircle();\n  };\n  /**\r\n   * Updates some of the Axis tooltip's visual properties, related to\r\n   * rendering of the Axis.\r\n   *\r\n   * @todo Description (review)\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererRadial.prototype.updateTooltip = function () {\n    var axis = this.axis;\n\n    if (axis) {\n      var bigNum = 4000;\n      var bbx = -4000;\n      var bby = -4000;\n      var bbw = bigNum * 2;\n      var bbh = bigNum * 2;\n      var axisAngle = this.axisAngle;\n\n      if (axisAngle < 0) {\n        axisAngle += 360;\n      }\n\n      var tooltipOrientation = \"vertical\";\n\n      if (axisAngle > 45 && axisAngle < 135 || axisAngle > 225 && axisAngle < 315) {\n        tooltipOrientation = \"horizontal\";\n      }\n\n      this.axis.updateTooltip(tooltipOrientation, {\n        x: bbx,\n        y: bby,\n        width: bbw,\n        height: bbh\n      });\n    }\n  };\n  /**\r\n   * Updates and positions a tick element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param tick      Tick element\r\n   * @param position  Position\r\n   */\n\n\n  AxisRendererRadial.prototype.updateTickElement = function (tick, position) {\n    var point = this.positionToPoint(position);\n\n    if (tick.element) {\n      var angle = $math.normalizeAngle(this.axisAngle + 90);\n\n      if (angle / 90 != Math.round(angle / 90)) {\n        tick.pixelPerfect = false;\n      } else {\n        tick.pixelPerfect = true;\n      }\n\n      var tickLength = -tick.length;\n\n      if (tick.inside) {\n        tickLength *= -1;\n      }\n\n      tick.path = $path.moveTo({\n        x: 0,\n        y: 0\n      }) + $path.lineTo({\n        x: tickLength * $math.cos(angle),\n        y: tickLength * $math.sin(angle)\n      });\n    }\n\n    this.positionItem(tick, point);\n    this.toggleVisibility(tick, position, 0, 1);\n  };\n  /**\r\n   * Converts a position on the axis to a coordinate in pixels.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (0-1)\r\n   * @return Coordinate (px)\r\n   */\n\n\n  AxisRendererRadial.prototype.positionToCoordinate = function (position) {\n    var coordinate;\n    var axis = this.axis;\n    var axisFullLength = axis.axisFullLength;\n    var innerRadius = this.pixelInnerRadius;\n\n    if (axis.renderer.inversed) {\n      coordinate = (axis.end - position) * axisFullLength + innerRadius;\n    } else {\n      coordinate = (position - axis.start) * axisFullLength + innerRadius;\n    }\n\n    return $math.round(coordinate, 1);\n  };\n  /**\r\n   * Converts a point at specific coordinates to a relative position (0-1)\r\n   * on the axis.\r\n   *\r\n   * @param point  Point\r\n   * @return Position (0-1)\r\n   */\n\n\n  AxisRendererRadial.prototype.pointToPosition = function (point) {\n    var coordinate = $math.getDistance(point) - this.pixelInnerRadius;\n    return this.coordinateToPosition(coordinate);\n  };\n\n  return AxisRendererRadial;\n}(AxisRendererY);\n\nexport { AxisRendererRadial };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"AxisRendererRadial\"] = AxisRendererRadial;","map":null,"metadata":{},"sourceType":"module"}