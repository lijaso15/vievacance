{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Disposer, MultiDisposer } from \"./Disposer\";\nimport { EventDispatcher } from \"./EventDispatcher\";\nimport * as $array from \"./Array\";\nimport * as $iter from \"./Iterator\";\n/**\r\n * @todo Description\r\n */\n\nvar IndexedIterable =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param array  List items\r\n   * @param start  Start index\r\n   * @param end    End index\r\n   */\n  function IndexedIterable(array, start, end) {\n    this._array = array;\n    this._start = start;\n    this._end = end;\n  }\n  /**\r\n   * Returns a list item iterator.\r\n   *\r\n   * @return Iterator\r\n   */\n\n\n  IndexedIterable.prototype.iterator = function () {\n    var _this = this;\n\n    return function (push) {\n      if (_this._start !== _this._end) {\n        if (_this._start < _this._end) {\n          for (var i = _this._start; i < _this._end; ++i) {\n            if (!push(_this._array[i])) {\n              break;\n            }\n          }\n        } else {\n          for (var i = _this._start - 1; i >= _this._end; --i) {\n            if (!push(_this._array[i])) {\n              break;\n            }\n          }\n        }\n      }\n    };\n  };\n  /**\r\n   * Returns an interable list sorted backwards than current list.\r\n   *\r\n   * @return List\r\n   */\n\n\n  IndexedIterable.prototype.backwards = function () {\n    return new IndexedIterable(this._array, this._end, this._start);\n  };\n  /**\r\n   * Returns a new list consisting only of specific range of items between\r\n   * `start` and `end` indexes.\r\n   *\r\n   * @param start  Start index\r\n   * @param end    End index\r\n   * @return List\r\n   */\n\n\n  IndexedIterable.prototype.range = function (start, end) {\n    if (start <= end) {\n      if (this._start === this._end) {\n        return this;\n      } else if (this._start < this._end) {\n        var diff = end - start;\n        start = Math.max(this._start + start, this._start);\n        end = Math.min(start + diff, this._end);\n        return new IndexedIterable(this._array, start, end);\n      } else {\n        var diff = end - start;\n        start = Math.max(this._start - start, this._end);\n        end = Math.max(start - diff, this._end);\n        return new IndexedIterable(this._array, start, end);\n      }\n    } else {\n      throw new Error(\"Start index must be lower than end index\");\n    }\n  };\n\n  return IndexedIterable;\n}();\n\nexport { IndexedIterable };\n/**\r\n * ListGrouper organizes [[List]] items into groups.\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nvar ListGrouper =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ListGrouper, _super);\n  /**\r\n   * Constructor.\r\n   */\n\n\n  function ListGrouper(list, getKey, sort) {\n    var _this = _super.call(this, [list.events.on(\"inserted\", function (x) {\n      var value = x.newValue;\n\n      var key = _this._getKey(value);\n\n      var index = 0;\n      $iter.eachContinue(list.iterator(), function (x) {\n        if (x === value) {\n          return false;\n        } else if (_this._getKey(x) === key) {\n          ++index;\n        }\n\n        return true;\n      });\n\n      _this._insert(value, key, index);\n    }, undefined, false), list.events.on(\"removed\", function (x) {\n      _this._remove(x.oldValue);\n    }, undefined, false)]) || this;\n    /**\r\n     * Grouping keys.\r\n     */\n\n\n    _this._keys = [];\n    /**\r\n     * List item groups.\r\n     */\n\n    _this._groups = {};\n    _this._getKey = getKey;\n    _this._sort = sort;\n    $iter.each(list.iterator(), function (x) {\n      _this._insert(x, getKey(x));\n    });\n    return _this;\n  }\n  /**\r\n   * Inserts an item (`x`) to a specific group (`key`) and specific `index`.\r\n   *\r\n   * @param x      Item\r\n   * @param key    Group name\r\n   * @param index  Index\r\n   */\n\n\n  ListGrouper.prototype._insert = function (x, key, index) {\n    if (this._groups[key] == null) {\n      this._groups[key] = []; // TODO code duplication with SortedList\n\n      var _a = $array.getSortedIndex(this._keys, this._sort, key),\n          found = _a.found,\n          index_1 = _a.index;\n\n      if (found) {\n        throw new Error(\"Key already exists: \" + key);\n      } else {\n        $array.insertIndex(this._keys, index_1, key);\n      }\n    }\n\n    if (index == null) {\n      this._groups[key].push(x);\n    } else {\n      $array.insertIndex(this._groups[key], index, x);\n    }\n  };\n  /**\r\n   * Removes an item from the list.\r\n   *\r\n   * @param x Item to remove\r\n   */\n\n\n  ListGrouper.prototype._remove = function (x) {\n    var key = this._getKey(x);\n\n    var values = this._groups[key];\n\n    if (values != null) {\n      $array.remove(values, x);\n\n      if (values.length === 0) {\n        delete this._groups[key];\n\n        var _a = $array.getSortedIndex(this._keys, this._sort, key),\n            found = _a.found,\n            index = _a.index;\n\n        if (found) {\n          $array.removeIndex(this._keys, index);\n        } else {\n          throw new Error(\"Key doesn't exist: \" + key);\n        }\n      }\n    }\n  };\n  /**\r\n   * Returns an iterator for the list.\r\n   *\r\n   * The iterator will iterate through all items in all groups.\r\n   *\r\n   * @return Iterator\r\n   */\n\n\n  ListGrouper.prototype.iterator = function () {\n    var _this = this;\n\n    return $iter.flatten($iter.map($iter.fromArray(this._keys), function (key) {\n      return $iter.fromArray(_this._groups[key]);\n    }));\n  };\n\n  return ListGrouper;\n}(MultiDisposer);\n\nexport { ListGrouper };\n/**\r\n * A disposable list, which when disposed itself will call `dispose()` method\r\n * on all its items.\r\n */\n\nvar ListDisposer =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ListDisposer, _super);\n\n  function ListDisposer(list) {\n    var _this = this;\n\n    var disposer = list.events.on(\"removed\", function (x) {\n      x.oldValue.dispose();\n    }, undefined, false);\n    _this = _super.call(this, function () {\n      disposer.dispose(); // TODO clear the list ?\n\n      $iter.each(list.iterator(), function (x) {\n        x.dispose();\n      });\n    }) || this;\n    return _this;\n  }\n\n  return ListDisposer;\n}(Disposer);\n\nexport { ListDisposer };\n/**\r\n * Checks if specific index fits into length.\r\n *\r\n * @param index  Index\r\n * @param len    Length\r\n */\n\nfunction checkBounds(index, len) {\n  if (!(index >= 0 && index < len)) {\n    throw new Error(\"Index out of bounds: \" + index);\n  }\n}\n/**\r\n * A List class is used to hold a number of indexed items of the same type.\r\n */\n\n\nvar List =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   *\r\n   * @param initial  Inital list of values to add to list\r\n   */\n  function List(initial) {\n    if (initial === void 0) {\n      initial = [];\n    }\n    /**\r\n     * Event dispatcher.\r\n     */\n\n\n    this.events = new EventDispatcher();\n    this._values = initial;\n  }\n\n  Object.defineProperty(List.prototype, \"values\", {\n    /**\r\n     * An array of values in the list.\r\n     *\r\n     * Do not use this property to add values. Rather use dedicated methods, like\r\n     * `push()`, `removeIndex()`, etc.\r\n     *\r\n     * @readonly\r\n     * @return List values\r\n     */\n    get: function () {\n      return this._values;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks if list contains specific item reference.\r\n   *\r\n   * @param item  Item to search for\r\n   * @return `true` if found, `false` if not found\r\n   */\n\n  List.prototype.contains = function (value) {\n    return this._values.indexOf(value) !== -1;\n  };\n  /**\r\n   * Removes specific item from the list.\r\n   *\r\n   * @param item An item to remove\r\n   */\n\n\n  List.prototype.removeValue = function (value) {\n    var i = 0;\n    var length = this._values.length;\n\n    while (i < length) {\n      // TODO handle NaN\n      if (this._values[i] === value) {\n        this.removeIndex(i);\n        --length;\n      } else {\n        ++i;\n      }\n    }\n  };\n  /**\r\n   * Searches the list for specific item and returns its index.\r\n   *\r\n   * @param item  An item to search for\r\n   * @return Index or -1 if not found\r\n   */\n\n\n  List.prototype.indexOf = function (value) {\n    return $array.indexOf(this._values, value);\n  };\n\n  Object.defineProperty(List.prototype, \"length\", {\n    /**\r\n     * Number of items in list.\r\n     *\r\n     * @readonly\r\n     * @return Number of items\r\n     */\n    get: function () {\n      return this._values.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks if there's a value at specific index.\r\n   *\r\n   * @param index  Index\r\n   * @return Value exists?\r\n   */\n\n  List.prototype.hasIndex = function (index) {\n    return index >= 0 && index < this._values.length;\n  };\n  /**\r\n   * Returns an item at specified index.\r\n   *\r\n   * @param index  Index\r\n   * @return List item\r\n   */\n\n\n  List.prototype.getIndex = function (index) {\n    return this._values[index];\n  };\n  /**\r\n   * Sets value at specific index.\r\n   *\r\n   * If there's already a value at the index, it is overwritten.\r\n   *\r\n   * @param index  Index\r\n   * @param value  New value\r\n   * @return New value\r\n   */\n\n\n  List.prototype.setIndex = function (index, value) {\n    checkBounds(index, this._values.length);\n    var oldValue = this._values[index]; // Do nothing if the old value and the new value are the same\n\n    if (oldValue !== value) {\n      this._values[index] = value;\n\n      if (this.events.isEnabled(\"setIndex\")) {\n        this.events.dispatchImmediately(\"setIndex\", {\n          type: \"setIndex\",\n          target: this,\n          index: index,\n          oldValue: oldValue,\n          newValue: value\n        });\n      }\n\n      if (this.events.isEnabled(\"removed\")) {\n        this.events.dispatchImmediately(\"removed\", {\n          type: \"removed\",\n          target: this,\n          oldValue: oldValue\n        });\n      }\n\n      if (this.events.isEnabled(\"inserted\")) {\n        this.events.dispatchImmediately(\"inserted\", {\n          type: \"inserted\",\n          target: this,\n          newValue: value\n        });\n      }\n    }\n\n    return oldValue;\n  };\n  /**\r\n   * Adds an item to the list at a specific index, which pushes all the other\r\n   * items further down the list.\r\n   *\r\n   * @param index Index\r\n   * @param item  An item to add\r\n   */\n\n\n  List.prototype.insertIndex = function (index, value) {\n    checkBounds(index, this._values.length + 1);\n    $array.insertIndex(this._values, index, value);\n\n    if (this.events.isEnabled(\"insertIndex\")) {\n      this.events.dispatchImmediately(\"insertIndex\", {\n        type: \"insertIndex\",\n        target: this,\n        index: index,\n        newValue: value\n      });\n    }\n\n    if (this.events.isEnabled(\"inserted\")) {\n      this.events.dispatchImmediately(\"inserted\", {\n        type: \"inserted\",\n        target: this,\n        newValue: value\n      });\n    }\n  };\n  /**\r\n   * [_sortQuicksort description]\r\n   *\r\n   * @todo Description\r\n   * @param low    [description]\r\n   * @param high   [description]\r\n   * @param order  [description]\r\n   */\n\n\n  List.prototype._sortQuicksort = function (low, high, order) {\n    if (low < high) {\n      var p = this._sortPartition(low, high, order);\n\n      this._sortQuicksort(low, p, order);\n\n      this._sortQuicksort(p + 1, high, order);\n    }\n  };\n  /**\r\n   * [_sortPartition description]\r\n   *\r\n   * @todo Description\r\n   * @param low    [description]\r\n   * @param high   [description]\r\n   * @param order  [description]\r\n   * @return [description]\r\n   */\n\n\n  List.prototype._sortPartition = function (low, high, order) {\n    var values = this._values;\n    var pivot = values[low];\n    var i = low - 1;\n    var j = high + 1;\n\n    for (;;) {\n      do {\n        ++i;\n      } while (order(values[i], pivot) < 0);\n\n      do {\n        --j;\n      } while (order(values[j], pivot) > 0);\n\n      if (i >= j) {\n        return j;\n      } else {\n        this.swap(i, j);\n      }\n    }\n  };\n  /**\r\n   * Reorders list items according to specific ordering function.\r\n   *\r\n   * @param order  Ordering function\r\n   */\n\n\n  List.prototype.sort = function (order) {\n    // https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    // @todo faster implementation of this\n    // @todo test this\n    this._sortQuicksort(0, this._values.length - 1, order);\n  };\n  /**\r\n   * Swaps indexes of two items in the list.\r\n   *\r\n   * @param a  Item 1\r\n   * @param b  Item 2\r\n   */\n\n\n  List.prototype.swap = function (a, b) {\n    var len = this._values.length;\n    checkBounds(a, len);\n    checkBounds(b, len);\n\n    if (a !== b) {\n      var value_a = this._values[a];\n      var value_b = this._values[b];\n      this._values[a] = value_b;\n\n      if (this.events.isEnabled(\"setIndex\")) {\n        this.events.dispatchImmediately(\"setIndex\", {\n          type: \"setIndex\",\n          target: this,\n          index: a,\n          oldValue: value_a,\n          newValue: value_b\n        });\n      }\n\n      this._values[b] = value_a;\n\n      if (this.events.isEnabled(\"setIndex\")) {\n        this.events.dispatchImmediately(\"setIndex\", {\n          type: \"setIndex\",\n          target: this,\n          index: b,\n          oldValue: value_b,\n          newValue: value_a\n        });\n      }\n    }\n  };\n  /**\r\n   * Removes a value at specific index.\r\n   *\r\n   * @param index  Index of value to remove\r\n   * @return Removed value\r\n   */\n\n\n  List.prototype.removeIndex = function (index) {\n    checkBounds(index, this._values.length);\n    var oldValue = this._values[index];\n    $array.removeIndex(this._values, index);\n\n    if (this.events.isEnabled(\"removeIndex\")) {\n      this.events.dispatchImmediately(\"removeIndex\", {\n        type: \"removeIndex\",\n        target: this,\n        index: index,\n        oldValue: oldValue\n      });\n    }\n\n    if (this.events.isEnabled(\"removed\")) {\n      this.events.dispatchImmediately(\"removed\", {\n        type: \"removed\",\n        target: this,\n        oldValue: oldValue\n      });\n    }\n\n    return oldValue;\n  };\n  /**\r\n   * Moves an item to a specific index within the list.\r\n   *\r\n   * If the index is not specified it will move the item to the end of the\r\n   * list.\r\n   *\r\n   * @param value  Item to move\r\n   * @param index  Index to place item at\r\n   */\n\n\n  List.prototype.moveValue = function (value, toIndex) {\n    // TODO don't do anything if the desired index is the same as the current index\n    var index = this.indexOf(value); // TODO remove all old values rather than only the first ?\n\n    if (index !== -1) {\n      var oldValue = this._values[index];\n      $array.removeIndex(this._values, index);\n\n      if (this.events.isEnabled(\"removeIndex\")) {\n        this.events.dispatchImmediately(\"removeIndex\", {\n          type: \"removeIndex\",\n          target: this,\n          index: index,\n          oldValue: oldValue\n        });\n      }\n    }\n\n    if (toIndex == null) {\n      toIndex = this._values.length;\n\n      this._values.push(value);\n    } else {\n      $array.insertIndex(this._values, toIndex, value);\n    }\n\n    if (this.events.isEnabled(\"insertIndex\")) {\n      this.events.dispatchImmediately(\"insertIndex\", {\n        type: \"insertIndex\",\n        target: this,\n        index: toIndex,\n        newValue: value\n      });\n    }\n\n    if (index === -1) {\n      if (this.events.isEnabled(\"inserted\")) {\n        this.events.dispatchImmediately(\"inserted\", {\n          type: \"inserted\",\n          target: this,\n          newValue: value\n        });\n      }\n    }\n  };\n  /**\r\n   * Adds an item to the end of the list.\r\n   *\r\n   * @param item  An item to add\r\n   */\n\n\n  List.prototype.push = function (value) {\n    var index = this._values.push(value) - 1;\n\n    if (this.events.isEnabled(\"insertIndex\")) {\n      this.events.dispatchImmediately(\"insertIndex\", {\n        type: \"insertIndex\",\n        target: this,\n        index: index,\n        newValue: value\n      });\n    }\n\n    if (this.events.isEnabled(\"inserted\")) {\n      this.events.dispatchImmediately(\"inserted\", {\n        type: \"inserted\",\n        target: this,\n        newValue: value\n      });\n    }\n\n    return value;\n  };\n  /**\r\n   * Adds an item as a first item in the list.\r\n   *\r\n   * @param item  An item to add\r\n   */\n\n\n  List.prototype.unshift = function (value) {\n    this.insertIndex(0, value);\n  };\n  /**\r\n   * Adds multiple items to the list.\r\n   *\r\n   * @param items  An Array of items to add\r\n   */\n\n\n  List.prototype.pushAll = function (values) {\n    var _this = this;\n\n    $array.each(values, function (value) {\n      _this.push(value);\n    });\n  };\n  /**\r\n   * Copies and adds items from abother list.\r\n   *\r\n   * @param source  A list top copy items from\r\n   */\n\n\n  List.prototype.copyFrom = function (source) {\n    this.pushAll(source._values);\n  };\n  /**\r\n   * Returns the last item from the list, and removes it.\r\n   *\r\n   * @return Item\r\n   */\n\n\n  List.prototype.pop = function () {\n    var index = this._values.length - 1;\n    return index < 0 ? undefined : this.removeIndex(this._values.length - 1);\n  };\n  /**\r\n   * Returns the first item from the list, and removes it.\r\n   *\r\n   * @return Item\r\n   */\n\n\n  List.prototype.shift = function () {\n    return this._values.length ? this.removeIndex(0) : undefined;\n  };\n  /**\r\n   * Sets multiple items to the list.\r\n   *\r\n   * All current items are removed.\r\n   *\r\n   * @param newArray  New items\r\n   */\n\n\n  List.prototype.setAll = function (newArray) {\n    var _this = this; // @tod if a value exists in both the new and old arrays, don't send remove/insert events\n\n\n    var oldArray = $array.copy(this._values);\n    this._values.length = 0;\n    $array.each(newArray, function (value) {\n      _this._values.push(value);\n    });\n\n    if (this.events.isEnabled(\"setAll\")) {\n      this.events.dispatchImmediately(\"setAll\", {\n        type: \"setAll\",\n        target: this,\n        oldArray: oldArray,\n        newArray: this._values // TODO make a copy ?\n\n      });\n    }\n\n    if (this.events.isEnabled(\"removed\")) {\n      $array.each(oldArray, function (x) {\n        _this.events.dispatchImmediately(\"removed\", {\n          type: \"removed\",\n          target: _this,\n          oldValue: x\n        });\n      });\n    }\n\n    if (this.events.isEnabled(\"inserted\")) {\n      $array.each(this._values, function (x) {\n        _this.events.dispatchImmediately(\"inserted\", {\n          type: \"inserted\",\n          target: _this,\n          newValue: x\n        });\n      });\n    }\n  };\n  /**\r\n   * Removes all items from the list.\r\n   */\n\n\n  List.prototype.clear = function () {\n    this.setAll([]);\n  };\n  /**\r\n   * Returns a list iterator.\r\n   *\r\n   * @return Iterator\r\n   */\n\n\n  List.prototype.iterator = function () {\n    return $iter.fromArray(this._values);\n  };\n  /**\r\n   * Returns an ES6 iterator for the list.\r\n   */\n\n\n  List.prototype[Symbol.iterator] = function () {\n    var length, i;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          length = this._values.length;\n          i = 0;\n          _a.label = 1;\n\n        case 1:\n          if (!(i < length)) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          , this._values[i]];\n\n        case 2:\n          _a.sent();\n\n          _a.label = 3;\n\n        case 3:\n          ++i;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n  /**\r\n   * Calls `f` for each element in the list.\r\n   *\r\n   * `f` should have at least one parameter defined which will get a current\r\n   * item, with optional second argument - index.\r\n   */\n\n\n  List.prototype.each = function (f) {\n    $array.each(this._values, f);\n  };\n  /**\r\n   * Returns a specific range of list items, which can be iterated.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Code duplication with IndexedIterable\r\n   * @param start  Start index\r\n   * @param end    End index\r\n   * @return Range\r\n   */\n\n\n  List.prototype.range = function (start, end) {\n    if (start <= end) {\n      var diff = end - start;\n      start = Math.max(start, 0);\n      end = Math.min(start + diff, this._values.length);\n      return new IndexedIterable(this._values, start, end);\n    } else {\n      throw new Error(\"Start index must be lower than end index\");\n    }\n  };\n  /**\r\n   * Returns an iterator that has list items sorted backwards.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return List\r\n   */\n\n\n  List.prototype.backwards = function () {\n    return new IndexedIterable(this._values, this._values.length, 0);\n  };\n\n  return List;\n}();\n\nexport { List };\n/**\r\n * A version of a [[List]] that has a \"template\".\r\n *\r\n * A template is an instance of an object, that can be used to create new\r\n * elements in the list without actually needing to create instances for those.\r\n *\r\n * When new element is created in the list, e.g. by calling its `create()`\r\n * method, an exact copy of the element is created (including properties and\r\n * other attributes), inserted into the list and returned.\r\n */\n\nvar ListTemplate =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ListTemplate, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param t Template object\r\n   */\n\n\n  function ListTemplate(t) {\n    var _this = _super.call(this) || this;\n\n    _this.template = t;\n    return _this;\n  }\n\n  Object.defineProperty(ListTemplate.prototype, \"template\", {\n    /**\r\n     * @return Template object\r\n     */\n    get: function () {\n      return this._template;\n    },\n\n    /**\r\n     * A \"template\" object to copy all properties from when creating new list\r\n     * items.\r\n     *\r\n     * @param v  Template object\r\n     */\n    set: function (v) {\n      v.isTemplate = true;\n      this._template = v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all elements from other list.\r\n   *\r\n   * @param source  Source list\r\n   */\n\n  ListTemplate.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    $iter.each(source.iterator(), function (value) {\n      _this.push(value.clone());\n    });\n  };\n\n  ListTemplate.prototype.create = function (make) {\n    var clone = make != null ? new make() : this.template.clone();\n    this.push(clone);\n    return clone;\n  };\n  /**\r\n   * Creates an exact clone of the list, including its items and template.\r\n   *\r\n   * @return New list\r\n   */\n\n\n  ListTemplate.prototype.clone = function () {\n    var out = new ListTemplate(this.template);\n    var values = this.values;\n    var length = values.length;\n\n    for (var i = 0; i < length; ++i) {\n      out.push(values[i].clone());\n    }\n\n    return out;\n  };\n\n  return ListTemplate;\n}(List);\n\nexport { ListTemplate };","map":null,"metadata":{},"sourceType":"module"}