{"ast":null,"code":"/**\r\n * ChordNode module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { FlowDiagramNode } from \"./FlowDiagramNode\";\nimport { AxisLabelCircular } from \"../axes/AxisLabelCircular\";\nimport { registry } from \"../../core/Registry\";\nimport { Slice } from \"../../core/elements/Slice\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport { Bullet } from \"../elements/Bullet\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a node in a Chord Diagram.\r\n *\r\n * A Chord node is a block with a value, which represents its size on the\r\n * diagram.\r\n *\r\n * Nodes are connected via [[ChordLink]] elements.\r\n *\r\n * @see {@link IChordNodeEvents} for a list of available events\r\n * @see {@link IChordNodeAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar ChordNode =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ChordNode, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ChordNode() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"ChordNode\";\n\n    var label = _this.createChild(AxisLabelCircular);\n\n    label.location = 0.5;\n    label.radius = 5;\n    label.text = \"{name}\";\n    label.zIndex = 1;\n    label.shouldClone = false;\n    _this.label = label;\n    _this.layout = \"none\";\n\n    _this.events.on(\"positionchanged\", _this.updateRotation, _this, false);\n\n    _this.isMeasured = false;\n    _this.slice = _this.createChild(Slice);\n    _this.slice.isMeasured = false;\n    var hiddenState = _this.hiddenState;\n    hiddenState.properties.fill = new InterfaceColorSet().getFor(\"disabledBackground\");\n    hiddenState.properties.opacity = 0.5;\n    hiddenState.properties.visible = true;\n    _this.setStateOnChildren = false;\n    _this.slice.hiddenState.properties.visible = true;\n\n    _this.adapter.add(\"tooltipX\", function (tooltipX, target) {\n      return target.slice.ix * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\n    });\n\n    _this.adapter.add(\"tooltipY\", function (tooltipY, target) {\n      return target.slice.iy * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\n    });\n\n    return _this;\n  }\n  /**\r\n   * Invalidates all links, attached to this node.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ChordNode.prototype.invalidateLinks = function () {\n    var _this = this;\n\n    _super.prototype.invalidateLinks.call(this);\n\n    var label = this.label;\n    var slice = this.slice;\n    var chart = this.chart;\n\n    if (chart && slice) {\n      var sum = this.total;\n      var arc_1 = slice.arc;\n      var sliceStartAngle_1 = slice.startAngle;\n      this.children.each(function (child) {\n        if (child instanceof Bullet) {\n          var locationX = child.locationX;\n\n          if (!$type.isNumber(locationX)) {\n            locationX = 0.5;\n          }\n\n          var locationY = child.locationY;\n\n          if (!$type.isNumber(locationY)) {\n            locationY = 1;\n          }\n\n          var childAngle = sliceStartAngle_1 + arc_1 * locationX;\n          var childRadius = locationY * slice.radius;\n          child.x = childRadius * $math.cos(childAngle);\n          child.y = childRadius * $math.sin(childAngle);\n        }\n      });\n      var labelAngle = sliceStartAngle_1 + arc_1 * label.location;\n      var startAngle = sliceStartAngle_1 + (1 - sum / this.adjustedTotal) * arc_1 * 0.5; // if value of a node is > then sum of the links, add to center link\n\n      if ($type.isNaN(startAngle)) {\n        startAngle = sliceStartAngle_1;\n      }\n\n      label.fixPosition(labelAngle, slice.radius);\n      this.nextAngle = startAngle;\n\n      if (this._outgoingSorted) {\n        $iter.each(this._outgoingSorted, function (dataItem) {\n          var link = dataItem.link;\n          link.parent = _this.chart.linksContainer;\n          var value = dataItem.getWorkingValue(\"value\");\n\n          if ($type.isNumber(value)) {\n            if (chart.nonRibbon) {\n              var percentWidth = link.percentWidth;\n\n              if (!$type.isNumber(percentWidth)) {\n                percentWidth = 5;\n              }\n\n              percentWidth = percentWidth / 100;\n              link.startAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;\n              link.arc = arc_1 * percentWidth;\n            } else {\n              link.arc = value * chart.valueAngle;\n              link.startAngle = _this.nextAngle;\n              _this.nextAngle += link.arc;\n            }\n\n            if (!dataItem.toNode) {\n              link.endAngle = link.startAngle;\n            }\n\n            link.radius = slice.pixelInnerRadius;\n          } //link.validate();\n\n        });\n      }\n\n      if (this._incomingSorted) {\n        $iter.each(this._incomingSorted, function (dataItem) {\n          var link = dataItem.link;\n          link.radius = slice.pixelInnerRadius;\n\n          if (chart.nonRibbon) {\n            var percentWidth = link.percentWidth;\n\n            if (!$type.isNumber(percentWidth)) {\n              percentWidth = 5;\n            }\n\n            percentWidth = percentWidth / 100;\n            link.endAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;\n            link.arc = arc_1 * percentWidth;\n          } else {\n            link.endAngle = _this.nextAngle;\n            var value = dataItem.getWorkingValue(\"value\");\n\n            if ($type.isNumber(value)) {\n              link.arc = value * chart.valueAngle; // yes, this is needed\n\n              _this.nextAngle += link.arc;\n            }\n          }\n\n          if (!dataItem.fromNode) {\n            link.startAngle = link.endAngle;\n          } //link.validate();\n\n        });\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   * updates slice start angle so that when we drag a node it would face the center\r\n   */\n\n\n  ChordNode.prototype.updateRotation = function () {\n    var slice = this.slice;\n    var mAngle = this.trueStartAngle + slice.arc / 2;\n    var radius = slice.radius;\n    var tx = radius * $math.cos(mAngle);\n    var ty = radius * $math.sin(mAngle);\n    var angle = $math.getAngle({\n      x: tx + this.pixelX,\n      y: ty + this.pixelY\n    });\n    slice.startAngle = this.trueStartAngle + (angle - mAngle);\n    this.dx = -this.pixelX;\n    this.dy = -this.pixelY;\n  };\n  /**\r\n   * Copies properties and labels from another [[ChordNode]].\r\n   *\r\n   * @param source  Source node\r\n   */\n\n\n  ChordNode.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.label.copyFrom(source.label);\n    this.slice.copyFrom(source.slice);\n  };\n\n  return ChordNode;\n}(FlowDiagramNode);\n\nexport { ChordNode };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"ChordNode\"] = ChordNode;","map":null,"metadata":{},"sourceType":"module"}