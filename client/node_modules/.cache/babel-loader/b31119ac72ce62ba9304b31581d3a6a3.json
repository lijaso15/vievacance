{"ast":null,"code":"/**\r\n * Duration formatting functionality.\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { Language } from \"../utils/Language\";\nimport { BaseObject } from \"../Base\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $object from \"../utils/Object\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $math from \"../utils/Math\";\n/**\r\n * DurationFormatter class. Formats numbers as durations.\r\n *\r\n * `1000` as `16:40`\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} Tutorial on duration formatting\r\n */\n\nvar DurationFormatter =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DurationFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function DurationFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A base value for negative numbers. Will treat all numbers below this value\r\n     * as negative numbers.\r\n     */\n\n\n    _this._negativeBase = 0;\n    /**\r\n     * A base unit to consider values are in.\r\n     *\r\n     * @default \"s\"\r\n     */\n\n    _this._baseUnit = \"second\";\n    /**\r\n     * Output format to produce. If the format calls for applying color to the\r\n     * formatted value, this setting will determine what markup to use: SVG or\r\n     * HTML.\r\n     *\r\n     * Available options: svg, html.\r\n     *\r\n     * @default \"svg\"\r\n     */\n\n    _this._outputFormat = \"svg\";\n    /**\r\n     * How many milliseconds each unit represents.\r\n     */\n\n    _this._unitValues = {\n      \"millisecond\": 1,\n      \"second\": 1000,\n      \"minute\": 60000,\n      \"hour\": 3600000,\n      \"day\": 86400000,\n      \"week\": 604800000,\n      \"month\": 2592000000,\n      \"year\": 31536000000\n    };\n    /**\r\n     * Collection of aliases for units.\r\n     */\n\n    _this._unitAliases = {\n      \"Y\": \"y\",\n      \"D\": \"d\",\n      \"H\": \"h\",\n      \"K\": \"h\",\n      \"k\": \"h\",\n      \"n\": \"S\"\n    };\n    _this.className = \"DurationFormatter\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Formats the number according as duration.\r\n   *\r\n   * For example `1000` (base unit seconds) would be converted to `16:40` as in\r\n   * 16 minutes and 40 seconds.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} Tutorial on duration formatting\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @param base    Override base unit\r\n   * @return Formatted number\r\n   */\n\n\n  DurationFormatter.prototype.format = function (value, format, base) {\n    // no language?\n    if (!this.language) {\n      if (this.sprite) {\n        this.language = this.sprite.language;\n      } else {\n        this.language = new Language();\n      }\n    } // no base unit?\n\n\n    var baseUnit = base || this._baseUnit; // no format passed in or empty\n\n    if (typeof format === \"undefined\" || format === \"\") {\n      if ($type.hasValue(this.durationFormat)) {\n        format = this.durationFormat;\n      } else {\n        format = this.getFormat($type.toNumber(value), null, baseUnit);\n      }\n    } // Clean format\n\n\n    format = $utils.cleanFormat(format); // get format info (it will also deal with parser caching)\n\n    var info = this.parseFormat(format, baseUnit); // cast to number just in case\n    // TODO: maybe use better casting\n\n    var source = Number(value); // format and replace the number\n\n    var details;\n\n    if (source > this._negativeBase) {\n      details = info.positive;\n    } else if (source < this._negativeBase) {\n      details = info.negative;\n    } else {\n      details = info.zero;\n    } // Format\n\n\n    var formatted = this.applyFormat(source, details); // Apply color?\n\n    if (details.color !== \"\") {\n      if (this._outputFormat === \"svg\") {\n        formatted = \"<tspan fill='\" + details.color + \"'>\" + formatted + \"</tspan>\";\n      } else if (this._outputFormat === \"html\") {\n        formatted = \"<span style='color: \" + details.color + \";'>\" + formatted + \"</span>\";\n      }\n    }\n\n    return formatted;\n  };\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format  Format string, i.e. \"#,###.00\"\r\n   * @param base    Override base unit\r\n   * @return Parsed information\r\n   */\n\n\n  DurationFormatter.prototype.parseFormat = function (format, base) {\n    var _this = this; // Check cache\n\n\n    var cached = this.getCache(format);\n\n    if ($type.hasValue(cached)) {\n      return cached;\n    } // no base unit?\n\n\n    var baseUnit = base || this._baseUnit; // Initialize duration parsing info\n\n    var info = {\n      \"positive\": {\n        \"color\": \"\",\n        \"template\": \"\",\n        \"parts\": [],\n        \"source\": \"\",\n        \"baseUnit\": baseUnit,\n        \"parsed\": false,\n        \"absolute\": false\n      },\n      \"negative\": {\n        \"color\": \"\",\n        \"template\": \"\",\n        \"parts\": [],\n        \"source\": \"\",\n        \"baseUnit\": baseUnit,\n        \"parsed\": false,\n        \"absolute\": false\n      },\n      \"zero\": {\n        \"color\": \"\",\n        \"template\": \"\",\n        \"parts\": [],\n        \"source\": \"\",\n        \"baseUnit\": baseUnit,\n        \"parsed\": false,\n        \"absolute\": false\n      }\n    }; // Escape double vertical bars (that mean display one vertical bar)\n\n    format = format.replace(\"||\", $strings.PLACEHOLDER2); // Split it up and deal with different formats\n\n    var parts = format.split(\"|\");\n    info.positive.source = parts[0];\n\n    if (typeof parts[2] === \"undefined\") {\n      info.zero = info.positive;\n    } else {\n      info.zero.source = parts[2];\n    }\n\n    if (typeof parts[1] === \"undefined\") {\n      info.negative = info.positive;\n    } else {\n      info.negative.source = parts[1];\n    } // Parse each\n\n\n    $object.each(info, function (part, item) {\n      // Already parsed\n      if (item.parsed) {\n        return;\n      } // Check cached\n\n\n      if (typeof _this.getCache(item.source) !== \"undefined\") {\n        info[part] = _this.getCache(item.source);\n        return;\n      } // Begin parsing\n\n\n      var partFormat = item.source; // Check for [] directives\n\n      var dirs = [];\n      dirs = item.source.match(/^\\[([^\\]]*)\\]/);\n\n      if (dirs && dirs.length && dirs[0] !== \"\") {\n        partFormat = item.source.substr(dirs[0].length);\n        item.color = dirs[1];\n      } // Let TextFormatter split into chunks\n\n\n      var chunks = getTextFormatter().chunk(partFormat, true);\n\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i]; // replace back double vertical bar\n\n        chunk.text = chunk.text.replace($strings.PLACEHOLDER2, \"|\");\n\n        if (chunk.type === \"value\") {\n          // Just \"Duration\"?\n          // if (chunk.text.toLowerCase() === \"duration\") {\n          // \tchunk.text = durationFormat;\n          // }\n          // Check for \"a\" (absolute) modifier\n          if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {\n            item.absolute = true;\n            chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, \"$1\");\n          } // Find all possible parts\n\n\n          var matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);\n\n          if (matches) {\n            // Populate template\n            for (var x = 0; x < matches.length; x++) {\n              // Is it an alias?\n              if (!$type.hasValue(matches[x])) {\n                matches[x] = _this._unitAliases[matches[x]];\n              }\n\n              item.parts.push(matches[x]);\n              chunk.text = chunk.text.replace(matches[x], $strings.PLACEHOLDER);\n            }\n          }\n        } // Apply to template\n\n\n        item.template += chunk.text;\n      } // Apply style formatting\n      //item.template = getTextFormatter().format(item.template, this.outputFormat);\n      // Save cache\n\n\n      _this.setCache(item.source, item); // Mark this as parsed\n\n\n      item.parsed = true;\n    }); // Save cache (the whole thing)\n\n    this.setCache(format, info);\n    return info;\n  };\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by {parseFormat}\r\n   * @return Formatted duration\r\n   */\n\n\n  DurationFormatter.prototype.applyFormat = function (value, details) {\n    // Use absolute values\n    var negative = !details.absolute && value < this._negativeBase;\n    value = Math.abs(value); // Recalculate to milliseconds\n\n    var tstamp = this.toTimeStamp(value, details.baseUnit); // Init return value\n\n    var res = details.template; // Iterate through duration parts\n\n    for (var i = 0, len = details.parts.length; i < len; i++) {\n      // Gather the part\n      var part = details.parts[i];\n      var unit = this.toTimeUnit(part.substr(0, 1));\n      var digits = part.length; // Calculate current unit value\n\n      var ints = Math.floor(tstamp / this._unitValues[unit]);\n      res = res.replace($strings.PLACEHOLDER, $utils.padString(ints, digits, \"0\")); // Reduce timestamp\n\n      tstamp -= ints * this._unitValues[unit];\n    } // Reapply negative sign\n\n\n    if (negative) {\n      res = \"-\" + res;\n    }\n\n    return res;\n  };\n  /**\r\n   * Converts numeric value to timestamp in milliseconds.\r\n   *\r\n   * @param value     A source value\r\n   * @param baseUnit  Base unit the source value is in: \"q\", \"s\", \"i\", \"h\", \"d\", \"w\", \"m\", \"y\"\r\n   * @return Value representation as a timestamp in milliseconds\r\n   */\n\n\n  DurationFormatter.prototype.toTimeStamp = function (value, baseUnit) {\n    return value * this._unitValues[baseUnit];\n  };\n\n  DurationFormatter.prototype.toTimeUnit = function (code) {\n    switch (code) {\n      case \"S\":\n        return \"millisecond\";\n\n      case \"s\":\n        return \"second\";\n\n      case \"m\":\n        return \"minute\";\n\n      case \"h\":\n        return \"hour\";\n\n      case \"d\":\n        return \"day\";\n\n      case \"w\":\n        return \"week\";\n\n      case \"M\":\n        return \"month\";\n\n      case \"y\":\n        return \"year\";\n    }\n\n    ;\n  };\n  /**\r\n   * Invalidates the parent [[Sprite]] object.\r\n   */\n\n\n  DurationFormatter.prototype.invalidateSprite = function () {\n    if (this.sprite) {\n      this.sprite.invalidate();\n    }\n  };\n\n  Object.defineProperty(DurationFormatter.prototype, \"baseUnit\", {\n    /**\r\n     * @return Base unit\r\n     */\n    get: function () {\n      return this._baseUnit;\n    },\n\n    /**\r\n     * Base unit the values are in.\r\n     *\r\n     * A base unit will be used to recalculate the numeric value to millisecond\r\n     * timestamps.\r\n     *\r\n     * Available options:\r\n     *\r\n     * * \"millisecond\"\r\n     * * \"second\"\r\n     * * \"minute\"\r\n     * * \"hour\"\r\n     * * \"day\"\r\n     * * \"week\"\r\n     * * \"month\"\r\n     * * \"year\"\r\n     *\r\n     * @default \"s\"\r\n     * @param baseUnit  A base unit\r\n     */\n    set: function (baseUnit) {\n      this._baseUnit = baseUnit;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DurationFormatter.prototype, \"outputFormat\", {\n    /**\r\n     * Getter for output format.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Output format\r\n     */\n    get: function () {\n      return this._outputFormat;\n    },\n\n    /**\r\n     * Setter for output format: \"svg\" or \"html.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Output format\r\n     */\n    set: function (outputFormat) {\n      this._outputFormat = outputFormat.toLowerCase();\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns appropriate default format for the value.\r\n   *\r\n   * If `maxValue` is sepcified, it will use that value to determine the time\r\n   * unit for the format.\r\n   *\r\n   * For example if your `baseUnit` is `\"second\"` and you pass in `10`, you\r\n   * will get `\"10\"`.\r\n   *\r\n   * However, you might want it to be formatted in the context of bigger scale,\r\n   * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all\r\n   * values, including small ones will use format with minutes, e.g.:\r\n   * `00:10`, `00:50`, `12: 30`, etc.\r\n   *\r\n   * @param value     Value to format\r\n   * @param maxValue  Maximum value to be used to determine format\r\n   * @param baseUnit  Base unit of the value\r\n   * @return Format\r\n   */\n\n  DurationFormatter.prototype.getFormat = function (value, maxValue, baseUnit) {\n    // Is format override set?\n    if ($type.hasValue(this.durationFormat)) {\n      return this.durationFormat;\n    } // Get base unit\n\n\n    if (!baseUnit) {\n      baseUnit = this.baseUnit;\n    }\n\n    if ($type.hasValue(maxValue) && value != maxValue) {\n      value = Math.abs(value);\n      maxValue = Math.abs(maxValue);\n      var maxUnit = this.getValueUnit($math.max(value, maxValue), baseUnit); //let diffUnit = this.getValueUnit(Math.abs(maxValue - value), baseUnit);\n      //console.log(maxUnit, diffUnit);\n\n      return this.durationFormats[baseUnit][maxUnit];\n    } else {\n      var unit = this.getValueUnit(value, baseUnit);\n      return this.durationFormats[baseUnit][unit];\n    }\n  };\n  /**\r\n   * Returns value's closest denominator time unit, e.g 100 seconds is\r\n   * `\"minute\"`, while 59 seconds would still be `second`.\r\n   *\r\n   * @param value     Source duration value\r\n   * @param baseUnit  Base unit\r\n   * @return Denominator\r\n   */\n\n\n  DurationFormatter.prototype.getValueUnit = function (value, baseUnit) {\n    // Get base unit\n    if (!baseUnit) {\n      baseUnit = this.baseUnit;\n    } // Convert to milliseconds\n\n\n    var currentUnit;\n    var ms = this.getMilliseconds(value, baseUnit);\n    $object.eachContinue(this._unitValues, function (key, val) {\n      if (key == baseUnit || currentUnit) {\n        var num = ms / val;\n\n        if (num <= 1) {\n          if (!currentUnit) {\n            currentUnit = key;\n          }\n\n          return false;\n        }\n\n        currentUnit = key;\n      }\n\n      return true;\n    });\n    return currentUnit;\n  };\n  /**\r\n   * Converts value to milliseconds according to `baseUnit`.\r\n   *\r\n   * @param value     Source duration value\r\n   * @param baseUnit  Base unit\r\n   * @return Value in milliseconds\r\n   */\n\n\n  DurationFormatter.prototype.getMilliseconds = function (value, baseUnit) {\n    // Get base unit\n    if (!baseUnit) {\n      baseUnit = this.baseUnit;\n    }\n\n    return value * this._unitValues[baseUnit];\n  };\n\n  Object.defineProperty(DurationFormatter.prototype, \"durationFormat\", {\n    /**\r\n     * @return Format\r\n     */\n    get: function () {\n      return this._durationFormat;\n    },\n\n    /**\r\n     * If set, this format will be used instead of the one determined dynamically\r\n     * based on the basedUnit and range of values.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} Available fomatting codes\r\n     * @param value  Format\r\n     */\n    set: function (value) {\n      if (this._durationFormat != value) {\n        this._durationFormat = value;\n        this.invalidateSprite();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DurationFormatter.prototype, \"durationFormats\", {\n    /**\r\n     * @return Formats\r\n     */\n    get: function () {\n      if (!this._durationFormats) {\n        this._durationFormats = {\n          \"millisecond\": {\n            \"millisecond\": this.language.translate(\"_duration_millisecond\"),\n            \"second\": this.language.translate(\"_duration_millisecond_second\"),\n            \"minute\": this.language.translate(\"_duration_millisecond_minute\"),\n            \"hour\": this.language.translate(\"_duration_millisecond_hour\"),\n            \"day\": this.language.translate(\"_duration_millisecond_day\"),\n            \"week\": this.language.translate(\"_duration_millisecond_week\"),\n            \"month\": this.language.translate(\"_duration_millisecond_month\"),\n            \"year\": this.language.translate(\"_duration_millisecond_year\")\n          },\n          \"second\": {\n            \"second\": this.language.translate(\"_duration_second\"),\n            \"minute\": this.language.translate(\"_duration_second_minute\"),\n            \"hour\": this.language.translate(\"_duration_second_hour\"),\n            \"day\": this.language.translate(\"_duration_second_day\"),\n            \"week\": this.language.translate(\"_duration_second_week\"),\n            \"month\": this.language.translate(\"_duration_second_month\"),\n            \"year\": this.language.translate(\"_duration_second_year\")\n          },\n          \"minute\": {\n            \"minute\": this.language.translate(\"_duration_minute\"),\n            \"hour\": this.language.translate(\"_duration_minute_hour\"),\n            \"day\": this.language.translate(\"_duration_minute_day\"),\n            \"week\": this.language.translate(\"_duration_minute_week\"),\n            \"month\": this.language.translate(\"_duration_minute_month\"),\n            \"year\": this.language.translate(\"_duration_minute_year\")\n          },\n          \"hour\": {\n            \"hour\": this.language.translate(\"_duration_hour\"),\n            \"day\": this.language.translate(\"_duration_hour_day\"),\n            \"week\": this.language.translate(\"_duration_hour_week\"),\n            \"month\": this.language.translate(\"_duration_hour_month\"),\n            \"year\": this.language.translate(\"_duration_hour_year\")\n          },\n          \"day\": {\n            \"day\": this.language.translate(\"_duration_day\"),\n            \"week\": this.language.translate(\"_duration_day_week\"),\n            \"month\": this.language.translate(\"_duration_day_month\"),\n            \"year\": this.language.translate(\"_duration_day_year\")\n          },\n          \"week\": {\n            \"week\": this.language.translate(\"_duration_week\"),\n            \"month\": this.language.translate(\"_duration_week_month\"),\n            \"year\": this.language.translate(\"_duration_week_year\")\n          },\n          \"month\": {\n            \"month\": this.language.translate(\"_duration_month\"),\n            \"year\": this.language.translate(\"_duration_month_year\")\n          },\n          \"year\": {\n            \"year\": this.language.translate(\"_duration_year\")\n          }\n        };\n      }\n\n      return this._durationFormats;\n    },\n\n    /**\r\n     * Duration formats for various combination of base units.\r\n     *\r\n     * @param value  Formats\r\n     */\n    set: function (value) {\n      this._durationFormats = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DurationFormatter;\n}(BaseObject);\n\nexport { DurationFormatter };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"DurationFormatter\"] = DurationFormatter;","map":null,"metadata":{},"sourceType":"module"}