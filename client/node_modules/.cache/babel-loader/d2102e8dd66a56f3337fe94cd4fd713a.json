{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Dictionary } from \"./utils/Dictionary\";\nimport { TargetedEventDispatcher } from \"./utils/EventDispatcher\";\nimport { MultiDisposer, CounterDisposer } from \"./utils/Disposer\";\nimport * as $utils from \"./utils/Utils\";\nimport * as $object from \"./utils/Object\";\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @important\r\n */\n\nvar SpriteEventDispatcher =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SpriteEventDispatcher, _super);\n\n  function SpriteEventDispatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * [_interactionEvents description]\r\n     *\r\n     * @todo Description\r\n     */\n\n\n    _this._interactionEvents = new Dictionary();\n    return _this;\n  }\n  /**\r\n   * [_dispatchSpriteEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._dispatchSpriteEvent = function (ev) {\n    if (this.target.disabled || this.target.isTemplate) {\n      return;\n    } // TODO remove this <any> later\n\n\n    if (this.target.events.isEnabled(ev.type)) {\n      var imev = $object.merge(ev, {\n        target: this.target\n      });\n      this.target.events.dispatchImmediately(imev.type, imev);\n    }\n  };\n  /**\r\n   * [_dispatchSpritePointEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._dispatchSpritePointEvent = function (ev) {\n    if (this.target.disabled || this.target.isTemplate) {\n      return;\n    } // TODO remove this <any> later\n\n\n    if (this.target.events.isEnabled(ev.type)) {\n      var imev = $object.merge(ev, {\n        target: this.target,\n        spritePoint: $utils.documentPointToSprite(ev.point, this.target),\n        svgPoint: this.target.getSvgPoint(ev.point)\n      });\n      this.target.events.dispatchImmediately(imev.type, imev);\n    }\n  };\n  /**\r\n   * [_addInteractionObjectEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._addInteractionObjectEvent = function (type, callback, context, shouldClone) {\n    var _this = this;\n\n    var counter = this._interactionEvents.insertKeyIfEmpty(type, function () {\n      var disposer = _this.target.interactions.events.on(type, callback, context, shouldClone);\n\n      return new CounterDisposer(function () {\n        _this._interactionEvents.removeKey(type);\n\n        disposer.dispose();\n      });\n    });\n\n    return counter.increment();\n  };\n  /**\r\n   * [_on description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {\n    var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);\n\n    var disposers = [info.disposer];\n    /**\r\n     * Catching Sprite-related events, converting them to [[SpriteEvent]] and\r\n     * triggering them on sprite\r\n     */\n\n    switch (type) {\n      case \"hit\":\n      case \"track\":\n      case \"doublehit\":\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpritePointEvent, this, shouldClone));\n        break;\n\n      case \"rightclick\":\n      case \"down\": //case \"hold\":\n\n      case \"up\":\n      case \"drag\":\n      case \"dragged\":\n      case \"dragstart\":\n      case \"dragstop\":\n      case \"over\":\n      case \"out\":\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n      case \"resize\": //case \"rotate\":\n\n      case \"focus\":\n      case \"blur\":\n      case \"toggled\":\n        disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpriteEvent, this, shouldClone));\n        break;\n    }\n    /**\r\n     * Set functional properties based on events. For example if we add a\r\n     * \"drag\" event handler, we want to make the Sprite draggable, even if we\r\n     * don't explicitly set \"draggable\"\r\n     */\n\n\n    switch (type) {\n      case \"hit\":\n      case \"doublehit\":\n      case \"rightclick\":\n      case \"down\":\n      case \"up\":\n        this.target.clickable = true;\n        break;\n\n      case \"toggled\":\n        this.target.togglable = true;\n        break;\n\n      case \"drag\":\n      case \"dragstart\":\n      case \"dragstop\":\n        this.target.draggable = true;\n        break;\n\n      case \"track\":\n        this.target.trackable = true;\n        break;\n\n      case \"resize\":\n        this.target.resizable = true;\n        break;\n\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n        this.target.swipeable = true;\n        break;\n\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        this.target.wheelable = true;\n        break;\n\n      case \"over\":\n        this.target.hoverable = true;\n\n      case \"out\":\n        this.target.hoverable = true;\n        break;\n\n      case \"focus\":\n      case \"blur\":\n        this.target.focusable = true;\n        break;\n    }\n\n    info.disposer = new MultiDisposer(disposers);\n    return info;\n  };\n\n  return SpriteEventDispatcher;\n}(TargetedEventDispatcher);\n\nexport { SpriteEventDispatcher };","map":null,"metadata":{},"sourceType":"module"}