{"ast":null,"code":"/*\n * Color Thief v2.0\n * by Lokesh Dhakar - http://www.lokeshdhakar.com\n *\n * Thanks\n * ------\n * Nick Rabinowitz - For creating quantize.js.\n * John Schulz - For clean up and optimization. @JFSIII\n * Nathan Spady - For adding drag and drop support to the demo page.\n *\n * License\n * -------\n * Copyright 2011, 2015 Lokesh Dhakar\n * Released under the MIT license\n * https://raw.githubusercontent.com/lokesh/color-thief/master/LICENSE\n *\n * @license\n */\n\n/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\nvar CanvasImage = function CanvasImage(image) {\n  this.canvas = document.createElement('canvas');\n  this.context = this.canvas.getContext('2d');\n  document.body.appendChild(this.canvas);\n  this.width = this.canvas.width = image.width;\n  this.height = this.canvas.height = image.height;\n  this.context.drawImage(image, 0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.clear = function () {\n  this.context.clearRect(0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.update = function (imageData) {\n  this.context.putImageData(imageData, 0, 0);\n};\n\nCanvasImage.prototype.getPixelCount = function () {\n  return this.width * this.height;\n};\n\nCanvasImage.prototype.getImageData = function () {\n  return this.context.getImageData(0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.removeCanvas = function () {\n  this.canvas.parentNode.removeChild(this.canvas);\n};\n\nexport var ColorThief = function ColorThief() {};\n/*\n * getColor(sourceImage[, quality])\n * returns {r: num, g: num, b: num}\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar\n * colors and return the base color from the largest cluster.\n *\n * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster a color will be returned but the greater the likelihood that it will not be the visually\n * most dominant color.\n *\n * */\n\nColorThief.prototype.getColor = function (sourceImage, quality) {\n  var palette = this.getPalette(sourceImage, 5, quality);\n  var dominantColor = palette[0];\n  return dominantColor;\n};\n/*\n * getPalette(sourceImage[, colorCount, quality])\n * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n *\n * colorCount determines the size of the palette; the number of colors returned. If not set, it\n * defaults to 10.\n *\n * BUGGY: Function does not always return the requested amount of colors. It can be +/- 2.\n *\n * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster the palette generation but the greater the likelihood that colors will be missed.\n *\n *\n */\n\n\nColorThief.prototype.getPalette = function (sourceImage, colorCount, quality) {\n  if (typeof colorCount === 'undefined' || colorCount < 2 || colorCount > 256) {\n    colorCount = 10;\n  }\n\n  if (typeof quality === 'undefined' || quality < 1) {\n    quality = 10;\n  } // Create custom CanvasImage object\n\n\n  var image = new CanvasImage(sourceImage);\n  var imageData = image.getImageData();\n  var pixels = imageData.data;\n  var pixelCount = image.getPixelCount(); // Store the RGB values in an array format suitable for quantize function\n\n  var pixelArray = [];\n\n  for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n    offset = i * 4;\n    r = pixels[offset + 0];\n    g = pixels[offset + 1];\n    b = pixels[offset + 2];\n    a = pixels[offset + 3]; // If pixel is mostly opaque and not white\n\n    if (a >= 125) {\n      if (!(r > 250 && g > 250 && b > 250)) {\n        pixelArray.push([r, g, b]);\n      }\n    }\n  } // Send array to quantize function which clusters values\n  // using median cut algorithm\n\n\n  var cmap = MMCQ.quantize(pixelArray, colorCount);\n  var palette = cmap ? cmap.palette() : null; // Clean up\n\n  image.removeCanvas();\n  return palette;\n};\n\nColorThief.prototype.getColorFromUrl = function (imageUrl, callback, quality) {\n  sourceImage = document.createElement(\"img\");\n  var thief = this;\n  sourceImage.addEventListener('load', function () {\n    var palette = thief.getPalette(sourceImage, 5, quality);\n    var dominantColor = palette[0];\n    callback(dominantColor, imageUrl);\n  });\n  sourceImage.src = imageUrl;\n};\n\nColorThief.prototype.getImageData = function (imageUrl, callback) {\n  xhr = new XMLHttpRequest();\n  xhr.open('GET', imageUrl, true);\n  xhr.responseType = 'arraybuffer';\n\n  xhr.onload = function (e) {\n    if (this.status == 200) {\n      uInt8Array = new Uint8Array(this.response);\n      i = uInt8Array.length;\n      binaryString = new Array(i);\n\n      for (var i = 0; i < uInt8Array.length; i++) {\n        binaryString[i] = String.fromCharCode(uInt8Array[i]);\n      }\n\n      data = binaryString.join('');\n      base64 = window.btoa(data);\n      callback(\"data:image/png;base64,\" + base64);\n    }\n  };\n\n  xhr.send();\n};\n\nColorThief.prototype.getColorAsync = function (imageUrl, callback, quality) {\n  var thief = this;\n  this.getImageData(imageUrl, function (imageData) {\n    sourceImage = document.createElement(\"img\");\n    sourceImage.addEventListener('load', function () {\n      var palette = thief.getPalette(sourceImage, 5, quality);\n      var dominantColor = palette[0];\n      callback(dominantColor, this);\n    });\n    sourceImage.src = imageData;\n  });\n};\n/*!\n * quantize.js Copyright 2008 Nick Rabinowitz.\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n * @license\n */\n// fill out a couple protovis dependencies\n\n/*!\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n * @license\n */\n\n\nif (!pv) {\n  var pv = {\n    map: function map(array, f) {\n      var o = {};\n      return f ? array.map(function (d, i) {\n        o.index = i;\n        return f.call(o, d);\n      }) : array.slice();\n    },\n    naturalOrder: function naturalOrder(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    },\n    sum: function sum(array, f) {\n      var o = {};\n      return array.reduce(f ? function (p, d, i) {\n        o.index = i;\n        return p + f.call(o, d);\n      } : function (p, d) {\n        return p + d;\n      }, 0);\n    },\n    max: function max(array, f) {\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\n    }\n  };\n}\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n *\n * @author Nick Rabinowitz\n * @example\n\n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n\nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) {\n    return cmap.map(p);\n});\n\n */\n\n\nvar MMCQ = function () {\n  // private constants\n  var sigbits = 5,\n      rshift = 8 - sigbits,\n      maxIterations = 1000,\n      fractByPopulations = 0.75; // get reduced-space color index for a pixel\n\n  function getColorIndex(r, g, b) {\n    return (r << 2 * sigbits) + (g << sigbits) + b;\n  } // Simple priority queue\n\n\n  function PQueue(comparator) {\n    var contents = [],\n        sorted = false;\n\n    function sort() {\n      contents.sort(comparator);\n      sorted = true;\n    }\n\n    return {\n      push: function push(o) {\n        contents.push(o);\n        sorted = false;\n      },\n      peek: function peek(index) {\n        if (!sorted) sort();\n        if (index === undefined) index = contents.length - 1;\n        return contents[index];\n      },\n      pop: function pop() {\n        if (!sorted) sort();\n        return contents.pop();\n      },\n      size: function size() {\n        return contents.length;\n      },\n      map: function map(f) {\n        return contents.map(f);\n      },\n      debug: function debug() {\n        if (!sorted) sort();\n        return contents;\n      }\n    };\n  } // 3d color space box\n\n\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\n    var vbox = this;\n    vbox.r1 = r1;\n    vbox.r2 = r2;\n    vbox.g1 = g1;\n    vbox.g2 = g2;\n    vbox.b1 = b1;\n    vbox.b2 = b2;\n    vbox.histo = histo;\n  }\n\n  VBox.prototype = {\n    volume: function volume(force) {\n      var vbox = this;\n\n      if (!vbox._volume || force) {\n        vbox._volume = (vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1);\n      }\n\n      return vbox._volume;\n    },\n    count: function count(force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._count_set || force) {\n        var npix = 0,\n            index,\n            i,\n            j,\n            k;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              index = getColorIndex(i, j, k);\n              npix += histo[index] || 0;\n            }\n          }\n        }\n\n        vbox._count = npix;\n        vbox._count_set = true;\n      }\n\n      return vbox._count;\n    },\n    copy: function copy() {\n      var vbox = this;\n      return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n    },\n    avg: function avg(force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._avg || force) {\n        var ntot = 0,\n            mult = 1 << 8 - sigbits,\n            rsum = 0,\n            gsum = 0,\n            bsum = 0,\n            hval,\n            i,\n            j,\n            k,\n            histoindex;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              histoindex = getColorIndex(i, j, k);\n              hval = histo[histoindex] || 0;\n              ntot += hval;\n              rsum += hval * (i + 0.5) * mult;\n              gsum += hval * (j + 0.5) * mult;\n              bsum += hval * (k + 0.5) * mult;\n            }\n          }\n        }\n\n        if (ntot) {\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n        } else {\n          //                    console.log('empty box');\n          vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n        }\n      }\n\n      return vbox._avg;\n    },\n    contains: function contains(pixel) {\n      var vbox = this,\n          rval = pixel[0] >> rshift,\n          gval = pixel[1] >> rshift,\n          bval = pixel[2] >> rshift;\n      return rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && gval <= vbox.g2 && bval >= vbox.b1 && bval <= vbox.b2;\n    }\n  }; // Color map\n\n  function CMap() {\n    this.vboxes = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());\n    });\n  }\n\n  CMap.prototype = {\n    push: function push(vbox) {\n      this.vboxes.push({\n        vbox: vbox,\n        color: vbox.avg()\n      });\n    },\n    palette: function palette() {\n      return this.vboxes.map(function (vb) {\n        return vb.color;\n      });\n    },\n    size: function size() {\n      return this.vboxes.size();\n    },\n    map: function map(color) {\n      var vboxes = this.vboxes;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        if (vboxes.peek(i).vbox.contains(color)) {\n          return vboxes.peek(i).color;\n        }\n      }\n\n      return this.nearest(color);\n    },\n    nearest: function nearest(color) {\n      var vboxes = this.vboxes,\n          d1,\n          d2,\n          pColor;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));\n\n        if (d2 < d1 || d1 === undefined) {\n          d1 = d2;\n          pColor = vboxes.peek(i).color;\n        }\n      }\n\n      return pColor;\n    },\n    forcebw: function forcebw() {\n      // XXX: won't  work yet\n      var vboxes = this.vboxes;\n      vboxes.sort(function (a, b) {\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));\n      }); // force darkest color to black if everything < 5\n\n      var lowest = vboxes[0].color;\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5) vboxes[0].color = [0, 0, 0]; // force lightest color to white if everything > 251\n\n      var idx = vboxes.length - 1,\n          highest = vboxes[idx].color;\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) vboxes[idx].color = [255, 255, 255];\n    }\n  }; // histo (1-d array, giving the number of pixels in\n  // each quantized region of color space), or null on error\n\n  function getHisto(pixels) {\n    var histosize = 1 << 3 * sigbits,\n        histo = new Array(histosize),\n        index,\n        rval,\n        gval,\n        bval;\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      index = getColorIndex(rval, gval, bval);\n      histo[index] = (histo[index] || 0) + 1;\n    });\n    return histo;\n  }\n\n  function vboxFromPixels(pixels, histo) {\n    var rmin = 1000000,\n        rmax = 0,\n        gmin = 1000000,\n        gmax = 0,\n        bmin = 1000000,\n        bmax = 0,\n        rval,\n        gval,\n        bval; // find min/max\n\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      if (rval < rmin) rmin = rval;else if (rval > rmax) rmax = rval;\n      if (gval < gmin) gmin = gval;else if (gval > gmax) gmax = gval;\n      if (bval < bmin) bmin = bval;else if (bval > bmax) bmax = bval;\n    });\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n  }\n\n  function medianCutApply(histo, vbox) {\n    if (!vbox.count()) return;\n    var rw = vbox.r2 - vbox.r1 + 1,\n        gw = vbox.g2 - vbox.g1 + 1,\n        bw = vbox.b2 - vbox.b1 + 1,\n        maxw = pv.max([rw, gw, bw]); // only one pixel, no split\n\n    if (vbox.count() == 1) {\n      return [vbox.copy()];\n    }\n    /* Find the partial sum arrays along the selected axis. */\n\n\n    var total = 0,\n        partialsum = [],\n        lookaheadsum = [],\n        i,\n        j,\n        k,\n        sum,\n        index;\n\n    if (maxw == rw) {\n      for (i = vbox.r1; i <= vbox.r2; i++) {\n        sum = 0;\n\n        for (j = vbox.g1; j <= vbox.g2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(i, j, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else if (maxw == gw) {\n      for (i = vbox.g1; i <= vbox.g2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(j, i, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else {\n      /* maxw == bw */\n      for (i = vbox.b1; i <= vbox.b2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.g1; k <= vbox.g2; k++) {\n            index = getColorIndex(j, k, i);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    }\n\n    partialsum.forEach(function (d, i) {\n      lookaheadsum[i] = total - d;\n    });\n\n    function doCut(color) {\n      var dim1 = color + '1',\n          dim2 = color + '2',\n          left,\n          right,\n          vbox1,\n          vbox2,\n          d2,\n          count2 = 0;\n\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n        if (partialsum[i] > total / 2) {\n          vbox1 = vbox.copy();\n          vbox2 = vbox.copy();\n          left = i - vbox[dim1];\n          right = vbox[dim2] - i;\n          if (left <= right) d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2)); // avoid 0-count boxes\n\n          while (!partialsum[d2]) {\n            d2++;\n          }\n\n          count2 = lookaheadsum[d2];\n\n          while (!count2 && partialsum[d2 - 1]) {\n            count2 = lookaheadsum[--d2];\n          } // set dimensions\n\n\n          vbox1[dim2] = d2;\n          vbox2[dim1] = vbox1[dim2] + 1; //                    console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n\n          return [vbox1, vbox2];\n        }\n      }\n    } // determine the cut planes\n\n\n    return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');\n  }\n\n  function quantize(pixels, maxcolors) {\n    // short-circuit\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n      //            console.log('wrong number of maxcolors');\n      return false;\n    } // XXX: check color content and convert to grayscale if insufficient\n\n\n    var histo = getHisto(pixels),\n        histosize = 1 << 3 * sigbits; // check that we aren't below maxcolors already\n\n    var nColors = 0;\n    histo.forEach(function () {\n      nColors++;\n    });\n\n    if (nColors <= maxcolors) {} // XXX: generate the new colors from the histo and return\n    // get the beginning vbox from the colors\n\n\n    var vbox = vboxFromPixels(pixels, histo),\n        pq = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count(), b.count());\n    });\n    pq.push(vbox); // inner function to do the iteration\n\n    function iter(lh, target) {\n      var ncolors = 1,\n          niters = 0,\n          vbox;\n\n      while (niters < maxIterations) {\n        vbox = lh.pop();\n\n        if (!vbox.count()) {\n          /* just put it back */\n          lh.push(vbox);\n          niters++;\n          continue;\n        } // do the cut\n\n\n        var vboxes = medianCutApply(histo, vbox),\n            vbox1 = vboxes[0],\n            vbox2 = vboxes[1];\n\n        if (!vbox1) {\n          //                    console.log(\"vbox1 not defined; shouldn't happen!\");\n          return;\n        }\n\n        lh.push(vbox1);\n\n        if (vbox2) {\n          /* vbox2 can be null */\n          lh.push(vbox2);\n          ncolors++;\n        }\n\n        if (ncolors >= target) return;\n\n        if (niters++ > maxIterations) {\n          //                    console.log(\"infinite loop; perhaps too few pixels!\");\n          return;\n        }\n      }\n    } // first set of colors, sorted by population\n\n\n    iter(pq, fractByPopulations * maxcolors); // Re-sort by the product of pixel occupancy times the size in color space.\n\n    var pq2 = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n    });\n\n    while (pq.size()) {\n      pq2.push(pq.pop());\n    } // next set - generate the median cuts using the (npix * vol) sorting.\n\n\n    iter(pq2, maxcolors - pq2.size()); // calculate the actual colors\n\n    var cmap = new CMap();\n\n    while (pq2.size()) {\n      cmap.push(pq2.pop());\n    }\n\n    return cmap;\n  }\n\n  return {\n    quantize: quantize\n  };\n}();","map":{"version":3,"sources":["/Users/Overseer/Desktop/vievacance/client/src/utils/color-thief.js"],"names":["CanvasImage","image","canvas","document","createElement","context","getContext","body","appendChild","width","height","drawImage","prototype","clear","clearRect","update","imageData","putImageData","getPixelCount","getImageData","removeCanvas","parentNode","removeChild","ColorThief","getColor","sourceImage","quality","palette","getPalette","dominantColor","colorCount","pixels","data","pixelCount","pixelArray","i","offset","r","g","b","a","push","cmap","MMCQ","quantize","getColorFromUrl","imageUrl","callback","thief","addEventListener","src","xhr","XMLHttpRequest","open","responseType","onload","e","status","uInt8Array","Uint8Array","response","length","binaryString","Array","String","fromCharCode","join","base64","window","btoa","send","getColorAsync","pv","map","array","f","o","d","index","call","slice","naturalOrder","sum","reduce","p","max","Math","apply","sigbits","rshift","maxIterations","fractByPopulations","getColorIndex","PQueue","comparator","contents","sorted","sort","peek","undefined","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","vbox","volume","force","_volume","count","_count_set","npix","j","k","_count","copy","avg","_avg","ntot","mult","rsum","gsum","bsum","hval","histoindex","contains","pixel","rval","gval","bval","CMap","vboxes","color","vb","nearest","d1","d2","pColor","sqrt","pow","forcebw","lowest","idx","highest","getHisto","histosize","forEach","vboxFromPixels","rmin","rmax","gmin","gmax","bmin","bmax","medianCutApply","rw","gw","bw","maxw","total","partialsum","lookaheadsum","doCut","dim1","dim2","left","right","vbox1","vbox2","count2","min","maxcolors","nColors","pq","iter","lh","target","ncolors","niters","pq2"],"mappings":"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","sourcesContent":["/*\n * Color Thief v2.0\n * by Lokesh Dhakar - http://www.lokeshdhakar.com\n *\n * Thanks\n * ------\n * Nick Rabinowitz - For creating quantize.js.\n * John Schulz - For clean up and optimization. @JFSIII\n * Nathan Spady - For adding drag and drop support to the demo page.\n *\n * License\n * -------\n * Copyright 2011, 2015 Lokesh Dhakar\n * Released under the MIT license\n * https://raw.githubusercontent.com/lokesh/color-thief/master/LICENSE\n *\n * @license\n */\n\n\n/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\nvar CanvasImage = function (image) {\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n\n    document.body.appendChild(this.canvas);\n\n    this.width = this.canvas.width = image.width;\n    this.height = this.canvas.height = image.height;\n\n    this.context.drawImage(image, 0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.clear = function () {\n    this.context.clearRect(0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.update = function (imageData) {\n    this.context.putImageData(imageData, 0, 0);\n};\n\nCanvasImage.prototype.getPixelCount = function () {\n    return this.width * this.height;\n};\n\nCanvasImage.prototype.getImageData = function () {\n    return this.context.getImageData(0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.removeCanvas = function () {\n    this.canvas.parentNode.removeChild(this.canvas);\n};\n\n\nexport var ColorThief = function () { };\n\n/*\n * getColor(sourceImage[, quality])\n * returns {r: num, g: num, b: num}\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar\n * colors and return the base color from the largest cluster.\n *\n * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster a color will be returned but the greater the likelihood that it will not be the visually\n * most dominant color.\n *\n * */\nColorThief.prototype.getColor = function (sourceImage, quality) {\n    var palette = this.getPalette(sourceImage, 5, quality);\n    var dominantColor = palette[0];\n    return dominantColor;\n};\n\n\n/*\n * getPalette(sourceImage[, colorCount, quality])\n * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n *\n * colorCount determines the size of the palette; the number of colors returned. If not set, it\n * defaults to 10.\n *\n * BUGGY: Function does not always return the requested amount of colors. It can be +/- 2.\n *\n * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster the palette generation but the greater the likelihood that colors will be missed.\n *\n *\n */\nColorThief.prototype.getPalette = function (sourceImage, colorCount, quality) {\n\n    if (typeof colorCount === 'undefined' || colorCount < 2 || colorCount > 256) {\n        colorCount = 10;\n    }\n    if (typeof quality === 'undefined' || quality < 1) {\n        quality = 10;\n    }\n\n    // Create custom CanvasImage object\n    var image = new CanvasImage(sourceImage);\n    var imageData = image.getImageData();\n    var pixels = imageData.data;\n    var pixelCount = image.getPixelCount();\n\n    // Store the RGB values in an array format suitable for quantize function\n    var pixelArray = [];\n    for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n        offset = i * 4;\n        r = pixels[offset + 0];\n        g = pixels[offset + 1];\n        b = pixels[offset + 2];\n        a = pixels[offset + 3];\n        // If pixel is mostly opaque and not white\n        if (a >= 125) {\n            if (!(r > 250 && g > 250 && b > 250)) {\n                pixelArray.push([r, g, b]);\n            }\n        }\n    }\n\n    // Send array to quantize function which clusters values\n    // using median cut algorithm\n    var cmap = MMCQ.quantize(pixelArray, colorCount);\n    var palette = cmap ? cmap.palette() : null;\n\n    // Clean up\n    image.removeCanvas();\n\n    return palette;\n};\n\nColorThief.prototype.getColorFromUrl = function (imageUrl, callback, quality) {\n    sourceImage = document.createElement(\"img\");\n    var thief = this;\n    sourceImage.addEventListener('load', function () {\n        var palette = thief.getPalette(sourceImage, 5, quality);\n        var dominantColor = palette[0];\n        callback(dominantColor, imageUrl);\n    });\n    sourceImage.src = imageUrl\n};\n\n\nColorThief.prototype.getImageData = function (imageUrl, callback) {\n    xhr = new XMLHttpRequest();\n    xhr.open('GET', imageUrl, true);\n    xhr.responseType = 'arraybuffer'\n    xhr.onload = function (e) {\n        if (this.status == 200) {\n            uInt8Array = new Uint8Array(this.response)\n            i = uInt8Array.length\n            binaryString = new Array(i);\n            for (var i = 0; i < uInt8Array.length; i++) {\n                binaryString[i] = String.fromCharCode(uInt8Array[i])\n            }\n            data = binaryString.join('')\n            base64 = window.btoa(data)\n            callback(\"data:image/png;base64,\" + base64)\n        }\n    }\n    xhr.send();\n};\n\nColorThief.prototype.getColorAsync = function (imageUrl, callback, quality) {\n    var thief = this;\n    this.getImageData(imageUrl, function (imageData) {\n        sourceImage = document.createElement(\"img\");\n        sourceImage.addEventListener('load', function () {\n            var palette = thief.getPalette(sourceImage, 5, quality);\n            var dominantColor = palette[0];\n            callback(dominantColor, this);\n        });\n        sourceImage.src = imageData;\n    });\n};\n\n\n\n/*!\n * quantize.js Copyright 2008 Nick Rabinowitz.\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n * @license\n */\n\n// fill out a couple protovis dependencies\n/*!\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n * @license\n */\nif (!pv) {\n    var pv = {\n        map: function (array, f) {\n            var o = {};\n            return f ? array.map(function (d, i) { o.index = i; return f.call(o, d); }) : array.slice();\n        },\n        naturalOrder: function (a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function (array, f) {\n            var o = {};\n            return array.reduce(f ? function (p, d, i) { o.index = i; return p + f.call(o, d); } : function (p, d) { return p + d; }, 0);\n        },\n        max: function (array, f) {\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    };\n}\n\n\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n *\n * @author Nick Rabinowitz\n * @example\n\n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n\nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) {\n    return cmap.map(p);\n});\n\n */\nvar MMCQ = (function () {\n    // private constants\n    var sigbits = 5,\n        rshift = 8 - sigbits,\n        maxIterations = 1000,\n        fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n    function PQueue(comparator) {\n        var contents = [],\n            sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function (o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function (index) {\n                if (!sorted) sort();\n                if (index === undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function () {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function () {\n                return contents.length;\n            },\n            map: function (f) {\n                return contents.map(f);\n            },\n            debug: function () {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function (force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function (force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0,\n                    index, i, j, k;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            index = getColorIndex(i, j, k);\n                            npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function () {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function (force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0,\n                    mult = 1 << (8 - sigbits),\n                    rsum = 0,\n                    gsum = 0,\n                    bsum = 0,\n                    hval,\n                    i, j, k, histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            histoindex = getColorIndex(i, j, k);\n                            hval = histo[histoindex] || 0;\n                            ntot += hval;\n                            rsum += (hval * (i + 0.5) * mult);\n                            gsum += (hval * (j + 0.5) * mult);\n                            bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n                } else {\n                    //                    console.log('empty box');\n                    vbox._avg = [\n                        ~~(mult * (vbox.r1 + vbox.r2 + 1) / 2),\n                        ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2),\n                        ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)\n                    ];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function (pixel) {\n            var vbox = this,\n                rval = pixel[0] >> rshift,\n                gval = pixel[1] >> rshift,\n                bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                gval >= vbox.g1 && gval <= vbox.g2 &&\n                bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n    function CMap() {\n        this.vboxes = new PQueue(function (a, b) {\n            return pv.naturalOrder(\n                a.vbox.count() * a.vbox.volume(),\n                b.vbox.count() * b.vbox.volume()\n            );\n        });\n    }\n    CMap.prototype = {\n        push: function (vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function () {\n            return this.vboxes.map(function (vb) { return vb.color; });\n        },\n        size: function () {\n            return this.vboxes.size();\n        },\n        map: function (color) {\n            var vboxes = this.vboxes;\n            for (var i = 0; i < vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function (color) {\n            var vboxes = this.vboxes,\n                d1, d2, pColor;\n            for (var i = 0; i < vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function () {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function (a, b) { return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color)); });\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0, 0, 0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length - 1,\n                highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255, 255, 255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits),\n            histo = new Array(histosize),\n            index, rval, gval, bval;\n        pixels.forEach(function (pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin = 1000000, rmax = 0,\n            gmin = 1000000, gmax = 0,\n            bmin = 1000000, bmax = 0,\n            rval, gval, bval;\n        // find min/max\n        pixels.forEach(function (pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax) bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1,\n            gw = vbox.g2 - vbox.g1 + 1,\n            bw = vbox.b2 - vbox.b1 + 1,\n            maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()];\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0,\n            partialsum = [],\n            lookaheadsum = [],\n            i, j, k, sum, index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i, j, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j, i, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        else {  /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j, k, i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function (d, i) {\n            lookaheadsum[i] = total - d;\n        });\n        function doCut(color) {\n            var dim1 = color + '1',\n                dim2 = color + '2',\n                left, right, vbox1, vbox2, d2, count2 = 0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n                    //                    console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n                doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n            //            console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels),\n            histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function () { nColors++; });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo),\n            pq = new PQueue(function (a, b) { return pv.naturalOrder(a.count(), b.count()); });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n        function iter(lh, target) {\n            var ncolors = 1,\n                niters = 0,\n                vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count()) { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox),\n                    vbox1 = vboxes[0],\n                    vbox2 = vboxes[1];\n\n                if (!vbox1) {\n                    //                    console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) {  /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n                    //                    console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function (a, b) {\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    };\n})();"]},"metadata":{},"sourceType":"module"}