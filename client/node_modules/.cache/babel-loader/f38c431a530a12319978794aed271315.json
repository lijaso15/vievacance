{"ast":null,"code":"/**\r\n * HeatLegend module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../../core/Container\";\nimport { LinearGradient } from \"../../core/rendering/fills/LinearGradient\";\nimport { registry } from \"../../core/Registry\";\nimport { toColor, Color } from \"../../core/utils/Color\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { ValueAxis } from \"../../charts/axes/ValueAxis\";\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $colors from \"../../core/utils/Colors\";\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * This class creates a link (waved color-filled line) between two nodes in a\r\n * Sankey Diagram.\r\n *\r\n * @see {@link IHeatLegendEvents} for a list of available events\r\n * @see {@link IHeatLegendAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar HeatLegend =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(HeatLegend, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function HeatLegend() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"HeatLegend\";\n    _this.markerContainer = _this.createChild(Container);\n    _this.markerContainer.shouldClone = false;\n    _this.markerCount = 1; // Create a template container and list for the a marker\n\n    var marker = new RoundedRectangle();\n    marker.minHeight = 20;\n    marker.minWidth = 20;\n    marker.interactionsEnabled = false;\n    marker.fillOpacity = 1;\n    marker.cornerRadius(0, 0, 0, 0);\n    _this.markerContainer.minHeight = 20;\n    _this.markerContainer.minWidth = 20;\n    _this.orientation = \"horizontal\";\n    _this.markers = new ListTemplate(marker);\n\n    _this._disposers.push(new ListDisposer(_this.markers));\n\n    _this._disposers.push(_this.markers.template);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  HeatLegend.prototype.getMinFromRules = function (property) {\n    var series = this.series;\n\n    if (series) {\n      var minValue_1;\n      $iter.eachContinue(series.heatRules.iterator(), function (heatRule) {\n        if (heatRule.property == property) {\n          minValue_1 = heatRule.min;\n          return false;\n        }\n\n        return true;\n      });\n      return minValue_1;\n    }\n  };\n\n  HeatLegend.prototype.getMaxFromRules = function (property) {\n    var series = this.series;\n\n    if (series) {\n      var maxValue_1;\n      $iter.each(series.heatRules.iterator(), function (heatRule) {\n        if (heatRule.property == property) {\n          maxValue_1 = heatRule.max;\n          return false;\n        }\n\n        return true;\n      });\n      return maxValue_1;\n    }\n  };\n  /**\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  HeatLegend.prototype.validate = function () {\n    _super.prototype.validate.call(this);\n\n    var series = this.series;\n    var minColor = this.minColor;\n    var maxColor = this.maxColor;\n\n    if (!$type.hasValue(minColor)) {\n      minColor = toColor(this.getMinFromRules(\"fill\"));\n    }\n\n    if (!$type.hasValue(maxColor)) {\n      maxColor = toColor(this.getMaxFromRules(\"fill\"));\n    }\n\n    if (series) {\n      var seriesFill = series.fill;\n\n      if (!$type.hasValue(minColor) && seriesFill instanceof Color) {\n        minColor = seriesFill;\n      }\n\n      if (!$type.hasValue(maxColor) && seriesFill instanceof Color) {\n        maxColor = seriesFill;\n      }\n    }\n\n    if (!$type.hasValue(maxColor)) {\n      maxColor = toColor(this.getMaxFromRules(\"fill\"));\n    }\n\n    var minOpacity = $type.toNumber(this.getMinFromRules(\"fillOpacity\"));\n\n    if (!$type.isNumber(minOpacity)) {\n      minOpacity = 1;\n    }\n\n    var maxOpacity = $type.toNumber(this.getMaxFromRules(\"fillOpacity\"));\n\n    if (!$type.isNumber(maxOpacity)) {\n      maxOpacity = 1;\n    }\n\n    var minStrokeOpacity = $type.toNumber(this.getMinFromRules(\"strokeOpacity\"));\n\n    if (!$type.isNumber(minStrokeOpacity)) {\n      minStrokeOpacity = 1;\n    }\n\n    var maxStrokeOpacity = $type.toNumber(this.getMaxFromRules(\"strokeOpacity\"));\n\n    if (!$type.isNumber(maxStrokeOpacity)) {\n      maxStrokeOpacity = 1;\n    }\n\n    var minStroke = toColor(this.getMinFromRules(\"stroke\"));\n    var maxStroke = toColor(this.getMaxFromRules(\"stroke\")); //if (series) {\n\n    for (var i = 0; i < this.markerCount; i++) {\n      var marker = this.markers.getIndex(i);\n\n      if (!marker) {\n        marker = this.markers.create();\n        marker.parent = this.markerContainer;\n        marker.height = percent(100);\n        marker.width = percent(100);\n      }\n\n      if (this.markerCount == 1) {\n        var gradient = new LinearGradient();\n        gradient.addColor(minColor, minOpacity);\n        gradient.addColor(maxColor, maxOpacity);\n\n        if (this.orientation == \"vertical\") {\n          gradient.rotation = -90;\n        }\n\n        marker.fill = gradient;\n\n        if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\n          var strokeGradient = new LinearGradient();\n          strokeGradient.addColor(minStroke, minStrokeOpacity);\n          strokeGradient.addColor(maxStroke, maxStrokeOpacity);\n\n          if (this.orientation == \"vertical\") {\n            strokeGradient.rotation = -90;\n          }\n\n          marker.stroke = strokeGradient;\n        }\n      } else {\n        var color = new Color($colors.interpolate(minColor.rgb, maxColor.rgb, i / this.markerCount));\n        marker.fill = color;\n        var opacity = minOpacity + (maxOpacity - minOpacity) * i / this.markerCount;\n        marker.fillOpacity = opacity;\n\n        if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\n          var color_1 = new Color($colors.interpolate(minStroke.rgb, maxStroke.rgb, i / this.markerCount));\n          marker.stroke = color_1;\n          var opacity_1 = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * i / this.markerCount;\n          marker.strokeOpacity = opacity_1;\n        }\n      }\n    }\n\n    var renderer = this.valueAxis.renderer;\n\n    if (this.markerCount > 1) {\n      if (this.orientation == \"horizontal\") {\n        renderer.minGridDistance = this.measuredWidth / this.markerCount;\n      } else {\n        renderer.minGridDistance = this.measuredHeight / this.markerCount;\n      }\n    }\n\n    this.valueAxis.invalidate();\n\n    for (var i = this.markerCount, len = this.markers.length; i < len; i++) {\n      this.markers.getIndex(i).parent = undefined;\n    }\n  };\n\n  Object.defineProperty(HeatLegend.prototype, \"minColor\", {\n    /**\r\n     * Returns minColor value\r\n     * @return {Color}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minColor\");\n    },\n\n    /**\r\n     * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.\r\n     *\r\n     * @param {Color}\r\n     */\n    set: function (value) {\n      if (!(value instanceof Color)) {\n        value = toColor(value);\n      }\n\n      this.setColorProperty(\"minColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"maxColor\", {\n    /**\r\n     * Returns maxColor value\r\n     * @return {Color}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxColor\");\n    },\n\n    /**\r\n     * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.\r\n     *\r\n     * @param {Color}\r\n     */\n    set: function (value) {\n      if (!$type.isObject(value)) {\n        value = toColor(value);\n      }\n\n      this.setColorProperty(\"maxColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"markerCount\", {\n    /**\r\n     * Returns number of color squares (markers).\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"markerCount\");\n    },\n\n    /**\r\n     * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"markerCount\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"minValue\", {\n    /**\r\n     * Returns minimum value of heat legend.\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minValue\");\n    },\n\n    /**\r\n     * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"minValue\", value);\n      this.valueAxis.min = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"maxValue\", {\n    /**\r\n     * Returns maximum value of heat legend.\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxValue\");\n    },\n\n    /**\r\n     * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxValue\", value);\n      this.valueAxis.max = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"orientation\", {\n    /**\r\n     * Returns orientation value.\r\n     *\r\n     * @return {\"horizontal\" | \"vertical\"}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"orientation\");\n    },\n\n    /**\r\n    * Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.\r\n    *\r\n    * @param {\"horizontal\" | \"vertical\"}\r\n    */\n    set: function (value) {\n      this.setPropertyValue(\"orientation\", value, true);\n      var markerContainer = this.markerContainer;\n      var valueAxis = this.valueAxis; // HORIZONTAL\n\n      if (value == \"horizontal\") {\n        if (!$type.hasValue(this.width)) {\n          this.width = 200;\n        }\n\n        this.height = undefined;\n        valueAxis.width = percent(100);\n        valueAxis.height = undefined;\n        valueAxis.tooltip.pointerOrientation = \"vertical\";\n        this.layout = \"vertical\";\n        markerContainer.width = percent(100);\n        markerContainer.height = undefined;\n\n        if (!(valueAxis.renderer instanceof AxisRendererX)) {\n          valueAxis.renderer = new AxisRendererX();\n        }\n      } // VERTICAL\n      else {\n          if (!$type.hasValue(this.height)) {\n            this.height = 200;\n          }\n\n          this.width = undefined;\n          this.layout = \"horizontal\";\n          markerContainer.width = undefined;\n          markerContainer.height = percent(100);\n          valueAxis.height = percent(100);\n          valueAxis.width = undefined;\n          valueAxis.tooltip.pointerOrientation = \"horizontal\";\n\n          if (!(valueAxis.renderer instanceof AxisRendererY)) {\n            valueAxis.renderer = new AxisRendererY();\n          }\n\n          valueAxis.renderer.inside = true;\n          valueAxis.renderer.labels.template.inside = true;\n          this.markerContainer.reverseOrder = true;\n        }\n\n      var renderer = valueAxis.renderer;\n      renderer.grid.template.disabled = true;\n      renderer.axisFills.template.disabled = true;\n      renderer.baseGrid.disabled = true;\n      renderer.labels.template.padding(2, 3, 2, 3);\n      renderer.minHeight = undefined;\n      renderer.minWidth = undefined;\n      this.markerContainer.layout = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"valueAxis\", {\n    /**\r\n     * Returns valueAxis value.\r\n     * @return {ValueAxis}\r\n     */\n    get: function () {\n      if (!this._valueAxis) {\n        this.valueAxis = this.createChild(ValueAxis);\n        this.valueAxis.shouldClone = false;\n      }\n\n      return this._valueAxis;\n    },\n\n    /**\r\n     * Sets a value axis of heat legend. Value axis for heat legend is created automatically.\r\n     * @param {ValueAxis}\r\n     */\n    set: function (valueAxis) {\n      this._valueAxis = valueAxis;\n      valueAxis.parent = this;\n      valueAxis.strictMinMax = true;\n      this.orientation = this.orientation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"series\", {\n    /**\r\n     * Returns series value.\r\n     * @return {Series}\r\n     */\n    get: function () {\n      return this._series;\n    },\n\n    /**\r\n     * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.\r\n     * @param series\r\n     */\n    set: function (series) {\n      var _this = this;\n\n      this._series = series;\n      var dataField = \"value\";\n\n      try {\n        var dataFieldDefined = series.heatRules.getIndex(0).dataField;\n\n        if (dataFieldDefined) {\n          dataField = dataFieldDefined;\n        }\n      } catch (err) {}\n\n      this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\n      series.dataItem.events.on(\"calculatedvaluechanged\", function (event) {\n        _this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\n      }, undefined, false);\n      series.heatRules.events.on(\"inserted\", this.invalidate, this, false);\n      series.heatRules.events.on(\"removed\", this.invalidate, this, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates min/max of value axis.\r\n   * @ignore\r\n   */\n\n  HeatLegend.prototype.updateMinMax = function (min, max) {\n    var valueAxis = this.valueAxis;\n\n    if (!$type.isNumber(this.minValue)) {\n      valueAxis.min = min;\n      valueAxis.invalidate();\n    }\n\n    if (!$type.isNumber(this.maxValue)) {\n      valueAxis.max = max;\n      valueAxis.invalidate();\n    }\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  HeatLegend.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up series\n      if ($type.hasValue(config.series) && $type.isString(config.series)) {\n        if ($type.isString(config.series)) {\n          if (this.map.hasKey(config.series)) {\n            config.series = this.map.getKey(config.series);\n          } else {\n            var seriesId_1 = config.series;\n            var disposer_1 = this.map.events.on(\"insertKey\", function (ev) {\n              if (ev.key == seriesId_1) {\n                this.series = ev.newValue;\n                disposer_1.dispose();\n              }\n            }, this);\n\n            this._disposers.push(disposer_1);\n\n            delete config.series;\n          }\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return HeatLegend;\n}(Container);\n\nexport { HeatLegend };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"HeatLegend\"] = HeatLegend;","map":null,"metadata":{},"sourceType":"module"}