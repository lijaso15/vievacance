{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { TargetedEventDispatcher } from \"../utils/EventDispatcher\";\nimport { MultiDisposer, CounterDisposer } from \"../utils/Disposer\";\n/**\r\n * Represents an Event Dispatcher for [[InteractionObject]].\r\n *\r\n * Besides regular [[EventDispatcher]] functionality it adds new events with\r\n * direct application to DOM nodes. Primarily used to handle keyboard events,\r\n * but can turn into something else moving forward.\r\n */\n\nvar InteractionObjectEventDispatcher =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(InteractionObjectEventDispatcher, _super);\n\n  function InteractionObjectEventDispatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Holds a list of Disposers for DOM events added.\r\n     */\n\n\n    _this._domEvents = {};\n    return _this;\n  }\n  /**\r\n   * Adds a DOM event and returns Disposer.\r\n   *\r\n   * @return Disposer\r\n   */\n\n\n  InteractionObjectEventDispatcher.prototype._addDOMEvent = function (type, key, listener, context) {\n    var _this = this;\n\n    if (!this._domEvents[type]) {\n      var callback_1 = function callback_1(e) {\n        listener.call(context, key, e);\n      };\n\n      this.target.element.addEventListener(type, callback_1, false);\n      this._domEvents[type] = new CounterDisposer(function () {\n        delete _this._domEvents[type];\n\n        _this.target.element.removeEventListener(type, callback_1, false);\n      });\n    }\n\n    return this._domEvents[type].increment();\n  };\n\n  InteractionObjectEventDispatcher.prototype._dispatchKeyboardEvent = function (key, ev) {\n    // TODO use this.dispatchImmediately ?\n    if (this.target.events.isEnabled(key)) {\n      this.target.events.dispatchImmediately(key, {\n        type: key,\n        target: this.target,\n        event: ev\n      });\n    }\n  };\n\n  InteractionObjectEventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {\n    var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);\n\n    var disposers = [info.disposer];\n\n    switch (type) {\n      case \"hit\":\n      case \"doublehit\":\n      case \"rightclick\":\n      case \"down\":\n      case \"up\":\n        this.target.clickable = true;\n        break;\n\n      case \"drag\":\n      case \"dragstart\":\n      case \"dragstop\":\n        this.target.draggable = true;\n        break;\n\n      case \"track\":\n        this.target.trackable = true;\n        break;\n\n      case \"resize\":\n        this.target.resizable = true;\n        break;\n\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n        this.target.swipeable = true;\n        break;\n\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        this.target.wheelable = true;\n        break;\n\n      case \"over\":\n      case \"out\":\n        this.target.hoverable = true;\n        break;\n\n      case \"focus\":\n      case \"blur\":\n      case \"focusin\":\n      case \"focusout\":\n        this.target.focusable = true;\n        break;\n\n      case \"keydown\":\n        disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));\n        break;\n\n      case \"keyup\":\n        disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));\n        break;\n\n      case \"keypress\":\n        disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));\n        break;\n\n      case \"input\":\n        disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));\n        break;\n    }\n\n    info.disposer = new MultiDisposer(disposers);\n    return info;\n  };\n\n  return InteractionObjectEventDispatcher;\n}(TargetedEventDispatcher);\n\nexport { InteractionObjectEventDispatcher };","map":null,"metadata":{},"sourceType":"module"}