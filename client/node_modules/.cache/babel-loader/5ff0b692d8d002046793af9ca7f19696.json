{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e(require(\"rgbcolor\"), require(\"stackblur-canvas\")) : \"function\" == typeof define && define.amd ? define([\"rgbcolor\", \"stackblur-canvas\"], e) : t.canvg = e(t.RGBColor, t.StackBlur);\n}(this, function (m, d) {\n  \"use strict\";\n\n  var t;\n  return m = m && m.hasOwnProperty(\"default\") ? m.default : m, d = d && d.hasOwnProperty(\"default\") ? d.default : d, function (t) {\n    var u;\n    t.exports;\n    (u = window).DOMParser = window.DOMParser;\n\n    function p() {\n      return document.createElement(\"canvas\");\n    }\n\n    var f,\n        c = function c(t, e, i) {\n      if (null != t || null != e || null != i) {\n        var n = function (s) {\n          var A = {\n            opts: s,\n            FRAMERATE: 30,\n            MAX_VIRTUAL_PIXELS: 3e4,\n            rootEmSize: 12,\n            emSize: 12,\n            log: function log(t) {}\n          };\n          1 == A.opts.log && \"undefined\" != typeof console && (A.log = function (t) {\n            console.log(t);\n          });\n          A.init = function (t) {\n            var e = 0;\n            A.UniqueId = function () {\n              return \"canvg\" + ++e;\n            }, A.Definitions = {}, A.Styles = {}, A.StylesSpecificity = {}, A.Animations = [], A.Images = [], A.ctx = t, A.ViewPort = new function () {\n              this.viewPorts = [], this.Clear = function () {\n                this.viewPorts = [];\n              }, this.SetCurrent = function (t, e) {\n                this.viewPorts.push({\n                  width: t,\n                  height: e\n                });\n              }, this.RemoveCurrent = function () {\n                this.viewPorts.pop();\n              }, this.Current = function () {\n                return this.viewPorts[this.viewPorts.length - 1];\n              }, this.width = function () {\n                return this.Current().width;\n              }, this.height = function () {\n                return this.Current().height;\n              }, this.ComputeSize = function (t) {\n                return null != t && \"number\" == typeof t ? t : \"x\" == t ? this.width() : \"y\" == t ? this.height() : Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);\n              };\n            }();\n          }, A.init(), A.ImagesLoaded = function () {\n            for (var t = 0; t < A.Images.length; t++) {\n              if (!A.Images[t].loaded) return !1;\n            }\n\n            return !0;\n          }, A.trim = function (t) {\n            return t.replace(/^\\s+|\\s+$/g, \"\");\n          }, A.compressSpaces = function (t) {\n            return t.replace(/(?!\\u3000)\\s+/gm, \" \");\n          }, A.ajax = function (t) {\n            var e;\n            return (e = u.XMLHttpRequest ? new u.XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\")) ? (e.open(\"GET\", t, !1), e.send(null), e.responseText) : null;\n          }, A.parseXml = function (e) {\n            if (\"undefined\" != typeof Windows && void 0 !== Windows.Data && void 0 !== Windows.Data.Xml) {\n              var t = new Windows.Data.Xml.Dom.XmlDocument(),\n                  i = new Windows.Data.Xml.Dom.XmlLoadSettings();\n              return i.prohibitDtd = !1, t.loadXml(e, i), t;\n            }\n\n            if (!u.DOMParser) {\n              e = e.replace(/<!DOCTYPE svg[^>]*>/, \"\");\n              var t = new ActiveXObject(\"Microsoft.XMLDOM\");\n              return t.async = \"false\", t.loadXML(e), t;\n            }\n\n            try {\n              var n = s.xmldom ? new u.DOMParser(s.xmldom) : new u.DOMParser();\n              return n.parseFromString(e, \"image/svg+xml\");\n            } catch (t) {\n              return (n = s.xmldom ? new u.DOMParser(s.xmldom) : new u.DOMParser()).parseFromString(e, \"text/xml\");\n            }\n          }, A.Property = function (t, e) {\n            this.name = t, this.value = e;\n          }, A.Property.prototype.getValue = function () {\n            return this.value;\n          }, A.Property.prototype.hasValue = function () {\n            return null != this.value && \"\" !== this.value;\n          }, A.Property.prototype.numValue = function () {\n            if (!this.hasValue()) return 0;\n            var t = parseFloat(this.value);\n            return (this.value + \"\").match(/%$/) && (t /= 100), t;\n          }, A.Property.prototype.valueOrDefault = function (t) {\n            return this.hasValue() ? this.value : t;\n          }, A.Property.prototype.numValueOrDefault = function (t) {\n            return this.hasValue() ? this.numValue() : t;\n          }, A.Property.prototype.addOpacity = function (t) {\n            var e = this.value;\n\n            if (null != t.value && \"\" != t.value && \"string\" == typeof this.value) {\n              var i = new m(this.value);\n              i.ok && (e = \"rgba(\" + i.r + \", \" + i.g + \", \" + i.b + \", \" + t.numValue() + \")\");\n            }\n\n            return new A.Property(this.name, e);\n          }, A.Property.prototype.getDefinition = function () {\n            var t = this.value.match(/#([^\\)'\"]+)/);\n            return t && (t = t[1]), t || (t = this.value), A.Definitions[t];\n          }, A.Property.prototype.isUrlDefinition = function () {\n            return 0 == this.value.indexOf(\"url(\");\n          }, A.Property.prototype.getFillStyleDefinition = function (t, e) {\n            var i = this.getDefinition();\n            if (null != i && i.createGradient) return i.createGradient(A.ctx, t, e);\n\n            if (null != i && i.createPattern) {\n              if (i.getHrefAttribute().hasValue()) {\n                var n = i.attribute(\"patternTransform\");\n                i = i.getHrefAttribute().getDefinition(), n.hasValue() && (i.attribute(\"patternTransform\", !0).value = n.value);\n              }\n\n              return i.createPattern(A.ctx, t);\n            }\n\n            return null;\n          }, A.Property.prototype.getDPI = function (t) {\n            return 96;\n          }, A.Property.prototype.getREM = function (t) {\n            return A.rootEmSize;\n          }, A.Property.prototype.getEM = function (t) {\n            return A.emSize;\n          }, A.Property.prototype.getUnits = function () {\n            var t = this.value + \"\";\n            return t.replace(/[0-9\\.\\-]/g, \"\");\n          }, A.Property.prototype.isPixels = function () {\n            if (!this.hasValue()) return !1;\n            var t = this.value + \"\";\n            return !!t.match(/px$/) || !!t.match(/^[0-9]+$/);\n          }, A.Property.prototype.toPixels = function (t, e) {\n            if (!this.hasValue()) return 0;\n            var i = this.value + \"\";\n            if (i.match(/rem$/)) return this.numValue() * this.getREM(t);\n            if (i.match(/em$/)) return this.numValue() * this.getEM(t);\n            if (i.match(/ex$/)) return this.numValue() * this.getEM(t) / 2;\n            if (i.match(/px$/)) return this.numValue();\n            if (i.match(/pt$/)) return this.numValue() * this.getDPI(t) * (1 / 72);\n            if (i.match(/pc$/)) return 15 * this.numValue();\n            if (i.match(/cm$/)) return this.numValue() * this.getDPI(t) / 2.54;\n            if (i.match(/mm$/)) return this.numValue() * this.getDPI(t) / 25.4;\n            if (i.match(/in$/)) return this.numValue() * this.getDPI(t);\n            if (i.match(/%$/)) return this.numValue() * A.ViewPort.ComputeSize(t);\n            var n = this.numValue();\n            return e && n < 1 ? n * A.ViewPort.ComputeSize(t) : n;\n          }, A.Property.prototype.toMilliseconds = function () {\n            if (!this.hasValue()) return 0;\n            var t = this.value + \"\";\n            return t.match(/s$/) ? 1e3 * this.numValue() : (t.match(/ms$/), this.numValue());\n          }, A.Property.prototype.toRadians = function () {\n            if (!this.hasValue()) return 0;\n            var t = this.value + \"\";\n            return t.match(/deg$/) ? this.numValue() * (Math.PI / 180) : t.match(/grad$/) ? this.numValue() * (Math.PI / 200) : t.match(/rad$/) ? this.numValue() : this.numValue() * (Math.PI / 180);\n          };\n          var t = {\n            baseline: \"alphabetic\",\n            \"before-edge\": \"top\",\n            \"text-before-edge\": \"top\",\n            middle: \"middle\",\n            central: \"middle\",\n            \"after-edge\": \"bottom\",\n            \"text-after-edge\": \"bottom\",\n            ideographic: \"ideographic\",\n            alphabetic: \"alphabetic\",\n            hanging: \"hanging\",\n            mathematical: \"alphabetic\"\n          };\n          return A.Property.prototype.toTextBaseline = function () {\n            return this.hasValue() ? t[this.value] : null;\n          }, A.Font = new function () {\n            this.Styles = \"normal|italic|oblique|inherit\", this.Variants = \"normal|small-caps|inherit\", this.Weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\", this.CreateFont = function (t, e, i, n, s, a) {\n              var r = null != a ? this.Parse(a) : this.CreateFont(\"\", \"\", \"\", \"\", \"\", A.ctx.font);\n              return {\n                fontFamily: s = s || r.fontFamily,\n                fontSize: n || r.fontSize,\n                fontStyle: t || r.fontStyle,\n                fontWeight: i || r.fontWeight,\n                fontVariant: e || r.fontVariant,\n                toString: function toString() {\n                  return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(\" \");\n                }\n              };\n            };\n            var r = this;\n\n            this.Parse = function (t) {\n              for (var e = {}, i = A.trim(A.compressSpaces(t || \"\")).split(\" \"), n = {\n                fontSize: !1,\n                fontStyle: !1,\n                fontWeight: !1,\n                fontVariant: !1\n              }, s = \"\", a = 0; a < i.length; a++) {\n                n.fontStyle || -1 == r.Styles.indexOf(i[a]) ? n.fontVariant || -1 == r.Variants.indexOf(i[a]) ? n.fontWeight || -1 == r.Weights.indexOf(i[a]) ? n.fontSize ? \"inherit\" != i[a] && (s += i[a]) : (\"inherit\" != i[a] && (e.fontSize = i[a].split(\"/\")[0]), n.fontStyle = n.fontVariant = n.fontWeight = n.fontSize = !0) : (\"inherit\" != i[a] && (e.fontWeight = i[a]), n.fontStyle = n.fontVariant = n.fontWeight = !0) : (\"inherit\" != i[a] && (e.fontVariant = i[a]), n.fontStyle = n.fontVariant = !0) : (\"inherit\" != i[a] && (e.fontStyle = i[a]), n.fontStyle = !0);\n              }\n\n              return \"\" != s && (e.fontFamily = s), e;\n            };\n          }(), A.ToNumberArray = function (t) {\n            for (var e = A.trim(A.compressSpaces((t || \"\").replace(/,/g, \" \"))).split(\" \"), i = 0; i < e.length; i++) {\n              e[i] = parseFloat(e[i]);\n            }\n\n            return e;\n          }, A.Point = function (t, e) {\n            this.x = t, this.y = e;\n          }, A.Point.prototype.angleTo = function (t) {\n            return Math.atan2(t.y - this.y, t.x - this.x);\n          }, A.Point.prototype.applyTransform = function (t) {\n            var e = this.x * t[0] + this.y * t[2] + t[4],\n                i = this.x * t[1] + this.y * t[3] + t[5];\n            this.x = e, this.y = i;\n          }, A.CreatePoint = function (t) {\n            var e = A.ToNumberArray(t);\n            return new A.Point(e[0], e[1]);\n          }, A.CreatePath = function (t) {\n            for (var e = A.ToNumberArray(t), i = [], n = 0; n < e.length; n += 2) {\n              i.push(new A.Point(e[n], e[n + 1]));\n            }\n\n            return i;\n          }, A.BoundingBox = function (t, e, i, n) {\n            this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN, this.x = function () {\n              return this.x1;\n            }, this.y = function () {\n              return this.y1;\n            }, this.width = function () {\n              return this.x2 - this.x1;\n            }, this.height = function () {\n              return this.y2 - this.y1;\n            }, this.addPoint = function (t, e) {\n              null != t && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = t, this.x2 = t), t < this.x1 && (this.x1 = t), t > this.x2 && (this.x2 = t)), null != e && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = e, this.y2 = e), e < this.y1 && (this.y1 = e), e > this.y2 && (this.y2 = e));\n            }, this.addX = function (t) {\n              this.addPoint(t, null);\n            }, this.addY = function (t) {\n              this.addPoint(null, t);\n            }, this.addBoundingBox = function (t) {\n              this.addPoint(t.x1, t.y1), this.addPoint(t.x2, t.y2);\n            }, this.addQuadraticCurve = function (t, e, i, n, s, a) {\n              var r = t + 2 / 3 * (i - t),\n                  o = e + 2 / 3 * (n - e),\n                  l = r + 1 / 3 * (s - t),\n                  h = o + 1 / 3 * (a - e);\n              this.addBezierCurve(t, e, r, l, o, h, s, a);\n            }, this.addBezierCurve = function (t, e, i, n, s, a, r, o) {\n              var l = [t, e],\n                  h = [i, n],\n                  u = [s, a],\n                  c = [r, o];\n              this.addPoint(l[0], l[1]), this.addPoint(c[0], c[1]);\n\n              for (var f = 0; f <= 1; f++) {\n                var m = function m(t) {\n                  return Math.pow(1 - t, 3) * l[f] + 3 * Math.pow(1 - t, 2) * t * h[f] + 3 * (1 - t) * Math.pow(t, 2) * u[f] + Math.pow(t, 3) * c[f];\n                },\n                    p = 6 * l[f] - 12 * h[f] + 6 * u[f],\n                    d = -3 * l[f] + 9 * h[f] - 9 * u[f] + 3 * c[f],\n                    y = 3 * h[f] - 3 * l[f];\n\n                if (0 != d) {\n                  var v = Math.pow(p, 2) - 4 * y * d;\n\n                  if (!(v < 0)) {\n                    var g = (-p + Math.sqrt(v)) / (2 * d);\n                    0 < g && g < 1 && (0 == f && this.addX(m(g)), 1 == f && this.addY(m(g)));\n                    var x = (-p - Math.sqrt(v)) / (2 * d);\n                    0 < x && x < 1 && (0 == f && this.addX(m(x)), 1 == f && this.addY(m(x)));\n                  }\n                } else {\n                  if (0 == p) continue;\n                  var b = -y / p;\n                  0 < b && b < 1 && (0 == f && this.addX(m(b)), 1 == f && this.addY(m(b)));\n                }\n              }\n            }, this.isPointInBox = function (t, e) {\n              return this.x1 <= t && t <= this.x2 && this.y1 <= e && e <= this.y2;\n            }, this.addPoint(t, e), this.addPoint(i, n);\n          }, A.Transform = function (t) {\n            var e = this;\n            this.Type = {}, this.Type.translate = function (t) {\n              this.p = A.CreatePoint(t), this.apply = function (t) {\n                t.translate(this.p.x || 0, this.p.y || 0);\n              }, this.unapply = function (t) {\n                t.translate(-1 * this.p.x || 0, -1 * this.p.y || 0);\n              }, this.applyToPoint = function (t) {\n                t.applyTransform([1, 0, 0, 1, this.p.x || 0, this.p.y || 0]);\n              };\n            }, this.Type.rotate = function (t) {\n              var e = A.ToNumberArray(t);\n              this.angle = new A.Property(\"angle\", e[0]), this.cx = e[1] || 0, this.cy = e[2] || 0, this.apply = function (t) {\n                t.translate(this.cx, this.cy), t.rotate(this.angle.toRadians()), t.translate(-this.cx, -this.cy);\n              }, this.unapply = function (t) {\n                t.translate(this.cx, this.cy), t.rotate(-1 * this.angle.toRadians()), t.translate(-this.cx, -this.cy);\n              }, this.applyToPoint = function (t) {\n                var e = this.angle.toRadians();\n                t.applyTransform([1, 0, 0, 1, this.p.x || 0, this.p.y || 0]), t.applyTransform([Math.cos(e), Math.sin(e), -Math.sin(e), Math.cos(e), 0, 0]), t.applyTransform([1, 0, 0, 1, -this.p.x || 0, -this.p.y || 0]);\n              };\n            }, this.Type.scale = function (t) {\n              this.p = A.CreatePoint(t), this.apply = function (t) {\n                t.scale(this.p.x || 1, this.p.y || this.p.x || 1);\n              }, this.unapply = function (t) {\n                t.scale(1 / this.p.x || 1, 1 / this.p.y || this.p.x || 1);\n              }, this.applyToPoint = function (t) {\n                t.applyTransform([this.p.x || 0, 0, 0, this.p.y || 0, 0, 0]);\n              };\n            }, this.Type.matrix = function (t) {\n              this.m = A.ToNumberArray(t), this.apply = function (t) {\n                t.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);\n              }, this.unapply = function (t) {\n                var e = this.m[0],\n                    i = this.m[2],\n                    n = this.m[4],\n                    s = this.m[1],\n                    a = this.m[3],\n                    r = this.m[5],\n                    o = 1 / (e * (1 * a - 0 * r) - i * (1 * s - 0 * r) + n * (0 * s - 0 * a));\n                t.transform(o * (1 * a - 0 * r), o * (0 * r - 1 * s), o * (0 * n - 1 * i), o * (1 * e - 0 * n), o * (i * r - n * a), o * (n * s - e * r));\n              }, this.applyToPoint = function (t) {\n                t.applyTransform(this.m);\n              };\n            }, this.Type.SkewBase = function (t) {\n              this.base = e.Type.matrix, this.base(t), this.angle = new A.Property(\"angle\", t);\n            }, this.Type.SkewBase.prototype = new this.Type.matrix(), this.Type.skewX = function (t) {\n              this.base = e.Type.SkewBase, this.base(t), this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];\n            }, this.Type.skewX.prototype = new this.Type.SkewBase(), this.Type.skewY = function (t) {\n              this.base = e.Type.SkewBase, this.base(t), this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];\n            }, this.Type.skewY.prototype = new this.Type.SkewBase(), this.transforms = [], this.apply = function (t) {\n              for (var e = 0; e < this.transforms.length; e++) {\n                this.transforms[e].apply(t);\n              }\n            }, this.unapply = function (t) {\n              for (var e = this.transforms.length - 1; 0 <= e; e--) {\n                this.transforms[e].unapply(t);\n              }\n            }, this.applyToPoint = function (t) {\n              for (var e = 0; e < this.transforms.length; e++) {\n                this.transforms[e].applyToPoint(t);\n              }\n            };\n\n            for (var i = A.trim(A.compressSpaces(t)).replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/), n = 0; n < i.length; n++) {\n              if (\"none\" !== i[n]) {\n                var s = A.trim(i[n].split(\"(\")[0]),\n                    a = i[n].split(\"(\")[1].replace(\")\", \"\"),\n                    r = this.Type[s];\n\n                if (void 0 !== r) {\n                  var o = new r(a);\n                  o.type = s, this.transforms.push(o);\n                }\n              }\n            }\n          }, A.AspectRatio = function (t, e, i, n, s, a, r, o, l, h) {\n            var u = (e = (e = A.compressSpaces(e)).replace(/^defer\\s/, \"\")).split(\" \")[0] || \"xMidYMid\",\n                c = e.split(\" \")[1] || \"meet\",\n                f = i / n,\n                m = s / a,\n                p = Math.min(f, m),\n                d = Math.max(f, m);\n            \"meet\" == c && (n *= p, a *= p), \"slice\" == c && (n *= d, a *= d), l = new A.Property(\"refX\", l), h = new A.Property(\"refY\", h), l.hasValue() && h.hasValue() ? t.translate(-p * l.toPixels(\"x\"), -p * h.toPixels(\"y\")) : (u.match(/^xMid/) && (\"meet\" == c && p == m || \"slice\" == c && d == m) && t.translate(i / 2 - n / 2, 0), u.match(/YMid$/) && (\"meet\" == c && p == f || \"slice\" == c && d == f) && t.translate(0, s / 2 - a / 2), u.match(/^xMax/) && (\"meet\" == c && p == m || \"slice\" == c && d == m) && t.translate(i - n, 0), u.match(/YMax$/) && (\"meet\" == c && p == f || \"slice\" == c && d == f) && t.translate(0, s - a)), \"none\" == u ? t.scale(f, m) : \"meet\" == c ? t.scale(p, p) : \"slice\" == c && t.scale(d, d), t.translate(null == r ? 0 : -r, null == o ? 0 : -o);\n          }, A.Element = {}, A.EmptyProperty = new A.Property(\"EMPTY\", \"\"), A.Element.ElementBase = function (a) {\n            this.attributes = {}, this.styles = {}, this.stylesSpecificity = {}, this.children = [], this.attribute = function (t, e) {\n              var i = this.attributes[t];\n              return null != i ? i : (1 == e && (i = new A.Property(t, \"\"), this.attributes[t] = i), i || A.EmptyProperty);\n            }, this.getHrefAttribute = function () {\n              for (var t in this.attributes) {\n                if (\"href\" == t || t.match(/:href$/)) return this.attributes[t];\n              }\n\n              return A.EmptyProperty;\n            }, this.style = function (t, e, i) {\n              var n = this.styles[t];\n              if (null != n) return n;\n              var s = this.attribute(t);\n              if (null != s && s.hasValue()) return this.styles[t] = s;\n\n              if (1 != i) {\n                var a = this.parent;\n\n                if (null != a) {\n                  var r = a.style(t);\n                  if (null != r && r.hasValue()) return r;\n                }\n              }\n\n              return 1 == e && (n = new A.Property(t, \"\"), this.styles[t] = n), n || A.EmptyProperty;\n            }, this.render = function (t) {\n              if (\"none\" != this.style(\"display\").value && \"hidden\" != this.style(\"visibility\").value) {\n                if (t.save(), this.style(\"mask\").hasValue()) {\n                  var e = this.style(\"mask\").getDefinition();\n                  null != e && e.apply(t, this);\n                } else if (this.style(\"filter\").hasValue()) {\n                  var i = this.style(\"filter\").getDefinition();\n                  null != i && i.apply(t, this);\n                } else this.setContext(t), this.renderChildren(t), this.clearContext(t);\n\n                t.restore();\n              }\n            }, this.setContext = function (t) {}, this.clearContext = function (t) {}, this.renderChildren = function (t) {\n              for (var e = 0; e < this.children.length; e++) {\n                this.children[e].render(t);\n              }\n            }, this.addChild = function (t, e) {\n              var i = t;\n              e && (i = A.CreateElement(t)), i.parent = this, \"title\" != i.type && this.children.push(i);\n            }, this.addStylesFromStyleDefinition = function () {\n              for (var t in A.Styles) {\n                if (\"@\" != t[0] && f(a, t)) {\n                  var e = A.Styles[t],\n                      i = A.StylesSpecificity[t];\n                  if (null != e) for (var n in e) {\n                    var s = this.stylesSpecificity[n];\n                    void 0 === s && (s = \"000\"), s < i && (this.styles[n] = e[n], this.stylesSpecificity[n] = i);\n                  }\n                }\n              }\n            };\n            var t,\n                e = new RegExp(\"^[A-Z-]+$\");\n\n            if (null != a && 1 == a.nodeType) {\n              for (var i = 0; i < a.attributes.length; i++) {\n                var n = a.attributes[i],\n                    s = (t = n.nodeName, e.test(t) ? t.toLowerCase() : t);\n                this.attributes[s] = new A.Property(s, n.value);\n              }\n\n              if (this.addStylesFromStyleDefinition(), this.attribute(\"style\").hasValue()) {\n                var r = this.attribute(\"style\").value.split(\";\");\n\n                for (i = 0; i < r.length; i++) {\n                  if (\"\" != A.trim(r[i])) {\n                    var o = r[i].split(\":\"),\n                        l = A.trim(o[0]),\n                        h = A.trim(o[1]);\n                    this.styles[l] = new A.Property(l, h);\n                  }\n                }\n              }\n\n              for (this.attribute(\"id\").hasValue() && null == A.Definitions[this.attribute(\"id\").value] && (A.Definitions[this.attribute(\"id\").value] = this), i = 0; i < a.childNodes.length; i++) {\n                var u = a.childNodes[i];\n\n                if (1 == u.nodeType && this.addChild(u, !0), this.captureTextNodes && (3 == u.nodeType || 4 == u.nodeType)) {\n                  var c = u.value || u.text || u.textContent || \"\";\n                  \"\" != A.compressSpaces(c) && this.addChild(new A.Element.tspan(u), !1);\n                }\n              }\n            }\n          }, A.Element.RenderedElementBase = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.calculateOpacity = function () {\n              for (var t = 1, e = this; null != e;) {\n                var i = e.style(\"opacity\", !1, !0);\n                i.hasValue() && (t *= i.numValue()), e = e.parent;\n              }\n\n              return t;\n            }, this.setContext = function (t, e) {\n              if (!e) {\n                var i;\n                if (this.style(\"fill\").isUrlDefinition()) null != (i = this.style(\"fill\").getFillStyleDefinition(this, this.style(\"fill-opacity\"))) && (t.fillStyle = i);else if (this.style(\"fill\").hasValue()) {\n                  var n;\n                  \"currentColor\" == (n = this.style(\"fill\")).value && (n.value = this.style(\"color\").value), \"inherit\" != n.value && (t.fillStyle = \"none\" == n.value ? \"rgba(0,0,0,0)\" : n.value);\n                }\n                if (this.style(\"fill-opacity\").hasValue() && (n = (n = new A.Property(\"fill\", t.fillStyle)).addOpacity(this.style(\"fill-opacity\")), t.fillStyle = n.value), this.style(\"stroke\").isUrlDefinition()) null != (i = this.style(\"stroke\").getFillStyleDefinition(this, this.style(\"stroke-opacity\"))) && (t.strokeStyle = i);else if (this.style(\"stroke\").hasValue()) {\n                  var s;\n                  \"currentColor\" == (s = this.style(\"stroke\")).value && (s.value = this.style(\"color\").value), \"inherit\" != s.value && (t.strokeStyle = \"none\" == s.value ? \"rgba(0,0,0,0)\" : s.value);\n                }\n\n                if (this.style(\"stroke-opacity\").hasValue() && (s = (s = new A.Property(\"stroke\", t.strokeStyle)).addOpacity(this.style(\"stroke-opacity\")), t.strokeStyle = s.value), this.style(\"stroke-width\").hasValue()) {\n                  var a = this.style(\"stroke-width\").toPixels();\n                  t.lineWidth = 0 == a ? .001 : a;\n                }\n\n                if (this.style(\"stroke-linecap\").hasValue() && (t.lineCap = this.style(\"stroke-linecap\").value), this.style(\"stroke-linejoin\").hasValue() && (t.lineJoin = this.style(\"stroke-linejoin\").value), this.style(\"stroke-miterlimit\").hasValue() && (t.miterLimit = this.style(\"stroke-miterlimit\").value), this.style(\"paint-order\").hasValue() && (t.paintOrder = this.style(\"paint-order\").value), this.style(\"stroke-dasharray\").hasValue() && \"none\" != this.style(\"stroke-dasharray\").value) {\n                  var r = A.ToNumberArray(this.style(\"stroke-dasharray\").value);\n                  void 0 !== t.setLineDash ? t.setLineDash(r) : void 0 !== t.webkitLineDash ? t.webkitLineDash = r : void 0 === t.mozDash || 1 == r.length && 0 == r[0] || (t.mozDash = r);\n                  var o = this.style(\"stroke-dashoffset\").toPixels();\n                  void 0 !== t.lineDashOffset ? t.lineDashOffset = o : void 0 !== t.webkitLineDashOffset ? t.webkitLineDashOffset = o : void 0 !== t.mozDashOffset && (t.mozDashOffset = o);\n                }\n              }\n\n              if (void 0 !== t.font) {\n                t.font = A.Font.CreateFont(this.style(\"font-style\").value, this.style(\"font-variant\").value, this.style(\"font-weight\").value, this.style(\"font-size\").hasValue() ? this.style(\"font-size\").toPixels() + \"px\" : \"\", this.style(\"font-family\").value).toString();\n                var l = this.style(\"font-size\", !1, !1);\n                l.isPixels() && (A.emSize = l.toPixels());\n              }\n\n              if (this.style(\"transform\", !1, !0).hasValue() && new A.Transform(this.style(\"transform\", !1, !0).value).apply(t), this.style(\"clip-path\", !1, !0).hasValue()) {\n                var h = this.style(\"clip-path\", !1, !0).getDefinition();\n                null != h && h.apply(t);\n              }\n\n              t.globalAlpha = this.calculateOpacity();\n            };\n          }, A.Element.RenderedElementBase.prototype = new A.Element.ElementBase(), A.Element.PathElementBase = function (t) {\n            this.base = A.Element.RenderedElementBase, this.base(t), this.path = function (t) {\n              return null != t && t.beginPath(), new A.BoundingBox();\n            }, this.renderChildren = function (t) {\n              this.path(t), A.Mouse.checkPath(this, t), \"\" != t.fillStyle && (\"inherit\" != this.style(\"fill-rule\").valueOrDefault(\"inherit\") ? t.fill(this.style(\"fill-rule\").value) : t.fill()), \"\" != t.strokeStyle && t.stroke();\n              var e = this.getMarkers();\n\n              if (null != e) {\n                if (this.style(\"marker-start\").isUrlDefinition() && (i = this.style(\"marker-start\").getDefinition()).render(t, e[0][0], e[0][1]), this.style(\"marker-mid\").isUrlDefinition()) for (var i = this.style(\"marker-mid\").getDefinition(), n = 1; n < e.length - 1; n++) {\n                  i.render(t, e[n][0], e[n][1]);\n                }\n                this.style(\"marker-end\").isUrlDefinition() && (i = this.style(\"marker-end\").getDefinition()).render(t, e[e.length - 1][0], e[e.length - 1][1]);\n              }\n            }, this.getBoundingBox = function () {\n              return this.path();\n            }, this.getMarkers = function () {\n              return null;\n            };\n          }, A.Element.PathElementBase.prototype = new A.Element.RenderedElementBase(), A.Element.svg = function (t) {\n            this.base = A.Element.RenderedElementBase, this.base(t), this.baseClearContext = this.clearContext, this.clearContext = function (t) {\n              this.baseClearContext(t), A.ViewPort.RemoveCurrent();\n            }, this.baseSetContext = this.setContext, this.setContext = function (t) {\n              if (t.strokeStyle = \"rgba(0,0,0,0)\", t.lineCap = \"butt\", t.lineJoin = \"miter\", t.miterLimit = 4, t.canvas.style && void 0 !== t.font && void 0 !== u.getComputedStyle) {\n                t.font = u.getComputedStyle(t.canvas).getPropertyValue(\"font\");\n                var e = new A.Property(\"fontSize\", A.Font.Parse(t.font).fontSize);\n                e.hasValue() && (A.rootEmSize = A.emSize = e.toPixels(\"y\"));\n              }\n\n              this.baseSetContext(t), this.attribute(\"x\").hasValue() || (this.attribute(\"x\", !0).value = 0), this.attribute(\"y\").hasValue() || (this.attribute(\"y\", !0).value = 0), t.translate(this.attribute(\"x\").toPixels(\"x\"), this.attribute(\"y\").toPixels(\"y\"));\n              var i = A.ViewPort.width(),\n                  n = A.ViewPort.height();\n\n              if (this.attribute(\"width\").hasValue() || (this.attribute(\"width\", !0).value = \"100%\"), this.attribute(\"height\").hasValue() || (this.attribute(\"height\", !0).value = \"100%\"), void 0 === this.root) {\n                i = this.attribute(\"width\").toPixels(\"x\"), n = this.attribute(\"height\").toPixels(\"y\");\n                var s = 0,\n                    a = 0;\n                this.attribute(\"refX\").hasValue() && this.attribute(\"refY\").hasValue() && (s = -this.attribute(\"refX\").toPixels(\"x\"), a = -this.attribute(\"refY\").toPixels(\"y\")), \"visible\" != this.attribute(\"overflow\").valueOrDefault(\"hidden\") && (t.beginPath(), t.moveTo(s, a), t.lineTo(i, a), t.lineTo(i, n), t.lineTo(s, n), t.closePath(), t.clip());\n              }\n\n              if (A.ViewPort.SetCurrent(i, n), this.attribute(\"viewBox\").hasValue()) {\n                var r = A.ToNumberArray(this.attribute(\"viewBox\").value),\n                    o = r[0],\n                    l = r[1];\n                i = r[2], n = r[3], A.AspectRatio(t, this.attribute(\"preserveAspectRatio\").value, A.ViewPort.width(), i, A.ViewPort.height(), n, o, l, this.attribute(\"refX\").value, this.attribute(\"refY\").value), A.ViewPort.RemoveCurrent(), A.ViewPort.SetCurrent(r[2], r[3]);\n              }\n            };\n          }, A.Element.svg.prototype = new A.Element.RenderedElementBase(), A.Element.rect = function (t) {\n            this.base = A.Element.PathElementBase, this.base(t), this.path = function (t) {\n              var e = this.attribute(\"x\").toPixels(\"x\"),\n                  i = this.attribute(\"y\").toPixels(\"y\"),\n                  n = this.attribute(\"width\").toPixels(\"x\"),\n                  s = this.attribute(\"height\").toPixels(\"y\"),\n                  a = this.attribute(\"rx\").toPixels(\"x\"),\n                  r = this.attribute(\"ry\").toPixels(\"y\");\n\n              if (this.attribute(\"rx\").hasValue() && !this.attribute(\"ry\").hasValue() && (r = a), this.attribute(\"ry\").hasValue() && !this.attribute(\"rx\").hasValue() && (a = r), a = Math.min(a, n / 2), r = Math.min(r, s / 2), null != t) {\n                var o = (Math.sqrt(2) - 1) / 3 * 4;\n                t.beginPath(), t.moveTo(e + a, i), t.lineTo(e + n - a, i), t.bezierCurveTo(e + n - a + o * a, i, e + n, i + r - o * r, e + n, i + r), t.lineTo(e + n, i + s - r), t.bezierCurveTo(e + n, i + s - r + o * r, e + n - a + o * a, i + s, e + n - a, i + s), t.lineTo(e + a, i + s), t.bezierCurveTo(e + a - o * a, i + s, e, i + s - r + o * r, e, i + s - r), t.lineTo(e, i + r), t.bezierCurveTo(e, i + r - o * r, e + a - o * a, i, e + a, i), t.closePath();\n              }\n\n              return new A.BoundingBox(e, i, e + n, i + s);\n            };\n          }, A.Element.rect.prototype = new A.Element.PathElementBase(), A.Element.circle = function (t) {\n            this.base = A.Element.PathElementBase, this.base(t), this.path = function (t) {\n              var e = this.attribute(\"cx\").toPixels(\"x\"),\n                  i = this.attribute(\"cy\").toPixels(\"y\"),\n                  n = this.attribute(\"r\").toPixels();\n              return null != t && (t.beginPath(), t.arc(e, i, n, 0, 2 * Math.PI, !1), t.closePath()), new A.BoundingBox(e - n, i - n, e + n, i + n);\n            };\n          }, A.Element.circle.prototype = new A.Element.PathElementBase(), A.Element.ellipse = function (t) {\n            this.base = A.Element.PathElementBase, this.base(t), this.path = function (t) {\n              var e = (Math.sqrt(2) - 1) / 3 * 4,\n                  i = this.attribute(\"rx\").toPixels(\"x\"),\n                  n = this.attribute(\"ry\").toPixels(\"y\"),\n                  s = this.attribute(\"cx\").toPixels(\"x\"),\n                  a = this.attribute(\"cy\").toPixels(\"y\");\n              return null != t && (t.beginPath(), t.moveTo(s + i, a), t.bezierCurveTo(s + i, a + e * n, s + e * i, a + n, s, a + n), t.bezierCurveTo(s - e * i, a + n, s - i, a + e * n, s - i, a), t.bezierCurveTo(s - i, a - e * n, s - e * i, a - n, s, a - n), t.bezierCurveTo(s + e * i, a - n, s + i, a - e * n, s + i, a), t.closePath()), new A.BoundingBox(s - i, a - n, s + i, a + n);\n            };\n          }, A.Element.ellipse.prototype = new A.Element.PathElementBase(), A.Element.line = function (t) {\n            this.base = A.Element.PathElementBase, this.base(t), this.getPoints = function () {\n              return [new A.Point(this.attribute(\"x1\").toPixels(\"x\"), this.attribute(\"y1\").toPixels(\"y\")), new A.Point(this.attribute(\"x2\").toPixels(\"x\"), this.attribute(\"y2\").toPixels(\"y\"))];\n            }, this.path = function (t) {\n              var e = this.getPoints();\n              return null != t && (t.beginPath(), t.moveTo(e[0].x, e[0].y), t.lineTo(e[1].x, e[1].y)), new A.BoundingBox(e[0].x, e[0].y, e[1].x, e[1].y);\n            }, this.getMarkers = function () {\n              var t = this.getPoints(),\n                  e = t[0].angleTo(t[1]);\n              return [[t[0], e], [t[1], e]];\n            };\n          }, A.Element.line.prototype = new A.Element.PathElementBase(), A.Element.polyline = function (t) {\n            this.base = A.Element.PathElementBase, this.base(t), this.points = A.CreatePath(this.attribute(\"points\").value), this.path = function (t) {\n              var e = new A.BoundingBox(this.points[0].x, this.points[0].y);\n              null != t && (t.beginPath(), t.moveTo(this.points[0].x, this.points[0].y));\n\n              for (var i = 1; i < this.points.length; i++) {\n                e.addPoint(this.points[i].x, this.points[i].y), null != t && t.lineTo(this.points[i].x, this.points[i].y);\n              }\n\n              return e;\n            }, this.getMarkers = function () {\n              for (var t = [], e = 0; e < this.points.length - 1; e++) {\n                t.push([this.points[e], this.points[e].angleTo(this.points[e + 1])]);\n              }\n\n              return 0 < t.length && t.push([this.points[this.points.length - 1], t[t.length - 1][1]]), t;\n            };\n          }, A.Element.polyline.prototype = new A.Element.PathElementBase(), A.Element.polygon = function (t) {\n            this.base = A.Element.polyline, this.base(t), this.basePath = this.path, this.path = function (t) {\n              var e = this.basePath(t);\n              return null != t && (t.lineTo(this.points[0].x, this.points[0].y), t.closePath()), e;\n            };\n          }, A.Element.polygon.prototype = new A.Element.polyline(), A.Element.path = function (t) {\n            this.base = A.Element.PathElementBase, this.base(t);\n            var e = this.attribute(\"d\").value;\n            e = e.replace(/,/gm, \" \");\n\n            for (var i = 0; i < 2; i++) {\n              e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\\s])/gm, \"$1 $2\");\n            }\n\n            for (e = (e = e.replace(/([^\\s])([MmZzLlHhVvCcSsQqTtAa])/gm, \"$1 $2\")).replace(/([0-9])([+\\-])/gm, \"$1 $2\"), i = 0; i < 2; i++) {\n              e = e.replace(/(\\.[0-9]*)(\\.)/gm, \"$1 $2\");\n            }\n\n            e = e.replace(/([Aa](\\s+[0-9]+){3})\\s+([01])\\s*([01])/gm, \"$1 $3 $4 \"), e = A.compressSpaces(e), e = A.trim(e), this.PathParser = new function (t) {\n              this.tokens = t.split(\" \"), this.reset = function () {\n                this.i = -1, this.command = \"\", this.previousCommand = \"\", this.start = new A.Point(0, 0), this.control = new A.Point(0, 0), this.current = new A.Point(0, 0), this.points = [], this.angles = [];\n              }, this.isEnd = function () {\n                return this.i >= this.tokens.length - 1;\n              }, this.isCommandOrEnd = function () {\n                return !!this.isEnd() || null != this.tokens[this.i + 1].match(/^[A-Za-z]$/);\n              }, this.isRelativeCommand = function () {\n                switch (this.command) {\n                  case \"m\":\n                  case \"l\":\n                  case \"h\":\n                  case \"v\":\n                  case \"c\":\n                  case \"s\":\n                  case \"q\":\n                  case \"t\":\n                  case \"a\":\n                  case \"z\":\n                    return !0;\n                }\n\n                return !1;\n              }, this.getToken = function () {\n                return this.i++, this.tokens[this.i];\n              }, this.getScalar = function () {\n                return parseFloat(this.getToken());\n              }, this.nextCommand = function () {\n                this.previousCommand = this.command, this.command = this.getToken();\n              }, this.getPoint = function () {\n                var t = new A.Point(this.getScalar(), this.getScalar());\n                return this.makeAbsolute(t);\n              }, this.getAsControlPoint = function () {\n                var t = this.getPoint();\n                return this.control = t;\n              }, this.getAsCurrentPoint = function () {\n                var t = this.getPoint();\n                return this.current = t;\n              }, this.getReflectedControlPoint = function () {\n                return \"c\" != this.previousCommand.toLowerCase() && \"s\" != this.previousCommand.toLowerCase() && \"q\" != this.previousCommand.toLowerCase() && \"t\" != this.previousCommand.toLowerCase() ? this.current : new A.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);\n              }, this.makeAbsolute = function (t) {\n                return this.isRelativeCommand() && (t.x += this.current.x, t.y += this.current.y), t;\n              }, this.addMarker = function (t, e, i) {\n                null != i && 0 < this.angles.length && null == this.angles[this.angles.length - 1] && (this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(i)), this.addMarkerAngle(t, null == e ? null : e.angleTo(t));\n              }, this.addMarkerAngle = function (t, e) {\n                this.points.push(t), this.angles.push(e);\n              }, this.getMarkerPoints = function () {\n                return this.points;\n              }, this.getMarkerAngles = function () {\n                for (var t = 0; t < this.angles.length; t++) {\n                  if (null == this.angles[t]) for (var e = t + 1; e < this.angles.length; e++) {\n                    if (null != this.angles[e]) {\n                      this.angles[t] = this.angles[e];\n                      break;\n                    }\n                  }\n                }\n\n                return this.angles;\n              };\n            }(e), this.path = function (t) {\n              var e = this.PathParser;\n              e.reset();\n              var i = new A.BoundingBox();\n\n              for (null != t && t.beginPath(); !e.isEnd();) {\n                switch (e.nextCommand(), e.command) {\n                  case \"M\":\n                  case \"m\":\n                    var n = e.getAsCurrentPoint();\n\n                    for (e.addMarker(n), i.addPoint(n.x, n.y), null != t && t.moveTo(n.x, n.y), e.start = e.current; !e.isCommandOrEnd();) {\n                      n = e.getAsCurrentPoint(), e.addMarker(n, e.start), i.addPoint(n.x, n.y), null != t && t.lineTo(n.x, n.y);\n                    }\n\n                    break;\n\n                  case \"L\":\n                  case \"l\":\n                    for (; !e.isCommandOrEnd();) {\n                      var s = e.current;\n                      n = e.getAsCurrentPoint(), e.addMarker(n, s), i.addPoint(n.x, n.y), null != t && t.lineTo(n.x, n.y);\n                    }\n\n                    break;\n\n                  case \"H\":\n                  case \"h\":\n                    for (; !e.isCommandOrEnd();) {\n                      var a = new A.Point((e.isRelativeCommand() ? e.current.x : 0) + e.getScalar(), e.current.y);\n                      e.addMarker(a, e.current), e.current = a, i.addPoint(e.current.x, e.current.y), null != t && t.lineTo(e.current.x, e.current.y);\n                    }\n\n                    break;\n\n                  case \"V\":\n                  case \"v\":\n                    for (; !e.isCommandOrEnd();) {\n                      a = new A.Point(e.current.x, (e.isRelativeCommand() ? e.current.y : 0) + e.getScalar()), e.addMarker(a, e.current), e.current = a, i.addPoint(e.current.x, e.current.y), null != t && t.lineTo(e.current.x, e.current.y);\n                    }\n\n                    break;\n\n                  case \"C\":\n                  case \"c\":\n                    for (; !e.isCommandOrEnd();) {\n                      var r = e.current,\n                          o = e.getPoint(),\n                          l = e.getAsControlPoint(),\n                          h = e.getAsCurrentPoint();\n                      e.addMarker(h, l, o), i.addBezierCurve(r.x, r.y, o.x, o.y, l.x, l.y, h.x, h.y), null != t && t.bezierCurveTo(o.x, o.y, l.x, l.y, h.x, h.y);\n                    }\n\n                    break;\n\n                  case \"S\":\n                  case \"s\":\n                    for (; !e.isCommandOrEnd();) {\n                      r = e.current, o = e.getReflectedControlPoint(), l = e.getAsControlPoint(), h = e.getAsCurrentPoint(), e.addMarker(h, l, o), i.addBezierCurve(r.x, r.y, o.x, o.y, l.x, l.y, h.x, h.y), null != t && t.bezierCurveTo(o.x, o.y, l.x, l.y, h.x, h.y);\n                    }\n\n                    break;\n\n                  case \"Q\":\n                  case \"q\":\n                    for (; !e.isCommandOrEnd();) {\n                      r = e.current, l = e.getAsControlPoint(), h = e.getAsCurrentPoint(), e.addMarker(h, l, l), i.addQuadraticCurve(r.x, r.y, l.x, l.y, h.x, h.y), null != t && t.quadraticCurveTo(l.x, l.y, h.x, h.y);\n                    }\n\n                    break;\n\n                  case \"T\":\n                  case \"t\":\n                    for (; !e.isCommandOrEnd();) {\n                      r = e.current, l = e.getReflectedControlPoint(), e.control = l, h = e.getAsCurrentPoint(), e.addMarker(h, l, l), i.addQuadraticCurve(r.x, r.y, l.x, l.y, h.x, h.y), null != t && t.quadraticCurveTo(l.x, l.y, h.x, h.y);\n                    }\n\n                    break;\n\n                  case \"A\":\n                  case \"a\":\n                    for (; !e.isCommandOrEnd();) {\n                      r = e.current;\n                      var u = e.getScalar(),\n                          c = e.getScalar(),\n                          f = e.getScalar() * (Math.PI / 180),\n                          m = e.getScalar(),\n                          p = e.getScalar(),\n                          d = (h = e.getAsCurrentPoint(), new A.Point(Math.cos(f) * (r.x - h.x) / 2 + Math.sin(f) * (r.y - h.y) / 2, -Math.sin(f) * (r.x - h.x) / 2 + Math.cos(f) * (r.y - h.y) / 2)),\n                          y = Math.pow(d.x, 2) / Math.pow(u, 2) + Math.pow(d.y, 2) / Math.pow(c, 2);\n                      1 < y && (u *= Math.sqrt(y), c *= Math.sqrt(y));\n                      var v = (m == p ? -1 : 1) * Math.sqrt((Math.pow(u, 2) * Math.pow(c, 2) - Math.pow(u, 2) * Math.pow(d.y, 2) - Math.pow(c, 2) * Math.pow(d.x, 2)) / (Math.pow(u, 2) * Math.pow(d.y, 2) + Math.pow(c, 2) * Math.pow(d.x, 2)));\n                      isNaN(v) && (v = 0);\n\n                      var g = new A.Point(v * u * d.y / c, v * -c * d.x / u),\n                          x = new A.Point((r.x + h.x) / 2 + Math.cos(f) * g.x - Math.sin(f) * g.y, (r.y + h.y) / 2 + Math.sin(f) * g.x + Math.cos(f) * g.y),\n                          b = function b(t) {\n                        return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2));\n                      },\n                          P = function P(t, e) {\n                        return (t[0] * e[0] + t[1] * e[1]) / (b(t) * b(e));\n                      },\n                          E = function E(t, e) {\n                        return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(P(t, e));\n                      },\n                          w = E([1, 0], [(d.x - g.x) / u, (d.y - g.y) / c]),\n                          B = [(d.x - g.x) / u, (d.y - g.y) / c],\n                          C = [(-d.x - g.x) / u, (-d.y - g.y) / c],\n                          T = E(B, C);\n\n                      P(B, C) <= -1 && (T = Math.PI), 1 <= P(B, C) && (T = 0);\n                      var V = 1 - p ? 1 : -1,\n                          M = w + V * (T / 2),\n                          S = new A.Point(x.x + u * Math.cos(M), x.y + c * Math.sin(M));\n\n                      if (e.addMarkerAngle(S, M - V * Math.PI / 2), e.addMarkerAngle(h, M - V * Math.PI), i.addPoint(h.x, h.y), null != t) {\n                        P = c < u ? u : c;\n                        var k = c < u ? 1 : u / c,\n                            D = c < u ? c / u : 1;\n                        t.translate(x.x, x.y), t.rotate(f), t.scale(k, D), t.arc(0, 0, P, w, w + T, 1 - p), t.scale(1 / k, 1 / D), t.rotate(-f), t.translate(-x.x, -x.y);\n                      }\n                    }\n\n                    break;\n\n                  case \"Z\":\n                  case \"z\":\n                    null != t && i.x1 !== i.x2 && i.y1 !== i.y2 && t.closePath(), e.current = e.start;\n                }\n              }\n\n              return i;\n            }, this.getMarkers = function () {\n              for (var t = this.PathParser.getMarkerPoints(), e = this.PathParser.getMarkerAngles(), i = [], n = 0; n < t.length; n++) {\n                i.push([t[n], e[n]]);\n              }\n\n              return i;\n            };\n          }, A.Element.path.prototype = new A.Element.PathElementBase(), A.Element.pattern = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.createPattern = function (t, e) {\n              var i = this.attribute(\"width\").toPixels(\"x\", !0),\n                  n = this.attribute(\"height\").toPixels(\"y\", !0),\n                  s = new A.Element.svg();\n              s.attributes.viewBox = new A.Property(\"viewBox\", this.attribute(\"viewBox\").value), s.attributes.width = new A.Property(\"width\", i + \"px\"), s.attributes.height = new A.Property(\"height\", n + \"px\"), s.attributes.transform = new A.Property(\"transform\", this.attribute(\"patternTransform\").value), s.children = this.children;\n              var a = p();\n              a.width = i, a.height = n;\n              var r = a.getContext(\"2d\");\n              this.attribute(\"x\").hasValue() && this.attribute(\"y\").hasValue() && r.translate(this.attribute(\"x\").toPixels(\"x\", !0), this.attribute(\"y\").toPixels(\"y\", !0));\n\n              for (var o = -1; o <= 1; o++) {\n                for (var l = -1; l <= 1; l++) {\n                  r.save(), s.attributes.x = new A.Property(\"x\", o * a.width), s.attributes.y = new A.Property(\"y\", l * a.height), s.render(r), r.restore();\n                }\n              }\n\n              return t.createPattern(a, \"repeat\");\n            };\n          }, A.Element.pattern.prototype = new A.Element.ElementBase(), A.Element.marker = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.baseRender = this.render, this.render = function (t, e, i) {\n              if (e) {\n                t.translate(e.x, e.y), \"auto\" == this.attribute(\"orient\").valueOrDefault(\"auto\") && t.rotate(i), \"strokeWidth\" == this.attribute(\"markerUnits\").valueOrDefault(\"strokeWidth\") && t.scale(t.lineWidth, t.lineWidth), t.save();\n                var n = new A.Element.svg();\n                n.attributes.viewBox = new A.Property(\"viewBox\", this.attribute(\"viewBox\").value), n.attributes.refX = new A.Property(\"refX\", this.attribute(\"refX\").value), n.attributes.refY = new A.Property(\"refY\", this.attribute(\"refY\").value), n.attributes.width = new A.Property(\"width\", this.attribute(\"markerWidth\").value), n.attributes.height = new A.Property(\"height\", this.attribute(\"markerHeight\").value), n.attributes.fill = new A.Property(\"fill\", this.attribute(\"fill\").valueOrDefault(\"black\")), n.attributes.stroke = new A.Property(\"stroke\", this.attribute(\"stroke\").valueOrDefault(\"none\")), n.children = this.children, n.render(t), t.restore(), \"strokeWidth\" == this.attribute(\"markerUnits\").valueOrDefault(\"strokeWidth\") && t.scale(1 / t.lineWidth, 1 / t.lineWidth), \"auto\" == this.attribute(\"orient\").valueOrDefault(\"auto\") && t.rotate(-i), t.translate(-e.x, -e.y);\n              }\n            };\n          }, A.Element.marker.prototype = new A.Element.ElementBase(), A.Element.defs = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.render = function (t) {};\n          }, A.Element.defs.prototype = new A.Element.ElementBase(), A.Element.GradientBase = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.stops = [];\n\n            for (var e = 0; e < this.children.length; e++) {\n              var i = this.children[e];\n              \"stop\" == i.type && this.stops.push(i);\n            }\n\n            this.getGradient = function () {}, this.gradientUnits = function () {\n              return this.attribute(\"gradientUnits\").valueOrDefault(\"objectBoundingBox\");\n            }, this.attributesToInherit = [\"gradientUnits\"], this.inheritStopContainer = function (t) {\n              for (var e = 0; e < this.attributesToInherit.length; e++) {\n                var i = this.attributesToInherit[e];\n                !this.attribute(i).hasValue() && t.attribute(i).hasValue() && (this.attribute(i, !0).value = t.attribute(i).value);\n              }\n            }, this.createGradient = function (t, e, i) {\n              var n = this;\n              this.getHrefAttribute().hasValue() && (n = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(n));\n\n              var s = function s(t) {\n                return i.hasValue() ? new A.Property(\"color\", t).addOpacity(i).value : t;\n              },\n                  a = this.getGradient(t, e);\n\n              if (null == a) return s(n.stops[n.stops.length - 1].color);\n\n              for (var r = 0; r < n.stops.length; r++) {\n                a.addColorStop(n.stops[r].offset, s(n.stops[r].color));\n              }\n\n              if (this.attribute(\"gradientTransform\").hasValue()) {\n                var o = A.ViewPort.viewPorts[0],\n                    l = new A.Element.rect();\n                l.attributes.x = new A.Property(\"x\", -A.MAX_VIRTUAL_PIXELS / 3), l.attributes.y = new A.Property(\"y\", -A.MAX_VIRTUAL_PIXELS / 3), l.attributes.width = new A.Property(\"width\", A.MAX_VIRTUAL_PIXELS), l.attributes.height = new A.Property(\"height\", A.MAX_VIRTUAL_PIXELS);\n                var h = new A.Element.g();\n                h.attributes.transform = new A.Property(\"transform\", this.attribute(\"gradientTransform\").value), h.children = [l];\n                var u = new A.Element.svg();\n                u.attributes.x = new A.Property(\"x\", 0), u.attributes.y = new A.Property(\"y\", 0), u.attributes.width = new A.Property(\"width\", o.width), u.attributes.height = new A.Property(\"height\", o.height), u.children = [h];\n                var c = p();\n                c.width = o.width, c.height = o.height;\n                var f = c.getContext(\"2d\");\n                return f.fillStyle = a, u.render(f), f.createPattern(c, \"no-repeat\");\n              }\n\n              return a;\n            };\n          }, A.Element.GradientBase.prototype = new A.Element.ElementBase(), A.Element.linearGradient = function (t) {\n            this.base = A.Element.GradientBase, this.base(t), this.attributesToInherit.push(\"x1\"), this.attributesToInherit.push(\"y1\"), this.attributesToInherit.push(\"x2\"), this.attributesToInherit.push(\"y2\"), this.getGradient = function (t, e) {\n              var i = \"objectBoundingBox\" == this.gradientUnits() ? e.getBoundingBox(t) : null;\n              this.attribute(\"x1\").hasValue() || this.attribute(\"y1\").hasValue() || this.attribute(\"x2\").hasValue() || this.attribute(\"y2\").hasValue() || (this.attribute(\"x1\", !0).value = 0, this.attribute(\"y1\", !0).value = 0, this.attribute(\"x2\", !0).value = 1, this.attribute(\"y2\", !0).value = 0);\n              var n = \"objectBoundingBox\" == this.gradientUnits() ? i.x() + i.width() * this.attribute(\"x1\").numValue() : this.attribute(\"x1\").toPixels(\"x\"),\n                  s = \"objectBoundingBox\" == this.gradientUnits() ? i.y() + i.height() * this.attribute(\"y1\").numValue() : this.attribute(\"y1\").toPixels(\"y\"),\n                  a = \"objectBoundingBox\" == this.gradientUnits() ? i.x() + i.width() * this.attribute(\"x2\").numValue() : this.attribute(\"x2\").toPixels(\"x\"),\n                  r = \"objectBoundingBox\" == this.gradientUnits() ? i.y() + i.height() * this.attribute(\"y2\").numValue() : this.attribute(\"y2\").toPixels(\"y\");\n              return n == a && s == r ? null : t.createLinearGradient(n, s, a, r);\n            };\n          }, A.Element.linearGradient.prototype = new A.Element.GradientBase(), A.Element.radialGradient = function (t) {\n            this.base = A.Element.GradientBase, this.base(t), this.attributesToInherit.push(\"cx\"), this.attributesToInherit.push(\"cy\"), this.attributesToInherit.push(\"r\"), this.attributesToInherit.push(\"fx\"), this.attributesToInherit.push(\"fy\"), this.getGradient = function (t, e) {\n              var i = e.getBoundingBox(t);\n              this.attribute(\"cx\").hasValue() || (this.attribute(\"cx\", !0).value = \"50%\"), this.attribute(\"cy\").hasValue() || (this.attribute(\"cy\", !0).value = \"50%\"), this.attribute(\"r\").hasValue() || (this.attribute(\"r\", !0).value = \"50%\");\n              var n = \"objectBoundingBox\" == this.gradientUnits() ? i.x() + i.width() * this.attribute(\"cx\").numValue() : this.attribute(\"cx\").toPixels(\"x\"),\n                  s = \"objectBoundingBox\" == this.gradientUnits() ? i.y() + i.height() * this.attribute(\"cy\").numValue() : this.attribute(\"cy\").toPixels(\"y\"),\n                  a = n,\n                  r = s;\n              this.attribute(\"fx\").hasValue() && (a = \"objectBoundingBox\" == this.gradientUnits() ? i.x() + i.width() * this.attribute(\"fx\").numValue() : this.attribute(\"fx\").toPixels(\"x\")), this.attribute(\"fy\").hasValue() && (r = \"objectBoundingBox\" == this.gradientUnits() ? i.y() + i.height() * this.attribute(\"fy\").numValue() : this.attribute(\"fy\").toPixels(\"y\"));\n              var o = \"objectBoundingBox\" == this.gradientUnits() ? (i.width() + i.height()) / 2 * this.attribute(\"r\").numValue() : this.attribute(\"r\").toPixels();\n              return t.createRadialGradient(a, r, 0, n, s, o);\n            };\n          }, A.Element.radialGradient.prototype = new A.Element.GradientBase(), A.Element.stop = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.offset = this.attribute(\"offset\").numValue(), this.offset < 0 && (this.offset = 0), 1 < this.offset && (this.offset = 1);\n            var e = this.style(\"stop-color\", !0);\n            \"\" === e.value && (e.value = \"#000\"), this.style(\"stop-opacity\").hasValue() && (e = e.addOpacity(this.style(\"stop-opacity\"))), this.color = e.value;\n          }, A.Element.stop.prototype = new A.Element.ElementBase(), A.Element.AnimateBase = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), A.Animations.push(this), this.duration = 0, this.begin = this.attribute(\"begin\").toMilliseconds(), this.maxDuration = this.begin + this.attribute(\"dur\").toMilliseconds(), this.getProperty = function () {\n              var t = this.attribute(\"attributeType\").value,\n                  e = this.attribute(\"attributeName\").value;\n              return \"CSS\" == t ? this.parent.style(e, !0) : this.parent.attribute(e, !0);\n            }, this.initialValue = null, this.initialUnits = \"\", this.removed = !1, this.calcValue = function () {\n              return \"\";\n            }, this.update = function (t) {\n              if (null == this.initialValue && (this.initialValue = this.getProperty().value, this.initialUnits = this.getProperty().getUnits()), this.duration > this.maxDuration) {\n                if (\"indefinite\" == this.attribute(\"repeatCount\").value || \"indefinite\" == this.attribute(\"repeatDur\").value) this.duration = 0;else if (\"freeze\" != this.attribute(\"fill\").valueOrDefault(\"remove\") || this.frozen) {\n                  if (\"remove\" == this.attribute(\"fill\").valueOrDefault(\"remove\") && !this.removed) return this.removed = !0, this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue, !0;\n                } else this.frozen = !0, this.parent.animationFrozen = !0, this.parent.animationFrozenValue = this.getProperty().value;\n                return !1;\n              }\n\n              this.duration = this.duration + t;\n              var e = !1;\n\n              if (this.begin < this.duration) {\n                var i = this.calcValue();\n                this.attribute(\"type\").hasValue() && (i = this.attribute(\"type\").value + \"(\" + i + \")\"), this.getProperty().value = i, e = !0;\n              }\n\n              return e;\n            }, this.from = this.attribute(\"from\"), this.to = this.attribute(\"to\"), this.values = this.attribute(\"values\"), this.values.hasValue() && (this.values.value = this.values.value.split(\";\")), this.progress = function () {\n              var t = {\n                progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n              };\n\n              if (this.values.hasValue()) {\n                var e = t.progress * (this.values.value.length - 1),\n                    i = Math.floor(e),\n                    n = Math.ceil(e);\n                t.from = new A.Property(\"from\", parseFloat(this.values.value[i])), t.to = new A.Property(\"to\", parseFloat(this.values.value[n])), t.progress = (e - i) / (n - i);\n              } else t.from = this.from, t.to = this.to;\n\n              return t;\n            };\n          }, A.Element.AnimateBase.prototype = new A.Element.ElementBase(), A.Element.animate = function (t) {\n            this.base = A.Element.AnimateBase, this.base(t), this.calcValue = function () {\n              var t = this.progress();\n              return t.from.numValue() + (t.to.numValue() - t.from.numValue()) * t.progress + this.initialUnits;\n            };\n          }, A.Element.animate.prototype = new A.Element.AnimateBase(), A.Element.animateColor = function (t) {\n            this.base = A.Element.AnimateBase, this.base(t), this.calcValue = function () {\n              var t = this.progress(),\n                  e = new m(t.from.value),\n                  i = new m(t.to.value);\n\n              if (e.ok && i.ok) {\n                var n = e.r + (i.r - e.r) * t.progress,\n                    s = e.g + (i.g - e.g) * t.progress,\n                    a = e.b + (i.b - e.b) * t.progress;\n                return \"rgb(\" + parseInt(n, 10) + \",\" + parseInt(s, 10) + \",\" + parseInt(a, 10) + \")\";\n              }\n\n              return this.attribute(\"from\").value;\n            };\n          }, A.Element.animateColor.prototype = new A.Element.AnimateBase(), A.Element.animateTransform = function (t) {\n            this.base = A.Element.AnimateBase, this.base(t), this.calcValue = function () {\n              for (var t = this.progress(), e = A.ToNumberArray(t.from.value), i = A.ToNumberArray(t.to.value), n = \"\", s = 0; s < e.length; s++) {\n                n += e[s] + (i[s] - e[s]) * t.progress + \" \";\n              }\n\n              return n;\n            };\n          }, A.Element.animateTransform.prototype = new A.Element.animate(), A.Element.font = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.horizAdvX = this.attribute(\"horiz-adv-x\").numValue(), this.isRTL = !1, this.isArabic = !1, this.fontFace = null, this.missingGlyph = null, this.glyphs = [];\n\n            for (var e = 0; e < this.children.length; e++) {\n              var i = this.children[e];\n              \"font-face\" == i.type ? (this.fontFace = i).style(\"font-family\").hasValue() && (A.Definitions[i.style(\"font-family\").value] = this) : \"missing-glyph\" == i.type ? this.missingGlyph = i : \"glyph\" == i.type && (\"\" != i.arabicForm ? (this.isRTL = !0, this.isArabic = !0, void 0 === this.glyphs[i.unicode] && (this.glyphs[i.unicode] = []), this.glyphs[i.unicode][i.arabicForm] = i) : this.glyphs[i.unicode] = i);\n            }\n          }, A.Element.font.prototype = new A.Element.ElementBase(), A.Element.fontface = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.ascent = this.attribute(\"ascent\").value, this.descent = this.attribute(\"descent\").value, this.unitsPerEm = this.attribute(\"units-per-em\").numValue();\n          }, A.Element.fontface.prototype = new A.Element.ElementBase(), A.Element.missingglyph = function (t) {\n            this.base = A.Element.path, this.base(t), this.horizAdvX = 0;\n          }, A.Element.missingglyph.prototype = new A.Element.path(), A.Element.glyph = function (t) {\n            this.base = A.Element.path, this.base(t), this.horizAdvX = this.attribute(\"horiz-adv-x\").numValue(), this.unicode = this.attribute(\"unicode\").value, this.arabicForm = this.attribute(\"arabic-form\").value;\n          }, A.Element.glyph.prototype = new A.Element.path(), A.Element.text = function (t) {\n            this.captureTextNodes = !0, this.base = A.Element.RenderedElementBase, this.base(t), this.baseSetContext = this.setContext, this.setContext = function (t) {\n              this.baseSetContext(t);\n              var e = this.style(\"dominant-baseline\").toTextBaseline();\n              null == e && (e = this.style(\"alignment-baseline\").toTextBaseline()), null != e && (t.textBaseline = e);\n            }, this.initializeCoordinates = function (t) {\n              this.x = this.attribute(\"x\").toPixels(\"x\"), this.y = this.attribute(\"y\").toPixels(\"y\"), this.attribute(\"dx\").hasValue() && (this.x += this.attribute(\"dx\").toPixels(\"x\")), this.attribute(\"dy\").hasValue() && (this.y += this.attribute(\"dy\").toPixels(\"y\")), this.x += this.getAnchorDelta(t, this, 0);\n            }, this.getBoundingBox = function (t) {\n              this.initializeCoordinates(t);\n\n              for (var e = null, i = 0; i < this.children.length; i++) {\n                var n = this.getChildBoundingBox(t, this, this, i);\n                null == e ? e = n : e.addBoundingBox(n);\n              }\n\n              return e;\n            }, this.renderChildren = function (t) {\n              this.initializeCoordinates(t);\n\n              for (var e = 0; e < this.children.length; e++) {\n                this.renderChild(t, this, this, e);\n              }\n            }, this.getAnchorDelta = function (t, e, i) {\n              var n = this.style(\"text-anchor\").valueOrDefault(\"start\");\n\n              if (\"start\" != n) {\n                for (var s = 0, a = i; a < e.children.length; a++) {\n                  var r = e.children[a];\n                  if (i < a && r.attribute(\"x\").hasValue()) break;\n                  s += r.measureTextRecursive(t);\n                }\n\n                return -1 * (\"end\" == n ? s : s / 2);\n              }\n\n              return 0;\n            }, this.adjustChildCoordinates = function (t, e, i, n) {\n              var s = i.children[n];\n              return s.attribute(\"x\").hasValue() ? (s.x = s.attribute(\"x\").toPixels(\"x\") + e.getAnchorDelta(t, i, n), s.attribute(\"dx\").hasValue() && (s.x += s.attribute(\"dx\").toPixels(\"x\"))) : (s.attribute(\"dx\").hasValue() && (e.x += s.attribute(\"dx\").toPixels(\"x\")), s.x = e.x), e.x = s.x + s.measureText(t), s.attribute(\"y\").hasValue() ? (s.y = s.attribute(\"y\").toPixels(\"y\"), s.attribute(\"dy\").hasValue() && (s.y += s.attribute(\"dy\").toPixels(\"y\"))) : (s.attribute(\"dy\").hasValue() && (e.y += s.attribute(\"dy\").toPixels(\"y\")), s.y = e.y), e.y = s.y, s;\n            }, this.getChildBoundingBox = function (t, e, i, n) {\n              var s = this.adjustChildCoordinates(t, e, i, n),\n                  a = s.getBoundingBox(t);\n\n              for (n = 0; n < s.children.length; n++) {\n                var r = e.getChildBoundingBox(t, e, s, n);\n                a.addBoundingBox(r);\n              }\n\n              return a;\n            }, this.renderChild = function (t, e, i, n) {\n              var s = this.adjustChildCoordinates(t, e, i, n);\n\n              for (s.render(t), n = 0; n < s.children.length; n++) {\n                e.renderChild(t, e, s, n);\n              }\n            };\n          }, A.Element.text.prototype = new A.Element.RenderedElementBase(), A.Element.TextElementBase = function (t) {\n            this.base = A.Element.RenderedElementBase, this.base(t), this.getGlyph = function (t, e, i) {\n              var n = e[i],\n                  s = null;\n\n              if (t.isArabic) {\n                var a = \"isolated\";\n                (0 == i || \" \" == e[i - 1]) && i < e.length - 2 && \" \" != e[i + 1] && (a = \"terminal\"), 0 < i && \" \" != e[i - 1] && i < e.length - 2 && \" \" != e[i + 1] && (a = \"medial\"), 0 < i && \" \" != e[i - 1] && (i == e.length - 1 || \" \" == e[i + 1]) && (a = \"initial\"), void 0 !== t.glyphs[n] && null == (s = t.glyphs[n][a]) && \"glyph\" == t.glyphs[n].type && (s = t.glyphs[n]);\n              } else s = t.glyphs[n];\n\n              return null == s && (s = t.missingGlyph), s;\n            }, this.renderChildren = function (t) {\n              var e = this.parent.style(\"font-family\").getDefinition();\n              if (null == e) \"stroke\" == t.paintOrder ? (\"\" != t.strokeStyle && t.strokeText(A.compressSpaces(this.getText()), this.x, this.y), \"\" != t.fillStyle && t.fillText(A.compressSpaces(this.getText()), this.x, this.y)) : (\"\" != t.fillStyle && t.fillText(A.compressSpaces(this.getText()), this.x, this.y), \"\" != t.strokeStyle && t.strokeText(A.compressSpaces(this.getText()), this.x, this.y));else {\n                var i = this.parent.style(\"font-size\").numValueOrDefault(A.Font.Parse(A.ctx.font).fontSize),\n                    n = this.parent.style(\"font-style\").valueOrDefault(A.Font.Parse(A.ctx.font).fontStyle),\n                    s = this.getText();\n                e.isRTL && (s = s.split(\"\").reverse().join(\"\"));\n\n                for (var a = A.ToNumberArray(this.parent.attribute(\"dx\").value), r = 0; r < s.length; r++) {\n                  var o = this.getGlyph(e, s, r),\n                      l = i / e.fontFace.unitsPerEm;\n                  t.translate(this.x, this.y), t.scale(l, -l);\n                  var h = t.lineWidth;\n                  t.lineWidth = t.lineWidth * e.fontFace.unitsPerEm / i, \"italic\" == n && t.transform(1, 0, .4, 1, 0, 0), o.render(t), \"italic\" == n && t.transform(1, 0, -.4, 1, 0, 0), t.lineWidth = h, t.scale(1 / l, -1 / l), t.translate(-this.x, -this.y), this.x += i * (o.horizAdvX || e.horizAdvX) / e.fontFace.unitsPerEm, void 0 === a[r] || isNaN(a[r]) || (this.x += a[r]);\n                }\n              }\n            }, this.getText = function () {}, this.measureTextRecursive = function (t) {\n              for (var e = this.measureText(t), i = 0; i < this.children.length; i++) {\n                e += this.children[i].measureTextRecursive(t);\n              }\n\n              return e;\n            }, this.measureText = function (t) {\n              var e = this.parent.style(\"font-family\").getDefinition();\n\n              if (null != e) {\n                var i = this.parent.style(\"font-size\").numValueOrDefault(A.Font.Parse(A.ctx.font).fontSize),\n                    n = 0,\n                    s = this.getText();\n                e.isRTL && (s = s.split(\"\").reverse().join(\"\"));\n\n                for (var a = A.ToNumberArray(this.parent.attribute(\"dx\").value), r = 0; r < s.length; r++) {\n                  n += (this.getGlyph(e, s, r).horizAdvX || e.horizAdvX) * i / e.fontFace.unitsPerEm, void 0 === a[r] || isNaN(a[r]) || (n += a[r]);\n                }\n\n                return n;\n              }\n\n              var o = A.compressSpaces(this.getText());\n              if (!t.measureText) return 10 * o.length;\n              t.save(), this.setContext(t, !0);\n              var l = t.measureText(o).width;\n              return t.restore(), l;\n            }, this.getBoundingBox = function (t) {\n              var e = this.parent.style(\"font-size\").numValueOrDefault(A.Font.Parse(A.ctx.font).fontSize);\n              return new A.BoundingBox(this.x, this.y - e, this.x + this.measureText(t), this.y);\n            };\n          }, A.Element.TextElementBase.prototype = new A.Element.RenderedElementBase(), A.Element.tspan = function (t) {\n            this.captureTextNodes = !0, this.base = A.Element.TextElementBase, this.base(t), this.text = A.compressSpaces(t.value || t.text || t.textContent || \"\"), this.getText = function () {\n              return 0 < this.children.length ? \"\" : this.text;\n            };\n          }, A.Element.tspan.prototype = new A.Element.TextElementBase(), A.Element.tref = function (t) {\n            this.base = A.Element.TextElementBase, this.base(t), this.getText = function () {\n              var t = this.getHrefAttribute().getDefinition();\n              if (null != t) return t.children[0].getText();\n            };\n          }, A.Element.tref.prototype = new A.Element.TextElementBase(), A.Element.a = function (t) {\n            this.base = A.Element.TextElementBase, this.base(t), this.hasText = 0 < t.childNodes.length;\n\n            for (var e = 0; e < t.childNodes.length; e++) {\n              3 != t.childNodes[e].nodeType && (this.hasText = !1);\n            }\n\n            this.text = this.hasText ? t.childNodes[0].value || t.childNodes[0].data : \"\", this.getText = function () {\n              return this.text;\n            }, this.baseRenderChildren = this.renderChildren, this.renderChildren = function (t) {\n              if (this.hasText) {\n                this.baseRenderChildren(t);\n                var e = new A.Property(\"fontSize\", A.Font.Parse(A.ctx.font).fontSize);\n                A.Mouse.checkBoundingBox(this, new A.BoundingBox(this.x, this.y - e.toPixels(\"y\"), this.x + this.measureText(t), this.y));\n              } else if (0 < this.children.length) {\n                var i = new A.Element.g();\n                i.children = this.children, i.parent = this, i.render(t);\n              }\n            }, this.onclick = function () {\n              u.open(this.getHrefAttribute().value);\n            }, this.onmousemove = function () {\n              A.ctx.canvas.style.cursor = \"pointer\";\n            };\n          }, A.Element.a.prototype = new A.Element.TextElementBase(), A.Element.image = function (t) {\n            this.base = A.Element.RenderedElementBase, this.base(t);\n            var e = this.getHrefAttribute().value;\n\n            if (\"\" != e) {\n              var a = e.match(/\\.svg$/);\n              if (A.Images.push(this), this.loaded = !1, a) this.img = A.ajax(e), this.loaded = !0;else {\n                this.img = document.createElement(\"img\"), 1 == A.opts.useCORS && (this.img.crossOrigin = \"Anonymous\");\n                var r = this;\n                this.img.onload = function () {\n                  r.loaded = !0;\n                }, this.img.onerror = function () {\n                  A.log('ERROR: image \"' + e + '\" not found'), r.loaded = !0;\n                }, this.img.src = e;\n              }\n              this.renderChildren = function (t) {\n                var e = this.attribute(\"x\").toPixels(\"x\"),\n                    i = this.attribute(\"y\").toPixels(\"y\"),\n                    n = this.attribute(\"width\").toPixels(\"x\"),\n                    s = this.attribute(\"height\").toPixels(\"y\");\n                0 != n && 0 != s && (t.save(), a ? t.drawSvg(this.img, e, i, n, s) : (t.translate(e, i), A.AspectRatio(t, this.attribute(\"preserveAspectRatio\").value, n, this.img.width, s, this.img.height, 0, 0), r.loaded && (void 0 === this.img.complete || this.img.complete) && t.drawImage(this.img, 0, 0)), t.restore());\n              }, this.getBoundingBox = function () {\n                var t = this.attribute(\"x\").toPixels(\"x\"),\n                    e = this.attribute(\"y\").toPixels(\"y\"),\n                    i = this.attribute(\"width\").toPixels(\"x\"),\n                    n = this.attribute(\"height\").toPixels(\"y\");\n                return new A.BoundingBox(t, e, t + i, e + n);\n              };\n            }\n          }, A.Element.image.prototype = new A.Element.RenderedElementBase(), A.Element.g = function (t) {\n            this.base = A.Element.RenderedElementBase, this.base(t), this.getBoundingBox = function (t) {\n              for (var e = new A.BoundingBox(), i = 0; i < this.children.length; i++) {\n                e.addBoundingBox(this.children[i].getBoundingBox(t));\n              }\n\n              return e;\n            };\n          }, A.Element.g.prototype = new A.Element.RenderedElementBase(), A.Element.symbol = function (t) {\n            this.base = A.Element.RenderedElementBase, this.base(t), this.render = function (t) {};\n          }, A.Element.symbol.prototype = new A.Element.RenderedElementBase(), A.Element.style = function (t) {\n            this.base = A.Element.ElementBase, this.base(t);\n\n            for (var e = \"\", i = 0; i < t.childNodes.length; i++) {\n              e += t.childNodes[i].data;\n            }\n\n            e = e.replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\");\n            var n = (e = A.compressSpaces(e)).split(\"}\");\n\n            for (i = 0; i < n.length; i++) {\n              if (\"\" != A.trim(n[i])) for (var s = n[i].split(\"{\"), a = s[0].split(\",\"), r = s[1].split(\";\"), o = 0; o < a.length; o++) {\n                var l = A.trim(a[o]);\n\n                if (\"\" != l) {\n                  for (var h = A.Styles[l] || {}, u = 0; u < r.length; u++) {\n                    var c = r[u].indexOf(\":\"),\n                        f = r[u].substr(0, c),\n                        m = r[u].substr(c + 1, r[u].length - c);\n                    null != f && null != m && (h[A.trim(f)] = new A.Property(A.trim(f), A.trim(m)));\n                  }\n\n                  if (A.Styles[l] = h, A.StylesSpecificity[l] = w(l), \"@font-face\" == l) for (var p = h[\"font-family\"].value.replace(/\"/g, \"\"), d = h.src.value.split(\",\"), y = 0; y < d.length; y++) {\n                    if (0 < d[y].indexOf('format(\"svg\")')) for (var v = d[y].indexOf(\"url\"), g = d[y].indexOf(\")\", v), x = d[y].substr(v + 5, g - v - 6), b = A.parseXml(A.ajax(x)).getElementsByTagName(\"font\"), P = 0; P < b.length; P++) {\n                      var E = A.CreateElement(b[P]);\n                      A.Definitions[p] = E;\n                    }\n                  }\n                }\n              }\n            }\n          }, A.Element.style.prototype = new A.Element.ElementBase(), A.Element.use = function (t) {\n            this.base = A.Element.RenderedElementBase, this.base(t), this.baseSetContext = this.setContext, this.setContext = function (t) {\n              this.baseSetContext(t), this.attribute(\"x\").hasValue() && t.translate(this.attribute(\"x\").toPixels(\"x\"), 0), this.attribute(\"y\").hasValue() && t.translate(0, this.attribute(\"y\").toPixels(\"y\"));\n            };\n            var n = this.getHrefAttribute().getDefinition();\n            this.path = function (t) {\n              null != n && n.path(t);\n            }, this.elementTransform = function () {\n              if (null != n && n.style(\"transform\", !1, !0).hasValue()) return new A.Transform(n.style(\"transform\", !1, !0).value);\n            }, this.getBoundingBox = function (t) {\n              if (null != n) return n.getBoundingBox(t);\n            }, this.renderChildren = function (t) {\n              if (null != n) {\n                var e = n;\n                \"symbol\" == n.type && ((e = new A.Element.svg()).type = \"svg\", e.attributes.viewBox = new A.Property(\"viewBox\", n.attribute(\"viewBox\").value), e.attributes.preserveAspectRatio = new A.Property(\"preserveAspectRatio\", n.attribute(\"preserveAspectRatio\").value), e.attributes.overflow = new A.Property(\"overflow\", n.attribute(\"overflow\").value), e.children = n.children), \"svg\" == e.type && (this.attribute(\"width\").hasValue() && (e.attributes.width = new A.Property(\"width\", this.attribute(\"width\").value)), this.attribute(\"height\").hasValue() && (e.attributes.height = new A.Property(\"height\", this.attribute(\"height\").value)));\n                var i = e.parent;\n                e.parent = null, e.render(t), e.parent = i;\n              }\n            };\n          }, A.Element.use.prototype = new A.Element.RenderedElementBase(), A.Element.mask = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.apply = function (t, e) {\n              var i = this.attribute(\"x\").toPixels(\"x\"),\n                  n = this.attribute(\"y\").toPixels(\"y\"),\n                  s = this.attribute(\"width\").toPixels(\"x\"),\n                  a = this.attribute(\"height\").toPixels(\"y\");\n\n              if (0 == s && 0 == a) {\n                for (var r = new A.BoundingBox(), o = 0; o < this.children.length; o++) {\n                  r.addBoundingBox(this.children[o].getBoundingBox(t));\n                }\n\n                i = Math.floor(r.x1), n = Math.floor(r.y1), s = Math.floor(r.width()), a = Math.floor(r.height());\n              }\n\n              var l = e.attribute(\"mask\").value;\n              e.attribute(\"mask\").value = \"\";\n              var h = p();\n              h.width = i + s, h.height = n + a;\n              var u = h.getContext(\"2d\");\n              this.renderChildren(u);\n              var c = p();\n              c.width = i + s, c.height = n + a;\n              var f = c.getContext(\"2d\");\n              e.render(f), f.globalCompositeOperation = \"destination-in\", f.fillStyle = u.createPattern(h, \"no-repeat\"), f.fillRect(0, 0, i + s, n + a), t.fillStyle = f.createPattern(c, \"no-repeat\"), t.fillRect(0, 0, i + s, n + a), e.attribute(\"mask\").value = l;\n            }, this.render = function (t) {};\n          }, A.Element.mask.prototype = new A.Element.ElementBase(), A.Element.clipPath = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.apply = function (t) {\n              var e = \"undefined\" != typeof CanvasRenderingContext2D,\n                  i = t.beginPath,\n                  n = t.closePath;\n              e && (CanvasRenderingContext2D.prototype.beginPath = function () {}, CanvasRenderingContext2D.prototype.closePath = function () {}), i.call(t);\n\n              for (var s = 0; s < this.children.length; s++) {\n                var a = this.children[s];\n\n                if (void 0 !== a.path) {\n                  var r = void 0 !== a.elementTransform && a.elementTransform();\n                  !r && a.style(\"transform\", !1, !0).hasValue() && (r = new A.Transform(a.style(\"transform\", !1, !0).value)), r && r.apply(t), a.path(t), e && (CanvasRenderingContext2D.prototype.closePath = n), r && r.unapply(t);\n                }\n              }\n\n              n.call(t), t.clip(), e && (CanvasRenderingContext2D.prototype.beginPath = i, CanvasRenderingContext2D.prototype.closePath = n);\n            }, this.render = function (t) {};\n          }, A.Element.clipPath.prototype = new A.Element.ElementBase(), A.Element.filter = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.apply = function (t, e) {\n              var i = e.getBoundingBox(t),\n                  n = Math.floor(i.x1),\n                  s = Math.floor(i.y1),\n                  a = Math.floor(i.width()),\n                  r = Math.floor(i.height()),\n                  o = e.style(\"filter\").value;\n              e.style(\"filter\").value = \"\";\n\n              for (var l = 0, h = 0, u = 0; u < this.children.length; u++) {\n                var c = this.children[u].extraFilterDistance || 0;\n                l = Math.max(l, c), h = Math.max(h, c);\n              }\n\n              var f = p();\n              f.width = a + 2 * l, f.height = r + 2 * h;\n              var m = f.getContext(\"2d\");\n\n              for (m.translate(-n + l, -s + h), e.render(m), u = 0; u < this.children.length; u++) {\n                \"function\" == typeof this.children[u].apply && this.children[u].apply(m, 0, 0, a + 2 * l, r + 2 * h);\n              }\n\n              t.drawImage(f, 0, 0, a + 2 * l, r + 2 * h, n - l, s - h, a + 2 * l, r + 2 * h), e.style(\"filter\", !0).value = o;\n            }, this.render = function (t) {};\n          }, A.Element.filter.prototype = new A.Element.ElementBase(), A.Element.feMorphology = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.apply = function (t, e, i, n, s) {};\n          }, A.Element.feMorphology.prototype = new A.Element.ElementBase(), A.Element.feComposite = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.apply = function (t, e, i, n, s) {};\n          }, A.Element.feComposite.prototype = new A.Element.ElementBase(), A.Element.feColorMatrix = function (t) {\n            this.base = A.Element.ElementBase, this.base(t);\n            var n = A.ToNumberArray(this.attribute(\"values\").value);\n\n            switch (this.attribute(\"type\").valueOrDefault(\"matrix\")) {\n              case \"saturate\":\n                var e = n[0];\n                n = [.213 + .787 * e, .715 - .715 * e, .072 - .072 * e, 0, 0, .213 - .213 * e, .715 + .285 * e, .072 - .072 * e, 0, 0, .213 - .213 * e, .715 - .715 * e, .072 + .928 * e, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n                break;\n\n              case \"hueRotate\":\n                var s = n[0] * Math.PI / 180,\n                    i = function i(t, e, _i) {\n                  return t + Math.cos(s) * e + Math.sin(s) * _i;\n                };\n\n                n = [i(.213, .787, -.213), i(.715, -.715, -.715), i(.072, -.072, .928), 0, 0, i(.213, -.213, .143), i(.715, .285, .14), i(.072, -.072, -.283), 0, 0, i(.213, -.213, -.787), i(.715, -.715, .715), i(.072, .928, .072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n                break;\n\n              case \"luminanceToAlpha\":\n                n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, .2125, .7154, .0721, 0, 0, 0, 0, 0, 0, 1];\n            }\n\n            function u(t, e, i, n, s, a) {\n              return t[i * n * 4 + 4 * e + a];\n            }\n\n            function c(t, e, i, n, s, a, r) {\n              t[i * n * 4 + 4 * e + a] = r;\n            }\n\n            function f(t, e) {\n              var i = n[t];\n              return i * (i < 0 ? e - 255 : e);\n            }\n\n            this.apply = function (t, e, i, n, s) {\n              var a = t.getImageData(0, 0, n, s);\n\n              for (i = 0; i < s; i++) {\n                for (e = 0; e < n; e++) {\n                  var r = u(a.data, e, i, n, 0, 0),\n                      o = u(a.data, e, i, n, 0, 1),\n                      l = u(a.data, e, i, n, 0, 2),\n                      h = u(a.data, e, i, n, 0, 3);\n                  c(a.data, e, i, n, 0, 0, f(0, r) + f(1, o) + f(2, l) + f(3, h) + f(4, 1)), c(a.data, e, i, n, 0, 1, f(5, r) + f(6, o) + f(7, l) + f(8, h) + f(9, 1)), c(a.data, e, i, n, 0, 2, f(10, r) + f(11, o) + f(12, l) + f(13, h) + f(14, 1)), c(a.data, e, i, n, 0, 3, f(15, r) + f(16, o) + f(17, l) + f(18, h) + f(19, 1));\n                }\n              }\n\n              t.clearRect(0, 0, n, s), t.putImageData(a, 0, 0);\n            };\n          }, A.Element.feColorMatrix.prototype = new A.Element.ElementBase(), A.Element.feGaussianBlur = function (t) {\n            this.base = A.Element.ElementBase, this.base(t), this.blurRadius = Math.floor(this.attribute(\"stdDeviation\").numValue()), this.extraFilterDistance = this.blurRadius, this.apply = function (t, e, i, n, s) {\n              d && void 0 !== d.canvasRGBA ? (t.canvas.id = A.UniqueId(), t.canvas.style.display = \"none\", document.body.appendChild(t.canvas), d.canvasRGBA(t.canvas, e, i, n, s, this.blurRadius), document.body.removeChild(t.canvas)) : A.log(\"ERROR: StackBlur.js must be included for blur to work\");\n            };\n          }, A.Element.feGaussianBlur.prototype = new A.Element.ElementBase(), A.Element.title = function (t) {}, A.Element.title.prototype = new A.Element.ElementBase(), A.Element.desc = function (t) {}, A.Element.desc.prototype = new A.Element.ElementBase(), A.Element.MISSING = function (t) {\n            A.log(\"ERROR: Element '\" + t.nodeName + \"' not yet implemented.\");\n          }, A.Element.MISSING.prototype = new A.Element.ElementBase(), A.CreateElement = function (t) {\n            var e = t.nodeName.replace(/^[^:]+:/, \"\");\n            e = e.replace(/\\-/g, \"\");\n            var i = null;\n            return (i = void 0 !== A.Element[e] ? new A.Element[e](t) : new A.Element.MISSING(t)).type = t.nodeName, i;\n          }, A.load = function (t, e) {\n            A.loadXml(t, A.ajax(e));\n          }, A.loadXml = function (t, e) {\n            A.loadXmlDoc(t, A.parseXml(e));\n          }, A.loadXmlDoc = function (a, r) {\n            A.init(a);\n\n            var i = function i(t) {\n              for (var e = a.canvas; e;) {\n                t.x -= e.offsetLeft, t.y -= e.offsetTop, e = e.offsetParent;\n              }\n\n              return u.scrollX && (t.x += u.scrollX), u.scrollY && (t.y += u.scrollY), t;\n            };\n\n            1 != A.opts.ignoreMouse && (a.canvas.onclick = function (t) {\n              var e = i(new A.Point(null != t ? t.clientX : event.clientX, null != t ? t.clientY : event.clientY));\n              A.Mouse.onclick(e.x, e.y);\n            }, a.canvas.onmousemove = function (t) {\n              var e = i(new A.Point(null != t ? t.clientX : event.clientX, null != t ? t.clientY : event.clientY));\n              A.Mouse.onmousemove(e.x, e.y);\n            });\n            var o = A.CreateElement(r.documentElement);\n            o.root = !0, o.addStylesFromStyleDefinition();\n\n            var l = !0,\n                n = function n() {\n              A.ViewPort.Clear(), a.canvas.parentNode ? A.ViewPort.SetCurrent(a.canvas.parentNode.clientWidth, a.canvas.parentNode.clientHeight) : A.ViewPort.SetCurrent(800, 600), 1 != A.opts.ignoreDimensions && (o.style(\"width\").hasValue() && (a.canvas.width = o.style(\"width\").toPixels(\"x\"), a.canvas.style && (a.canvas.style.width = a.canvas.width + \"px\")), o.style(\"height\").hasValue() && (a.canvas.height = o.style(\"height\").toPixels(\"y\"), a.canvas.style && (a.canvas.style.height = a.canvas.height + \"px\")));\n              var t = a.canvas.clientWidth || a.canvas.width,\n                  e = a.canvas.clientHeight || a.canvas.height;\n\n              if (1 == A.opts.ignoreDimensions && o.style(\"width\").hasValue() && o.style(\"height\").hasValue() && (t = o.style(\"width\").toPixels(\"x\"), e = o.style(\"height\").toPixels(\"y\")), A.ViewPort.SetCurrent(t, e), null != A.opts.offsetX && (o.attribute(\"x\", !0).value = A.opts.offsetX), null != A.opts.offsetY && (o.attribute(\"y\", !0).value = A.opts.offsetY), null != A.opts.scaleWidth || null != A.opts.scaleHeight) {\n                var i = null,\n                    n = null,\n                    s = A.ToNumberArray(o.attribute(\"viewBox\").value);\n                null != A.opts.scaleWidth && (o.attribute(\"width\").hasValue() ? i = o.attribute(\"width\").toPixels(\"x\") / A.opts.scaleWidth : isNaN(s[2]) || (i = s[2] / A.opts.scaleWidth)), null != A.opts.scaleHeight && (o.attribute(\"height\").hasValue() ? n = o.attribute(\"height\").toPixels(\"y\") / A.opts.scaleHeight : isNaN(s[3]) || (n = s[3] / A.opts.scaleHeight)), null == i && (i = n), null == n && (n = i), o.attribute(\"width\", !0).value = A.opts.scaleWidth, o.attribute(\"height\", !0).value = A.opts.scaleHeight, o.style(\"transform\", !0, !0).value += \" scale(\" + 1 / i + \",\" + 1 / n + \")\";\n              }\n\n              1 != A.opts.ignoreClear && a.clearRect(0, 0, t, e), o.render(a), l && (l = !1, \"function\" == typeof A.opts.renderCallback && A.opts.renderCallback(r));\n            },\n                s = !0;\n\n            A.ImagesLoaded() && (s = !1, n()), A.intervalID = setInterval(function () {\n              var t = !1;\n              if (s && A.ImagesLoaded() && (t = !(s = !1)), 1 != A.opts.ignoreMouse && (t |= A.Mouse.hasEvents()), 1 != A.opts.ignoreAnimation) for (var e = 0; e < A.Animations.length; e++) {\n                t |= A.Animations[e].update(1e3 / A.FRAMERATE);\n              }\n              \"function\" == typeof A.opts.forceRedraw && 1 == A.opts.forceRedraw() && (t = !0), t && (n(), A.Mouse.runEvents());\n            }, 1e3 / A.FRAMERATE);\n          }, A.stop = function () {\n            A.intervalID && clearInterval(A.intervalID);\n          }, A.Mouse = new function () {\n            this.events = [], this.hasEvents = function () {\n              return 0 != this.events.length;\n            }, this.onclick = function (t, e) {\n              this.events.push({\n                type: \"onclick\",\n                x: t,\n                y: e,\n                run: function run(t) {\n                  t.onclick && t.onclick();\n                }\n              });\n            }, this.onmousemove = function (t, e) {\n              this.events.push({\n                type: \"onmousemove\",\n                x: t,\n                y: e,\n                run: function run(t) {\n                  t.onmousemove && t.onmousemove();\n                }\n              });\n            }, this.eventElements = [], this.checkPath = function (t, e) {\n              for (var i = 0; i < this.events.length; i++) {\n                var n = this.events[i];\n                e.isPointInPath && e.isPointInPath(n.x, n.y) && (this.eventElements[i] = t);\n              }\n            }, this.checkBoundingBox = function (t, e) {\n              for (var i = 0; i < this.events.length; i++) {\n                var n = this.events[i];\n                e.isPointInBox(n.x, n.y) && (this.eventElements[i] = t);\n              }\n            }, this.runEvents = function () {\n              A.ctx.canvas.style.cursor = \"\";\n\n              for (var t = 0; t < this.events.length; t++) {\n                for (var e = this.events[t], i = this.eventElements[t]; i;) {\n                  e.run(i), i = i.parent;\n                }\n              }\n\n              this.events = [], this.eventElements = [];\n            };\n          }(), A;\n        }(i || {});\n\n        \"string\" == typeof t && (t = document.getElementById(t)), null != t.svg && t.svg.stop(), t.childNodes && 1 == t.childNodes.length && \"OBJECT\" == t.childNodes[0].nodeName || (t.svg = n);\n        var s = t.getContext(\"2d\");\n        void 0 !== e.documentElement ? n.loadXmlDoc(s, e) : \"<\" == e.substr(0, 1) ? n.loadXml(s, e) : n.load(s, e);\n      } else for (var a = document.querySelectorAll(\"svg\"), r = 0; r < a.length; r++) {\n        var o = a[r],\n            l = document.createElement(\"canvas\");\n        l.width = o.clientWidth, l.height = o.clientHeight, o.parentNode.insertBefore(l, o), o.parentNode.removeChild(o);\n        var h = document.createElement(\"div\");\n        h.appendChild(o), c(l, h.innerHTML);\n      }\n    };\n\n    \"undefined\" == typeof Element || (void 0 !== Element.prototype.matches ? f = function f(t, e) {\n      return t.matches(e);\n    } : void 0 !== Element.prototype.webkitMatchesSelector ? f = function f(t, e) {\n      return t.webkitMatchesSelector(e);\n    } : void 0 !== Element.prototype.mozMatchesSelector ? f = function f(t, e) {\n      return t.mozMatchesSelector(e);\n    } : void 0 !== Element.prototype.msMatchesSelector ? f = function f(t, e) {\n      return t.msMatchesSelector(e);\n    } : void 0 !== Element.prototype.oMatchesSelector ? f = function f(t, e) {\n      return t.oMatchesSelector(e);\n    } : (\"function\" != typeof jQuery && \"function\" != typeof Zepto || (f = function f(t, e) {\n      return $(t).is(e);\n    }), void 0 === f && \"undefined\" != typeof Sizzle && (f = Sizzle.matchesSelector)));\n    var e = /(\\[[^\\]]+\\])/g,\n        i = /(#[^\\s\\+>~\\.\\[:]+)/g,\n        a = /(\\.[^\\s\\+>~\\.\\[:]+)/g,\n        r = /(::[^\\s\\+>~\\.\\[:]+|:first-line|:first-letter|:before|:after)/gi,\n        o = /(:[\\w-]+\\([^\\)]*\\))/gi,\n        l = /(:[^\\s\\+>~\\.\\[:]+)/g,\n        h = /([^\\s\\+>~\\.\\[:]+)/g;\n\n    function w(n) {\n      var s = [0, 0, 0],\n          t = function t(_t, e) {\n        var i = n.match(_t);\n        null != i && (s[e] += i.length, n = n.replace(_t, \" \"));\n      };\n\n      return n = (n = n.replace(/:not\\(([^\\)]*)\\)/g, \"     $1 \")).replace(/{[\\s\\S]*/gm, \" \"), t(e, 1), t(i, 0), t(a, 1), t(r, 2), t(o, 1), t(l, 1), n = (n = n.replace(/[\\*\\s\\+>~]/g, \" \")).replace(/[#\\.]/g, \" \"), t(h, 2), s.join(\"\");\n    }\n\n    \"undefined\" != typeof CanvasRenderingContext2D && (CanvasRenderingContext2D.prototype.drawSvg = function (t, e, i, n, s, a) {\n      var r = {\n        ignoreMouse: !0,\n        ignoreAnimation: !0,\n        ignoreDimensions: !0,\n        ignoreClear: !0,\n        offsetX: e,\n        offsetY: i,\n        scaleWidth: n,\n        scaleHeight: s\n      };\n\n      for (var o in a) {\n        a.hasOwnProperty(o) && (r[o] = a[o]);\n      }\n\n      c(this.canvas, t, r);\n    }), t.exports = c;\n  }(t = {\n    exports: {}\n  }, t.exports), t.exports;\n});","map":null,"metadata":{},"sourceType":"script"}